<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">

<meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="apple-touch-icon" href="https://files.catbox.moe/g2x30e.png">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <title>Phone</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Noto+Sans+SC:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        @font-face { font-family: 'bulangni'; src: url('') format('truetype'); font-weight: normal; font-style: normal; font-display: swap; }
        :root { 
            --screen-width: 350px; 
            --screen-height: 650px; 
            --secondary-bg: #ffffff; 
            --border-color: #e0e0e0; 
            --text-primary: #1E1E1E; 
            --text-secondary: #6B6B6B; 
            --accent-color: #1E1E1E;
            --world-book-bg: #F7F7F7;
            --glass-bg: rgba(255, 255, 255, 0.7);
            --glass-border: rgba(255, 255, 255, 0.4);
        }
        html {
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100);
            overflow: hidden;
        }

/* ▼▼▼ 请用下面这【一整块】全新的代码，替换掉所有旧的 body, phone-frame, phone-screen 等样式 ▼▼▼ */

      /*ios底部兼容*/
         body.ios{
             padding-bottom: 0;
         }
        body.ios #chat-list-bottom-nav{
             padding-bottom: 20px;
         }

/* 1. 重置 body，使其成为一个干净的画布 */
body {
    height: 100vh;
    height: calc(var(--vh, 1vh) * 100);
    overflow: hidden;
    margin: 0;
    padding: 0;
    font-family: 'Inter', 'Noto Sans SC', 'bulangni', -apple-system, BlinkMacSystemFont, "Segue UI", Roboto, Helvetica, Arial, sans-serif;
    font-weight: normal;
    background-color: #F7F7F7;
}

/* 2. 让 #phone-screen 成为新的“根”容器，撑满整个浏览器窗口 */
#phone-screen {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    background-color: #000; /* 保留一个默认的黑色背景 */
}

/* 4. 【核心】让所有页面的头部自动适应iPhone的“刘海”安全区 */
.header, .qzone-header {
    /* 使用 env(safe-area-inset-top) 自动获取顶部安全距离 */
    padding-top: calc(0px + env(safe-area-inset-top));
}

/* 5. 【核心】让聊天输入框和底部导航栏自动适应iPhone底部的“小黑条”安全区 */
#chat-input-area {
    padding-bottom: calc(8px + env(safe-area-inset-bottom));
}

        .screen { width: 100%; height: 100%; position: absolute; top: 0; left: 0; display: flex; flex-direction: column; overflow: hidden; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
        .screen.active { opacity: 1; visibility: visible; z-index: 1; }
        .header { position: relative; z-index: 15; flex-shrink: 0; padding: 20px 20px; padding-top: calc(20px + env(safe-area-inset-top)); background-color: #F7F7F7; border-bottom: 1px solid #E0E0E0; display: flex; justify-content: space-between; align-items: center; font-size: 18px; font-weight: 600; color: var(--text-primary); min-height: 20px; }
        
        #world-book-screen .header { box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }
        .header .header-actions { display: flex; align-items: center; gap: 5px; }
        .header .back-btn, .header .action-btn { font-size: 24px; cursor: pointer; width: 30px; text-align: center; color: var(--accent-color); display: flex; align-items: center; justify-content: center; }
        /* 圆形SVG按钮样式 */
        .circle-btn { width: 30px; height: 30px; border-radius: 50%; background-color: #1E1E1E; border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: opacity 0.2s; }
        .circle-btn:hover { opacity: 0.8; }
        .circle-btn svg { width: 16px; height: 16px; fill: white; }
        .circle-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .circle-btn:disabled:hover { opacity: 0.4; }
        
        #world-book-screen .header .back-btn { color: var(--text-primary); }

.header .action-btn {
    font-size: 16px; /* 专门为"上传"、"+"等文字按钮缩小字号 */
    font-weight: 600; /* 可以加粗一点让它更清晰 */
}

#world-book-screen .header .action-btn {
    color: var(--text-secondary);
}

        .header .action-btn img { height: 26px; }
        .header .save-btn { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; }
        /* 完成按钮的圆形样式 */
        .save-btn.circle-btn { width: 30px; height: 30px; }
        #home-screen { display: flex; flex-direction: column; justify-content: flex-start; align-items: center; padding: 20px; padding-top: 80px; padding-bottom: 50px; box-sizing: border-box; background-size: cover; background-position: center; }
        #clock-container { text-align: center; color: white; text-shadow: 0 3px 8px rgba(0,0,0,0.4); margin-bottom: 20px; flex-shrink: 0; }
        #main-time { font-size: 80px; font-weight: 200; }
        #main-date { font-size: 18px; font-weight: 500; }
        #app-grid { margin-top: auto; display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%; padding: 20px; }
        .app-row { display: flex; justify-content: center; gap: 25px; width: 100%; }
        .app-icon { display: flex; flex-direction: column; align-items: center; cursor: pointer; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5); font-size: 14px; font-weight: 500; text-align: center; }
        .app-icon .icon-bg { width: 65px; height: 65px; border-radius: 18px; background-color: var(--secondary-bg); display: flex; justify-content: center; align-items: center; font-size: 32px; margin-bottom: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); transition: transform 0.2s ease; overflow: hidden; }
        .app-icon:active .icon-bg { transform: scale(0.9); }
        .app-icon .icon-bg img { width: 100%; height: 100%; object-fit: cover; }
        .app-icon .label { color: white; }
        .form-container, .list-container { padding: 20px; overflow-y: auto; flex-grow: 1; display:flex; flex-direction: column;background-color: #F7F7F7; }
        .form-group { margin-bottom: 20px; }
        
        /* 【新增】群聊互通记忆开关样式 */
        .memory-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
            flex-shrink: 0;
        }
        
        .memory-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .memory-switch-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #DCDCDC;
            border-radius: 24px;
            transition: background-color 0.2s ease-in-out;
        }
        
        .memory-switch-slider::before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 2px;
            bottom: 2px;
            background-color: #FFFFFF;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease-in-out;
        }
        
        .memory-switch input:checked + .memory-switch-slider {
            background-color: #1E1E1E;
        }
        
        .memory-switch input:checked + .memory-switch-slider::before {
            transform: translateX(20px);
        }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-secondary); }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; }
        .form-group textarea { min-height: 80px; resize: vertical; }
        #world-book-content-input { height: calc(100% - 120px); }
        .form-button { width: 100%; padding: 15px; background-color: var(--accent-color); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 10px; }
        .form-button-secondary { background-color: #f0f0f0; color: var(--text-primary); border: 1px solid var(--border-color); }
        #wallpaper-screen .form-container { align-items: flex-start; }
        
        /* 新增：预览界面容器样式 */
        .preview-container {
            display: flex;
            gap: 20px;
            width: 100%;
            margin-bottom: 20px;
        }
        
        .preview-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        /* 预览区域按钮样式 */
        .preview-section .form-button {
            width: 180px;
            margin-top: 0;
        }
        #wallpaper-preview { width: 180px; height: 320px; border: 2px dashed var(--border-color); background-color: #F7F7F7; margin-bottom: 20px; background-size: cover; background-position: center; border-radius: 10px; display: flex; justify-content: center; align-items: center; color: var(--text-secondary); }
        #wallpaper-upload-input { display: none; }
        
        /* 聊天背景预览样式 */
        #chat-background-preview { width: 180px; height: 320px; border: 2px dashed var(--border-color); background-color: #F7F7F7; margin-bottom: 20px; background-size: cover; background-position: center; border-radius: 10px; display: flex; justify-content: center; align-items: center; color: var(--text-secondary); }
        #chat-background-upload-input { display: none; }
/* world-book相关页面背景样式 */
#world-book-screen,
#world-book-editor-screen {
    background-color: var(--world-book-bg);
}

/* 修改后的 #world-book-list 样式 */
#world-book-list {
    flex-grow: 1;
    overflow-y: auto;
    background-color: transparent;
    padding: 20px;
    padding-top: 20px;
}

/* 毛玻璃容器核心样式 */
.glass-container {
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.4);
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
    margin-bottom: 16px;
    overflow: hidden !important;
    transition: all 0.3s ease;
    /* 解决边缘锯齿问题 */
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
    /* 强制硬件加速 */
    will-change: transform;
    /* 确保圆角边界完全生效 */
    -webkit-mask-image: -webkit-radial-gradient(white, black);
    mask-image: radial-gradient(white, black);
}

/* 分类标题的毛玻璃容器 */
.glass-container.category-header {
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.4);
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
    margin-bottom: 8px;
    overflow: hidden;
    /* 解决边缘锯齿问题 */
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
    /* 强制硬件加速 */
    will-change: transform;
}

/* 内容列表的毛玻璃容器 */
.glass-container.content-list {
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.4);
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
    margin-bottom: 16px;
    overflow: hidden;
    /* 解决边缘锯齿问题 */
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
    /* 强制硬件加速 */
    will-change: transform;
}

.glass-container.empty-state {
    margin-top: 40px;
}

.glass-content {
    padding: 0;
    background: transparent;
}

/* 列表项样式优化 */
.glass-container .list-item {
    border-bottom: 1px solid rgba(255, 255, 255, 0.15);
    margin: 0;
    background: transparent;
    position: relative;
    padding: 16px 20px;
    transition: background-color 0.2s ease;
}

.glass-container .list-item:first-child {
    border-top: none;
}

.glass-container .list-item:last-child {
    border-bottom: none;
}

.glass-container .list-item:hover {
    background-color: rgba(255, 255, 255, 0.2);
}

.glass-container .list-item .item-title {
    font-weight: 500;
    font-size: 16px;
    color: var(--text-primary);
    margin-bottom: 4px;
}

.glass-container .list-item .item-content {
    font-size: 14px;
    color: var(--text-secondary);
    line-height: 1.4;
}

/* 分组标题样式优化 */
.glass-container .world-book-group-header {
    background: transparent;
    margin: 0;
    padding: 12px 20px;
}

/* 移除hover悬浮效果 */

/* ▼▼▼ 晴空设计方案样式 ▼▼▼ */

/* 输入框样式 */
.input-field, 
#world-book-unified-modal input[type="text"],
#world-book-unified-modal textarea,
#world-book-unified-modal select,
.form-group input,
.form-group textarea,
.form-group select {
    background-color: #FFFFFF !important;
    color: #1E1E1E !important;
    border: 1px solid #DCDCDC !important;
    border-radius: 8px !important;
    padding: 12px 16px !important;
    font-size: 16px !important;
    transition: all 0.2s ease-in-out !important;
    box-sizing: border-box !important;
}

.input-field::placeholder,
#world-book-unified-modal input[type="text"]::placeholder,
#world-book-unified-modal textarea::placeholder {
    color: #A0A0A0 !important;
}

.input-field:focus,
#world-book-unified-modal input[type="text"]:focus,
#world-book-unified-modal textarea:focus,
#world-book-unified-modal select:focus,
.form-group input:focus,
.form-group textarea:focus,
.form-group select:focus {
    outline: none !important;
    border-color: #1E1E1E !important;
    box-shadow: 0 0 0 3px rgba(30, 30, 30, 0.1) !important;
}

/* 主按钮样式 */
.primary-button,
#save-world-book-btn,
#add-new-category-btn,
#close-category-manager-btn,
.form-button,
.save {
    background-color: #1E1E1E !important;
    color: #FFFFFF !important;
    border: none !important;
    border-radius: 8px !important;
    padding: 10px 20px !important;
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
}

.primary-button:hover,
#save-world-book-btn:hover,
#add-new-category-btn:hover,
#close-category-manager-btn:hover,
.form-button:hover,
.save:hover {
    background-color: #000000 !important;
    transform: translateY(-2px) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
}

/* 分类条目样式 */
.category-item,
#existing-categories-list .category-item-row {
    background: rgba(255, 255, 255, 0.7) !important;
    backdrop-filter: blur(20px) !important;
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important;
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important;
    padding: 20px !important;
    overflow: hidden !important;
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
    margin-bottom: 12px !important;
}

.category-item:hover,
#existing-categories-list .category-item-row:hover {
    transform: translateY(-4px) scale(1.02) !important;
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.12) !important;
}


/* 下拉框样式 */
.select-trigger,
#world-book-category-select,
.form-group select {
    appearance: none !important;
    -webkit-appearance: none !important;
    -moz-appearance: none !important;
    background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 4 5"><path fill="%236B6B6B" d="M2 0L0 2h4zm0 5L0 3h4z"/></svg>') !important;
    background-repeat: no-repeat !important;
    background-position: right 16px center !important;
    background-size: 12px !important;
    cursor: pointer !important;
}

/* 标签样式 */
#world-book-unified-modal .form-group label {
    color: var(--text-primary) !important;
    font-weight: 500 !important;
    margin-bottom: 8px !important;
    display: block !important;
}

/* 分类项内容样式 */
.category-item-row {
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
}

.category-item-row .group-name {
    color: var(--text-primary) !important;
    font-weight: 500 !important;
    font-size: 16px !important;
}

.category-item-row .delete-group-btn {
    background-color: rgba(255, 59, 48, 0.1) !important;
    color: #AB4D3F !important;
    border: none !important;
    border-radius: 50% !important;
    width: 30px !important;
    height: 30px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    cursor: pointer !important;
    font-size: 18px !important;
    font-weight: bold !important;
    transition: all 0.2s ease !important;
}

.category-item-row .delete-group-btn:hover {
    background-color: rgba(255, 59, 48, 0.2) !important;
    transform: scale(1.1) !important;
}

/* 表单组间距优化 */
#world-book-unified-modal .form-group {
    margin-bottom: 24px !important;
}

/* textarea特殊样式 */
#world-book-unified-modal textarea {
    /* 核心修改：在这里将高度从 200px 改为 300px */
    min-height: 450px !important;
    resize: vertical !important;
    font-family: inherit !important;
}

/* ▼▼▼ 统一模态框样式 ▼▼▼ */

/* 统一模态框基础样式 */
#world-book-unified-modal .modal-content {
    background: rgba(255, 255, 255, 0.7) !important;
    backdrop-filter: blur(20px) !important;
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important;
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important;
    overflow: hidden !important;
}

/* 统一视图切换 */
.unified-view {
    width: 100%;
    min-height: 400px;
    display: flex;
    flex-direction: column;
}

/* 主菜单项样式 */
.unified-menu-item {
    background: rgba(255, 255, 255, 0.5) !important;
    border: 1px solid rgba(255, 255, 255, 0.3) !important;
    border-radius: 12px !important;
    padding: 20px !important;
    margin-bottom: 12px !important;
    display: flex !important;
    align-items: center !important;
    cursor: pointer !important;
    transition: all 0.2s ease !important;
}

.unified-menu-item:hover {
    background: rgba(255, 255, 255, 0.7) !important;
    transform: translateY(-2px) !important;
    box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.1) !important;
}

.unified-menu-item .menu-icon {
    font-size: 32px;
    margin-right: 16px;
    flex-shrink: 0;
}

.unified-menu-item .menu-text {
    flex-grow: 1;
}

.unified-menu-item .menu-title {
    font-size: 18px;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 4px;
}

.unified-menu-item .menu-desc {
    font-size: 14px;
    color: var(--text-secondary);
}

.unified-menu-item .menu-arrow {
    font-size: 20px;
    color: var(--text-secondary);
    flex-shrink: 0;
}

/* 返回按钮样式 */
.unified-back-btn {
    display: inline-flex !important;
    align-items: center !important;
    color: var(--accent-color) !important;
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    margin-bottom: 20px !important;
    padding: 8px 0 !important;
    transition: color 0.2s ease !important;
}

.unified-back-btn:hover {
    color: var(--text-primary) !important;
}

/* 统一动作按钮区域 */
.unified-actions {
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
}

/* 模态框头部样式优化 */
#world-book-unified-modal .modal-header {
    background: transparent !important;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2) !important;
    padding: 20px 20px 16px 20px !important;
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
}

#world-book-unified-modal .modal-body {
    padding: 20px !important;
}

#world-book-unified-modal .modal-footer {
    background: transparent !important;
    border-top: 1px solid rgba(255, 255, 255, 0.2) !important;
    padding: 16px 20px 20px 20px !important;
}

/* ▲▲▲ 统一模态框样式结束 ▲▲▲ */

/* ▲▲▲ 晴空设计方案样式结束 ▲▲▲ */

/* 修改后的 #chat-list 样式，去掉了 padding 和 margin */
#chat-list {
    flex-grow: 1;
    background-color: var(--secondary-bg);
    /* padding-top: 72px; */ /* 像这样注释掉也可以 */
    padding-bottom: 70px; /* 为底部导航栏留出空间 */
    box-sizing: border-box;
}

        .list-item { display: flex; flex-direction: column; cursor: pointer; }
        
        /* 非毛玻璃容器中的列表项样式 */
        .list-item:not(.glass-container .list-item) {
            padding: 12px 20px;
            border-bottom: 1px solid var(--border-color);
        }
        /* 非毛玻璃容器中的列表项hover效果 */
        .list-item:not(.glass-container .list-item):hover { background-color: #f5f5f5; }
        .list-item .item-title { font-weight: 500; font-size: 16px; margin-bottom: 5px; }
        .list-item .item-content { font-size: 14px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .chat-list-item { display: flex; align-items: center; padding: 10px 15px; cursor: pointer; border-bottom: 1px solid var(--border-color); position: relative; }
@media (hover: hover) {
    .chat-list-item:hover {
        background-color: #f5f5f5;
    }
}
.chat-list-item .avatar { width: 45px; height: 45px; border-radius: 20%; margin-right: 12px; object-fit: cover; background-color: #ccc; }
.chat-list-item .info { flex-grow: 1; overflow: hidden; }
        .chat-list-item .name-line { display: flex; align-items: center; gap: 6px; margin-bottom: 2px; }
        .chat-list-item .name { font-weight: 500; color: var(--text-primary); }
        .chat-list-item .group-tag { font-size: 10px; color: var(--accent-color); background-color: #F7F7F7; padding: 2px 6px; border-radius: 8px; font-weight: bold; flex-shrink: 0; }
        .chat-list-item .last-msg { font-size: 13px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; }
        #chat-interface-screen { background-size: cover; background-position: center; position: relative; }
        #selection-cancel-btn.circle-btn { margin-right: 10px; }
        #selection-delete-btn.circle-btn { background-color: #AB4D3F !important; }

/* ▼▼▼ 用这块代码替换掉你原来的 #chat-messages 样式 ▼▼▼ */
#chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    overflow-x: hidden;
    transition: margin-bottom 0.3s ease-in-out, padding-bottom 0.3s ease-in-out;
    margin-bottom: 0;
    padding: 10px 15px;
    /* 核心修改：增加了顶部的内边距，为浮动的Header留出空间 */
    /* 这个值可以根据你的Header实际高度微调，100px是一个比较安全的值 */
    padding-top: 150px; 
    display: flex;
    flex-direction: column;
    gap: 20px;
    box-sizing: border-box;
}
/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▲▲▲ 替换结束 ▲▲▲ */
        #load-more-btn { text-align: center; padding: 10px; color: var(--accent-color); font-size: 14px; cursor: pointer; background-color: transparent; border: none; width: 100%; }
        #load-more-btn:hover { text-decoration: underline; }

        .sender-name { font-size: 11px; color: #666; margin-bottom: 3px; }

.message-wrapper.ai .sender-name {
    margin-left: 50px; /* 稍微调整，与头像对齐 */
    margin-bottom: 3px;
    position: absolute; /* 让它脱离流，避免影响气泡对齐 */
    top: -16px;       /* 定位到气泡上方 */
    left: 0;
}

/* === 【全新】消息布局与时间戳样式 === */

/* 1. 消息单元的总容器 (重构) */
.message-wrapper {
    display: flex;          /* 使用Flex布局 */
    gap: 8px;               /* 气泡和时间戳之间的间距 */
    align-items: flex-end;  /* 核心：让气泡和时间戳底部对齐 */
    position: relative;
    max-width: 90%;         /* 可以稍微放宽一点，因为时间戳现在在外面了 */
/* ▼▼▼ 【核心新增代码】在这里 ▼▼▼ */
    -webkit-user-select: none; /* 兼容 Safari/Chrome */
    user-select: none;         /* 标准语法 */
    /* ▲▲▲ 新增代码结束 ▲▲▲ */
}

/* 2. AI消息单元靠左 */
.message-wrapper.ai {
    align-self: flex-start;
    flex-direction: row; /* 头像、气泡、时间戳，从左到右排列 */
}

/* 3. 用户消息单元靠右 */
.message-wrapper.user {
    align-self: flex-end;
    flex-direction: row-reverse; /* 时间戳、气泡、头像，从右到左排列 */
}

/* 4. 气泡和头像的直接容器 (保持不变) */
.message-bubble {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    max-width: 100%;
}

.timestamp {
    /* 移除旧的 position: absolute */
    font-size: 11px;
    color: #999;
    text-shadow: 0 0 3px rgba(255,255,255,0.6);
    white-space: nowrap; /* 防止时间换行 */
    margin-bottom: 5px;  /* 让它和气泡底部有轻微的对齐偏移，更美观 */
    flex-shrink: 0;      /* 防止被压缩 */
}

/* 【新增】模拟时间戳的特殊样式 */
.timestamp.simulated-timestamp {
    /* ▼▼▼ 在这里修改 ▼▼▼ */
    background: rgba(0, 0, 0, 0.2);      /* 1. 背景色：改为透明度更高的淡黑色 */
    color: var(--text-secondary);        /* 2. 文字颜色：改为深灰色以保证清晰 */
    padding: 2px 4px;                   /* 3. 内边距(大小)：增加左右边距，让气泡更舒展 */
    border-radius: 16px;                 /* 4. 圆角：可以稍微减小，看起来更精致 */
    font-size: 10px;                     /* (大小)：字体大小，您可以按需修改 */
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1); /* 5. 阴影：改为更柔和的淡阴影 */

    /* --- 以下为保持不变的基础样式 --- */
    font-weight: 500;
    text-shadow: none;
    position: relative;
    display: inline-block;
    z-index: 10;
    margin-bottom: 3px;
}

        .message-bubble.selected::after { content: '✔'; position: absolute; left: -10px; top: 50%; transform: translateY(-50%); background-color: var(--accent-color); color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; }
        .message-bubble.user.selected::after { left: auto; right: -10px; }

        .message-bubble.user { flex-direction: row-reverse; }
        #typing-indicator { align-self: flex-start; display: none; margin: 0 10px 10px; color: var(--text-secondary); }
        #chat-input-area {
            flex-shrink: 0;
            padding: 8px;
            padding-bottom: 28px; /* 保持原有的底部安全距离 */
            background-color: rgba(247, 247, 247, 0.8); /* 1. 背景色改为半透明 */
            backdrop-filter: blur(15px);                /* 2. 增强模糊效果 */
            -webkit-backdrop-filter: blur(15px);        /* 3. 兼容Safari */
            border-top: 1px solid rgba(0, 0, 0, 0.1);    /* 4. 边框改为更柔和的半透明色 */
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #chat-input-main-row { display: flex; align-items: flex-end; gap: 8px; width: 100%; }
        #chat-input { flex-grow: 1; border: none; padding: 10px 15px; border-radius: 7px; background-color: var(--secondary-bg); font-size: 16px; max-height: 100px; resize: none; }
        .action-button { border: none; color: white; border-radius: 20px; cursor: pointer; font-weight: 600; font-size: 14px; flex-shrink: 0; }
        #send-btn { background-color: var(--accent-color); height: 40px; padding: 0 15px;}
        .modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); display: none; justify-content: center; align-items: center; z-index: 100; }
        .modal.visible { display: flex; }
        .modal-content { width: 90%; max-height: 90%; background-color: white; border-radius: 15px; display: flex; flex-direction: column;position: relative; }
        .modal-header { padding: 15px; font-weight: 600; border-bottom: 1px solid var(--border-color); text-align: center; display: flex; justify-content: space-between; align-items: center; }
        .modal-body { padding: 15px; overflow-y: auto; }
        .modal-footer { padding: 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-around; }
        .modal-footer button { width: 45%; padding: 12px; border-radius: 8px; border: 1px solid var(--accent-color); cursor: pointer; font-size: 16px; }
        .modal-footer .save { background-color: var(--accent-color); color: white; }
        .modal-footer .cancel { background-color: white; color: var(--accent-color); }
        .avatar-upload { display: flex; align-items: center; gap: 15px; }
        .avatar-upload img { width: 60px; height: 60px; border-radius: 50%; object-fit: cover; background-color: #eee; }
        .avatar-upload button { padding: 8px 12px; border: 1px solid #ccc; background-color: #f0f0f0; border-radius: 5px; cursor: pointer; }
        #open-persona-library-btn { font-size: 14px; padding: 6px 10px; margin-left: 0; }
        .avatar-upload input[type="file"] { display: none; }
        #group-members-settings { display: flex; overflow-x: auto; padding-bottom: 10px; gap: 15px; }
        .member-editor { text-align: center; cursor: pointer; }
        .member-editor img { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; background-color: #eee; margin-bottom: 5px; }
        .member-editor .member-name { font-size: 12px; }
#notification-bar {
    position: absolute;
    /* 核心修改：使用 env(safe-area-inset-top) 来自动避开顶部的“刘海”或“灵动岛” */
    top: calc(5px + env(safe-area-inset-top));
    left: 50%;
    width: 90%;
    z-index: 500;
    background-color: rgba(250, 250, 250, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 16px;
    padding: 10px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    display: flex;
    align-items: center;
    gap: 12px;
    cursor: pointer;
    transform: translateX(-50%) translateY(-150%);
    transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    visibility: hidden;
}
#notification-bar.visible {
    /* 关键：在Y轴回到原位的同时，保持X轴的居中变换 */
    transform: translateX(-50%) translateY(0);
    visibility: visible;
}
        #notification-avatar { width: 30px; height: 30px; border-radius: 50%; object-fit: cover; }
        #notification-content .name { font-weight: 600; font-size: 15px; color: #000; }
        #notification-content .message { font-size: 14px; color: #555; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; }
        .sticker-image { max-width: 100px; max-height: 100px; display: block; object-fit: contain; }
.message-bubble.is-sticker .content, .message-bubble.is-voice-message .content { padding: 0 !important; background-color: transparent !important; box-shadow: none !important; border: none !important; backdrop-filter: none !important; -webkit-backdrop-filter: none !important; }        #chat-input-actions-top { display: flex; gap: 8px; padding: 0 5px; }
        .chat-action-icon-btn { font-size: 24px; padding: 0; width: 38px; height: 38px; line-height: 38px; text-align: center; border-radius: 50%; background-color: rgba(255, 255, 255, 0.5); color: var(--text-primary); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.05); cursor: pointer; display:flex; justify-content:center; align-items:center; }
        #sticker-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 50%; background-color: #F7F7F7; backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 0px 0px 0 0; z-index: 200; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #sticker-panel.visible { transform: translateY(0); visibility: visible; }
        #sticker-panel-header { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); }
        #sticker-panel-header .title { font-weight: 600; }
        #sticker-panel-header .panel-btn { font-size: 16px; padding: 5px 10px; cursor: pointer; color: var(--accent-color); }
        .svg-btn { width: 40px; height: 40px; border-radius: 50%; background-color: #1E1E1E; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: opacity 0.2s, transform 0.1s; }
        .svg-btn:hover { opacity: 0.8; }
        .svg-btn:active { transform: scale(0.95); }
        .svg-btn svg { color: white; }
        #sticker-grid { flex-grow: 1; overflow-y: auto; padding: 15px; display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; }
        .sticker-item { position: relative; aspect-ratio: 1 / 1; background-size: contain; background-repeat: no-repeat; background-position: center; cursor: pointer; }
        .sticker-item .delete-btn { display: none; position: absolute; top: -5px; right: -5px; width: 20px; height: 20px; background-color: #AB4D3F; color: white; border-radius: 50%; text-align: center; line-height: 20px; font-size: 14px; cursor: pointer; border: 2px solid white; }
        #input-actions-wrapper { position: static; display: flex; align-items: flex-end; gap: 8px; flex-shrink: 0; }
        #wait-reply-btn { position: static; bottom: auto; right: auto; width: 60px; height: 40px; padding: 0 ; border-radius: 24px; display: flex; align-items: center; justify-content: center; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.08); box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: opacity 0.2s, transform 0.1s; cursor: pointer;}
        #wait-reply-btn:hover { opacity: 0.8; }
        #wait-reply-btn:active { transform: scale(0.9); }
/* ▼▼▼ 用这块代码替换旧的 #wait-reply-btn img 样式 ▼▼▼ */
#wait-reply-btn img {
    height: 45px; /* 您可以按需调整这个数值，比如 28px 或 32px */
}        .chat-image { max-width: 100%; border-radius: 10px; display: block; }
        .message-bubble.has-image .content { padding: 5px; }
        #custom-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 1000; opacity: 0; transition: opacity 0.2s ease-in-out; }
        #custom-modal-overlay.visible { display: flex; opacity: 1; }
        #custom-modal { background-color: #fff; width: 280px; border-radius: 14px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; transform: scale(0.95); transition: transform 0.2s ease-in-out; }
        #custom-modal-overlay.visible #custom-modal { transform: scale(1); }
        .custom-modal-header { padding: 16px; font-size: 17px; font-weight: 600; text-align: center; }
        .custom-modal-body { padding: 0 16px 16px; text-align: center; font-size: 14px; color: #333; line-height: 1.5; }
        .custom-modal-body p { margin: 0; margin-bottom: 12px; }
        .custom-modal-body input { width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; }
        .custom-modal-footer {  display: flex; }
        .custom-modal-footer button { flex: 1; background: none; border: none; padding: 12px; font-size: 17px; cursor: pointer; color: var(--accent-color); }
        .custom-modal-footer button:first-child { border-right: 1px solid #dbdbdb; }
        .custom-modal-footer .confirm-btn { font-weight: 600; }
        .custom-modal-footer .confirm-btn.btn-danger { color: #AB4D3F; }
        #preset-actions-modal .custom-modal-footer { flex-direction: column; }
        #preset-actions-modal .custom-modal-footer button { width: 100%; border: none; border-bottom: 1px solid #dbdbdb; padding: 14px; font-size: 18px; }
        #preset-actions-modal .custom-modal-footer button:last-child { border-bottom: none; }
        .custom-multiselect { position: relative; user-select: none; }
        .select-box { display: flex; align-items: center; width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; background-color: #fff; cursor: pointer; }
         .select-box .selected-options-text {
    flex-grow: 1;
    white-space: normal; /* 允许正常换行 */
    word-break: break-all; /* 对长单词或URL等强制换行 */
    color: var(--text-primary);
    line-height: 1.4; /* 增加行高，让多行文本更易读 */
}
        .select-box .arrow-down { margin-left: auto; font-size: 10px; color: var(--text-secondary); transition: transform 0.2s; }
        .select-box.expanded .arrow-down { transform: rotate(180deg); }

.checkboxes-container {
    display: none;
    position: absolute;
    /* 核心修改：不再使用 top，而是用 margin-top 来创造间距，更稳定 */
    top: 100%; 
    margin-top: 5px; /* <-- 新增：向下推开5像素的距离 */
    left: 0;
    right: 0;
    max-height: 150px;
    overflow-y: auto;
    overflow-x: hidden;
    background-color: #fff;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    z-index: 101;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

        .checkboxes-container.visible { display: block; }

.checkboxes-container label {
    display: flex;
    align-items: center;
    padding: 8px 12px; /* 减少内边距，实现紧凑排布 */
    cursor: pointer;
    font-weight: normal;
    color: var(--text-primary);
    font-size: 15px;
    gap: 8px; /* 元素间距离 */
    flex-wrap: nowrap; /* 防止换行 */
}

/* 书籍项目不需要gap */
.wb-book-container label {
    gap: 0 !important;
}

        /* 隐藏默认勾选框 */
        .checkboxes-container input[type="checkbox"] { 
            display: none !important; 
        }
        
        /* 确保所有书籍容器内的checkbox都被隐藏 */
        .wb-book-container input[type="checkbox"] {
            display: none !important;
        }
        
        /* 隐藏书籍项目中的自定义勾选框 */
        .wb-book-container .custom-checkbox {
            display: none !important;
        }
        
        /* SVG圆形勾选框样式 */
        .custom-checkbox {
            width: 16px;
            height: 16px;
            min-width: 16px; /* 确保最小宽度 */
            min-height: 16px; /* 确保最小高度 */
            cursor: pointer;
            flex-shrink: 0; /* 不允许收缩 */
        }
        
        .custom-checkbox-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #1E1E1E;
            background-color: transparent;
            transition: all 0.2s ease;
        }
        
        .custom-checkbox.checked .custom-checkbox-circle {
            background-color: #1E1E1E;
            border-color: #1E1E1E;
        }
        
        /* 分类头部样式 */
        .wb-category-header {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 15px;
            gap: 8px;
            background-color: #ffffff;
            border-bottom: 1px solid #e9ecef;
            flex-wrap: nowrap; /* 防止换行 */
            white-space: nowrap; /* 防止文本换行 */
        }
        
        .wb-category-header .arrow {
            color: #1E1E1E !important; /* 强制黑色箭头 */
            font-size: 12px;
            transition: transform 0.2s ease;
            flex-shrink: 0;
        }
        
        .wb-category-header.collapsed .arrow {
            transform: rotate(-90deg);
        }
        .bg-upload-container { display: flex; align-items: center; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .bg-preview-img { max-width: 120px; max-height: 80px; border-radius: 8px; border: 1px solid var(--border-color); object-fit: cover; display: none; }
#remove-bg-btn {
    /* ▼▼▼ 从旁边的按钮复制的核心样式 ▼▼▼ */
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.4);
    border-radius: 16px;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    
    /* ▼▼▼ 统一其他基础样式 ▼▼▼ */
    color: var(--text-primary); /* 与“上传”按钮文字颜色统一 */
    padding: 8px 12px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    display: none; /* 保持默认隐藏的行为 */
}

#remove-bg-btn:hover {
    transform: translateY(-4px) scale(1.02);
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.12);
}        .message-bubble.is-ai-image .content { padding: 5px; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
        .ai-generated-image { max-width: 180px; border-radius: 12px; display: block; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; }
        .ai-generated-image:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .voice-message-body { display: flex; align-items: center; cursor: pointer; padding: 4px 8px; min-width: 80px; max-width: 200px; }
        .message-bubble.user .voice-message-body { color: #1E1E1E; flex-direction: row-reverse; }
        .message-bubble.ai .voice-message-body { color: var(--text-primary); }
        .voice-waveform { display: flex; align-items: center; height: 20px; gap: 2px; flex-grow: 1; margin: 0 10px; }
        .voice-waveform div { width: 3px; background-color: currentColor; border-radius: 2px; animation: wave-quiet 1.5s ease-in-out infinite; }
        @keyframes wave-quiet { 0%, 100% { height: 2px; } 50% { height: 10px; } }
        .voice-waveform div:nth-child(2) { animation-delay: 0.2s; } .voice-waveform div:nth-child(3) { animation-delay: 0.4s; } .voice-waveform div:nth-child(4) { animation-delay: 0.6s; } .voice-waveform div:nth-child(5) { animation-delay: 0.8s; }
.voice-duration {
    /* --- 核心修正 --- */
    font-size: var(--chat-font-size, 13px);
    /* --- 修正结束 --- */
    font-weight: 500;
    color: var(--text-secondary);
}
        .message-bubble.user .voice-duration { color: #1E1E1E; }

/* ▼▼▼ 用这块代码替换掉你原来的 .message-bubble .content 样式 ▼▼▼ */
/* 通用内容区样式，为时间戳和字体大小做准备 */
.message-bubble .content {
    position: relative;
    font-size: var(--chat-font-size, 16px);
    padding: 8px 12px;
    line-height: 1.5;
    word-break: break-word; /* 核心修正: 强制长单词或URL换行，防止撑破气泡 */
    text-align: justify; /* <<<--- 新增这一行代码 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */

        /* === 气泡主题样式 === */
        .message-bubble.user .content { background-color: rgba(255, 255, 255, 0.75); color: #585858; border-radius: 8px 2px 8px 8px; }
        .message-bubble.ai .content { background-color: rgba(255, 255, 255, 0.7); color: #585858; border-radius: 2px 8px 8px 8px; }
      
.message-bubble::after {
    content: "";
    position: absolute;
    width: 20px;  
    height: 20px; 
    background-size: contain;
    background-repeat: no-repeat;
    opacity: 1; 
    z-index: 1;
}
      
        #chat-messages[data-theme="pink_blue"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_blue"] .message-bubble.ai .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.user .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.user .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.ai .content { background-color: #fffde4; color: #5C4033; }
        #chat-messages[data-theme="black_white"] .message-bubble.user .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="black_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #343a40; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.user .content { background-color: #FFEB3B; color: #5D4037; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="red_black"] .message-bubble.user .content { background-color: #C62828; color: #FFFFFF; }
        #chat-messages[data-theme="red_black"] .message-bubble.ai .content { background-color: #212121; color: #FFFFFF; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.user .content { background-color: #A0D2EB; color: #153243; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.ai .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="gray_white"] .message-bubble.user .content { background-color: #e9ecef; color: #495057; }
        #chat-messages[data-theme="gray_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="blue_green"] .message-bubble.user .content { background-color: #d1ecf1; color: #0c5460; }
        #chat-messages[data-theme="blue_green"] .message-bubble.ai .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="pink_white"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="pink_black"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="pink_green"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_green"] .message-bubble.ai .content { background-color: #C8E6C9; color: #1B5E20; }
        #chat-messages[data-theme="green_black"] .message-bubble.user .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="green_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }

        #transfer-btn { font-weight: bold; }
        #transfer-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1001; }
        #transfer-modal.visible { display: flex; }
        .transfer-content { background-color: #f9f9f9; border-radius: 20px; width: 290px; padding: 20px; box-shadow: 0 5px 25px rgba(238, 238, 243, 0.3); text-align: center; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100" opacity="0.05"><path d="M50,4 C35,4 28,15 28,24 C28,33 35,32 35,40 C35,48 28,49 28,57 C28,65 35,66 35,74 C35,82 28,83 28,91 C28,99 35,100 50,100 C65,100 72,99 72,91 C72,83 65,82 65,74 C65,66 72,65 72,57 C72,49 65,48 65,40 C65,32 72,33 72,24 C72,15 65,4 50,4 Z" fill="%23FF69B4"/></svg>'); background-repeat: no-repeat; background-position: top right; background-size: 80px; }
        .transfer-header { font-size: 20px; font-weight: bold; color: #1E1E1E; margin-bottom: 20px; }
        .transfer-input-group { margin-bottom: 15px; text-align: left; }
        .transfer-input-group label { display: block; font-size: 14px; color: #1E1E1E; margin-bottom: 5px; font-weight: 500; }
        .transfer-input-group input { width: 100%; padding: 12px; border-radius: 10px; border: 2px solid #f4f2f3; background-color: #fff; font-size: 16px; box-sizing: border-box; }
        .transfer-input-group input:focus { border-color: #1E1E1E; outline: none; }
        .transfer-actions { display: flex; justify-content: space-between; gap: 10px; }
        .transfer-actions button { flex: 1; padding: 12px; border: none; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: transform 0.2s; }
        .transfer-actions button:active { transform: scale(0.95); }
        #transfer-cancel-btn { background-color: #fcfafb; color: #1E1E1E; }
        #transfer-confirm-btn { background-color: #1E1E1E; color: white; }
        .message-bubble.is-transfer .content { padding: 0; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; cursor: pointer; }
        .transfer-card { width: 200px; border-radius: 12px; padding: 12px; color: white; position: relative; overflow: hidden; }
        .transfer-card::before { content: '🐾'; position: absolute; right: 10px; top: 5px; font-size: 30px; opacity: 0.2; transform: rotate(15deg); }
        .message-bubble.user .transfer-card { background: radial-gradient(circle at top left, #fcc97d, #fcc97d); }
        .message-bubble.ai .transfer-card { background: radial-gradient(circle at top left, #fcc97d, #fcc97d); }
        .transfer-title { font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 6px; margin-bottom: 8px; }
        .transfer-amount { font-size: 28px; font-weight: bold; margin-bottom: 4px; }
        .transfer-note { font-size: 13px; opacity: 0.9; border-top: 1px solid rgba(255,255,255,0.3); padding-top: 8px; margin-top: 8px; word-break: break-all; }
        
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        #listen-together-btn img.rotating { animation: spin 2s linear infinite; }
        #listen-together-btn img.paused { animation-play-state: paused; }
        #music-player-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; display: none; justify-content: center; align-items: center; background-color: rgba(0,0,0,0.3); }
        #music-player-overlay.visible { display: flex; }
        .music-player-window { width: 90%; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 20px; box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); border: 1px solid rgba(255, 255, 255, 0.18); padding: 25px; display: flex; flex-direction: column; align-items: center; color: #1f1f1f; position: relative; }
        #music-playlist-btn { position: absolute; top: 15px; right: 15px; font-size: 24px; cursor: pointer; color: #333; }
        #music-time-counter { font-size: 12px; color: #555; margin-bottom: 20px; }
        #music-player-song-title { font-size: 20px; font-weight: 600; margin-bottom: 5px; text-align: center; }
        #music-player-artist { font-size: 14px; color: #666; margin-bottom: 25px; }
        .music-controls { display: flex; align-items: center; justify-content: center; gap: 20px; width: 100%; margin-bottom: 30px; }
        .music-controls button { background: none; border: none; font-size: 16px; font-weight: bold; cursor: pointer; color: #333; width: 44px; height: 44px; display: flex; justify-content: center; align-items: center; transition: transform 0.2s; }
        .music-controls button:active { transform: scale(0.9); }
        .music-controls .play-pause-btn { font-size: 24px; width: 60px; height: 60px; border-radius: 50%; background-color: rgba(0,0,0,0.05); }
        .music-bottom-actions { display: flex; justify-content: space-between; width: 100%; }
        .music-bottom-actions button { flex: 1; padding: 12px 0; border: none; border-radius: 10px; font-size: 15px; font-weight: 500; cursor: pointer; }
        #music-exit-btn { background-color: rgba(213, 99, 99, 0.7); color: white; margin-right: 5px; }
        #music-return-btn { background-color: rgba(131, 176, 225, 0.7); color: white; margin-left: 5px; }
        
        #music-playlist-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 70%; background-color: rgba(242, 242, 247, 0.9); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 210; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #music-playlist-panel.visible { transform: translateY(0); visibility: visible; }
        .playlist-header { padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); font-weight: 600; }
        .playlist-header .panel-btn { font-size: 16px; cursor: pointer; color: var(--accent-color); }
        .playlist-body { flex-grow: 1; overflow-y: auto; padding: 10px 0; }
        .playlist-item { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; border-bottom: 1px solid #eee; }
        .playlist-item.playing { background-color: rgba(0, 123, 255, 0.1); }
        .playlist-item-info .title { font-weight: 500; font-size: 15px; }
        .playlist-item-info .artist { font-size: 12px; color: #666; }
        .playlist-item .delete-track-btn { color: #d46b66; font-size: 20px; padding: 5px; }

        /* Persona Library Styles */
        #persona-library-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; padding: 10px; }
        .persona-preset-item { aspect-ratio: 1 / 1; border-radius: 12px; background-size: cover; background-position: center; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; border: 1px solid rgba(0,0,0,0.1); }
        .persona-preset-item:hover { transform: scale(1.08); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .modal-header .action-button { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; background: none; border: none; padding: 5px; }
        
        /* 圆形SVG按钮样式 */
        .circular-svg-button {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 36px;
            height: 36px;
            min-width: 36px;
            min-height: 36px;
            max-width: 36px;
            max-height: 36px;
            border-radius: 50%;
            background-color: #1E1E1E;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 1;
            flex-shrink: 0;
            box-sizing: border-box;
            aspect-ratio: 1/1;
        }
        
        .circular-svg-button:hover {
            background-color: #333;
            transform: scale(1.05);
        }
        
        .circular-svg-button svg {
            width: 18px;
            height: 18px;
            fill: white;
        }
        
        /* Battery Alert Modal Styles */
        #battery-alert-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.4); display: none; justify-content: center; align-items: center; z-index: 2000; opacity: 0; transition: opacity 0.3s ease; }
        #battery-alert-modal.visible { display: flex; opacity: 1; }
        .battery-alert-content { background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); width: 280px; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); text-align: center; padding: 20px; cursor: pointer; transform: scale(0.9); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        #battery-alert-modal.visible .battery-alert-content { transform: scale(1); }
        #battery-alert-image { max-width: 100px; max-height: 100px; margin-bottom: 15px; }
        #battery-alert-text { font-size: 16px; font-weight: 500; color: #333; margin: 0; line-height: 1.4; }

/* 这是你要添加的新样式 */
#font-preview {
    transition: font-family 0.3s ease;}

/* === 线下模式样式 === */
/* 线下模式消息容器 */
.reality-message-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: -2px 0 -10px 0;
    position: relative;
    width: 100%;
}

/* 线下模式消息气泡 - 毛玻璃效果 */
.reality-message-bubble {
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.4);
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
    padding: 8px 12px 8px 12px;  /* 上右下左：左右相等 */
    max-width: 90%;
    position: relative;
    text-align: left;
    word-break: break-word;
    line-height: 1.5;
    /* 使用和线上模式相同的字体样式 */
    font-size: var(--chat-font-size, 16px);
    margin: 5px auto;
    /* 恢复原来的布局 */
    display: inline-block;
}

/* 线下模式用户气泡的特殊padding */
.reality-message-bubble.user {
    padding: 5px 10px 5px 10px;  /* 用户消息：左右相等 */
}

/* 线下模式斜体文字样式 */
.reality-italic {
    font-style: italic;
}

/* 线下模式时间戳 - 在气泡外部上方居中 */
.reality-timestamp {
    font-size: 11px;
    color: #666;
    text-align: center;
    margin-bottom: 5px;
    background: rgba(255, 255, 255, 0.6);
    padding: 3px 8px;
    border-radius: 15px;
    display: inline-block;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

/* 线下模式系统提示容器 - 真正的居中 */
.message-wrapper.system-mode-switch {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 0px auto -5px auto;
    width: 100%;
    text-align: center;
    
}
/* 或者使用更精确的选择器 */
  #chat-messages .reality-message-wrapper:nth-last-child(2) {
      margin-bottom: 7px !important;
  }

  #chat-messages .message-wrapper.system-mode-switch:nth-last-child(2) {
      margin-bottom: 7px !important;
  }
  
/* 线下模式系统提示 - 居中的黑色气泡 */
.reality-system-message {
    text-align: center;
    padding: 5px 10px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    border-radius: 10px;
    font-size: 12px;
    font-weight: 500;
    max-width: 200px;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    margin: 0 auto;
    display: inline-block;
}

/* === 聊天列表界面新增样式 (这是新添加的) === */
#chat-list-screen {
}

.chat-list-view {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, visibility 0.2s;
    z-index: 1; 
}
.chat-list-view.active {
    opacity: 1;
    visibility: visible;
    z-index: 2; 
}

#messages-view {
    overflow-y: auto; 
}

/* 底部导航栏样式 */
#chat-list-bottom-nav {
    position: absolute; /* 让它固定在底部 */
    bottom: 0;
    left: 0;
    width: 100%;
    z-index: 15; /* 确保它在视图之上 */
    display: flex;
    border-top: 1px solid #E0E0E0;
    background-color: #F7F7F7;
    
}

.nav-item {
    flex: 1;
    text-align: center;
    padding: 10px 0;
    font-size: 14px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: color 0.2s;
}

.nav-item.active {
    color: var(--accent-color);
    font-weight: 600;
}

/* === 动态界面 (QZone) 样式 (这是新添加的) === */
#qzone-screen {
    background-color: #F7F7F7;
}

.qzone-header {
    /* position: absolute;  <-- 把这个改成 relative */
    position: relative;
    z-index: 10; /* z-index 保持，或者可以更高 */
    flex-shrink: 0; /* 防止被压缩 */
    padding: 20px 20px;
    padding-top: calc(20px + env(safe-area-inset-top));
    background-color: rgba(247, 247, 247, 0.7); 
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    font-weight: 600;
    text-align: center;
    min-height: 60px;
}

.qzone-header .back-btn {
    font-size: 24px;
    cursor: pointer;
    color: var(--accent-color);
}

.qzone-header span:nth-child(2) { /* "好友动态"文字 */
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
}

.qzone-content {
    flex-grow: 1;
    overflow-y: auto;
    background-color: #F7F7F7;
    /* padding-top: 80px;  <-- 删除这个，因为header不再是absolute了 */
}

.qzone-profile-header {
    position: relative;
    margin-bottom: 20px;
}

.qzone-banner-container {
    width: 100%;
    height: 180px; /* 背景板高度 */
    position: relative;
}

#qzone-banner-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.qzone-user-info {
    position: absolute;
    bottom: -30px; /* 让头像和昵称区域向下偏移，一半在背景板内，一半在外 */
    left: 20px;
    display: flex;
    align-items: flex-end; /* 让昵称和头像底部对齐 */
    gap: 10px;
}

.qzone-avatar-container {
    position: relative;
}

#qzone-avatar-img {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: 3px solid white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    object-fit: cover;
}

#qzone-nickname {
    font-size: 18px;
    font-weight: 600;
    color: #fff;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    padding-bottom: 5px; /* 微调位置 */
}

/* 编辑按钮的通用样式 */
.qzone-edit-btn {
    position: absolute;
    background-color: rgba(0,0,0,0.4);
    color: white;
    border: none;
    border-radius: 10px;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
}

#change-qzone-banner-btn {
    bottom: 10px;
    right: 10px;
}

#change-qzone-avatar-btn {
    bottom: 5px;
    right: 5px;
}

#change-qzone-nickname-btn {
    font-size: 14px;
    padding: 2px 6px;
    margin-left: 5px; /* 与昵称的间距 */
    color: var(--text-primary);
    background-color: rgba(255,255,255,0.7);
    border-radius: 5px;
    position: relative; /* 脱离flex布局的对齐 */
    bottom: 5px; /* 微调垂直位置 */
}

/* === 让编辑功能更“隐形” === */
#qzone-banner-container,
#qzone-avatar-container,
#qzone-nickname {
    cursor: pointer; /* 鼠标悬停时显示为可点击手势 */
    transition: opacity 0.2s;
}
#qzone-banner-container:hover,
#qzone-avatar-container:hover,
#qzone-nickname:hover {
    opacity: 0.85; /* 悬停时稍微变暗，给用户反馈 */
}
/* 隐藏掉旧的、独立的编辑按钮 */
.qzone-edit-btn {
    display: none;
}

/* === 控制 Header 和 Bottom Nav 的显隐 === */
/* 默认隐藏动态界面的 Header */
#qzone-screen .qzone-header {
    display: none;
}
/* 当动态视图激活时，显示它的Header */
#qzone-screen.active .qzone-header {
    display: flex;
}

/* 当进入动态视图时，隐藏主Header和底部导航栏 */
#chat-list-screen.in-qzone-view > .header,
#chat-list-screen.in-qzone-view > #chat-list-bottom-nav {
    display: none;
}

.chat-list-item:first-child,
.chat-group-container:first-child {
    margin-top: 10px; 
}

/* ▲▲▲ 新样式替换结束 ▲▲▲ */

/* ▼▼▼ 把所有这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 动态功能栏样式 === */
.qzone-actions-bar {
    display: flex;
    justify-content: space-around;
    padding: 10px 0;
    margin: 40px 15px 15px 15px; /* 上边距更大，为浮动的头像留出空间 */
    background-color: var(--secondary-bg);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

.action-item {
    flex: 1;
    text-align: center;
    font-size: 15px;
    font-weight: 500;
    color: var(--text-primary);
    cursor: pointer;
    padding: 8px 0;
    position: relative;
}

/* 用伪元素创建分隔线 */
.action-item:not(:last-child)::after {
    content: '';
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 1px;
    height: 20px;
    background-color: var(--border-color);
}

/* === 动态帖子列表样式 === */
#qzone-posts-list {
    padding: 0 15px 20px 15px; /* 左右和底部留出边距 */
    display: flex;
    flex-direction: column;
    gap: 20px; /* 帖子之间的间距 */
}

.qzone-post-item {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
}

.post-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.post-header .post-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
}

.post-info {
    display: flex;
    flex-direction: column;
}

.post-info .post-nickname {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-primary);
}

.post-info .post-timestamp {
    font-size: 12px;
    color: var(--text-secondary);
}

.post-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap; /* 让换行符生效 */
    word-break: break-word; /* 防止长单词溢出 */
}

/* ▲▲▲ 新样式结束 ▲▲▲ */

/* ▼▼▼ 新样式粘贴到末尾 ▼▼▼ */

/* === 发布动态模态框样式 === */
#post-public-text {
    min-height: 80px; /* 确保文本域有足够的高度 */
    resize: vertical;
}

.post-image-preview-container {
    position: relative;
    width: 100%;
    aspect-ratio: 16 / 9; /* 保持16:9的预览比例 */
    background-color: #F7F7F7;
    border: 2px dashed var(--border-color);
    border-radius: 8px;
    margin-bottom: 15px;
    display: none; /* 默认隐藏 */
    justify-content: center;
    align-items: center;
}
.post-image-preview-container.visible {
    display: flex; /* 上传后显示 */
}

#post-image-preview {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    border-radius: 6px;
}

#post-remove-image-btn {
    position: absolute;
    top: -10px;
    right: -10px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background-color: #AB4D3F;
    color: white;
    border: 2px solid white;
    font-size: 16px;
    line-height: 20px;
    text-align: center;
    cursor: pointer;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
}

.post-image-upload-options {
    display: flex;
    gap: 10px;
}

.post-image-upload-options button {
    flex: 1;
    margin-top: 0;
}

/* ▲▲▲ 新样式结束 ▲▲▲ */

/* ▼▼▼ 新样式 ▼▼▼ */

/* === 发布动态模态框 - 模式切换样式 === */
.post-mode-switcher {
    display: flex;
    margin-bottom: 20px;
    background-color: #333333; /* 修改点：容器背景改为深灰色 */
    border-radius: 8px;
    padding: 4px;
}

.mode-btn {
    flex: 1;
    padding: 8px;
    border: none;
    background-color: transparent;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    color: #ababab; /* 修改点：未选中时文字颜色改为浅灰色 */
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

.mode-btn.active {
    background-color: #1E1E1E; /* 修改点：背景色改为 #1E1E1E */
    color: #FFFFFF; /* 修改点：文字颜色改为纯白色 */
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.post-mode-content {
    display: none; /* 默认都隐藏 */
}

.post-mode-content.active {
    display: block; /* 激活的才显示 */
}

/* ▲▲▲ 新样式结束 ▲▲▲ */

/* === 相册页面背景色 === */
#album-screen {
    background-color: #F7F7F7; /* 使用一个柔和的浅灰色，比纯白更护眼 */
}

/* === 相册页面网格布局 === */
#album-grid-page {
    padding: 15px;
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* 每行显示2个相册 */
    gap: 15px;
}

/* === 相册项目样式 (美化) === */
.album-item {
    display: flex;
    flex-direction: column;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border-radius: 8px; /* 给整个项目也加个圆角 */
}

.album-item:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 15px rgba(0,0,0,0.1);
}

.album-cover {
    aspect-ratio: 1 / 1; /* 保持封面为正方形 */
    background-size: cover;
    background-position: center;
    border-radius: 8px;
    margin-bottom: 8px;
    background-color: #F7F7F7; /* 封面加载前的占位颜色 */
}

.album-info {
    text-align: center;
}

.album-name {
    font-weight: 500;
    margin: 0 0 4px 0;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 防止长名字换行 */
}

.album-count {
    font-size: 12px;
    color: var(--text-secondary);
    margin: 0;
}

/* ▲▲▲ 新的 CSS 粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 相册照片详情页 === */
#album-photos-screen {
    background-color: #F7F7F7;
}

#photos-grid-page {
    padding: 15px;
    display: grid;
    /* 每行显示3张照片，并保持间距 */
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
}

.photo-item {
    position: relative; /* 为了定位删除按钮 */
    aspect-ratio: 1 / 1; /* 保持照片为正方形 */
    border-radius: 6px;
    overflow: hidden; /* 防止图片溢出圆角 */
    background-color: #e9ecef; /* 图片加载前的占位符颜色 */
}

.photo-item .photo-thumb {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 保证图片填满容器且不变形 */
    cursor: pointer;
}

/* 删除按钮的样式 */
.photo-item .photo-delete-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 22px;
    height: 22px;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 16px;
    line-height: 22px;
    text-align: center;
    cursor: pointer;
    opacity: 0; /* 默认隐藏 */
    transition: opacity 0.2s ease;
}

/* 鼠标悬停在照片上时显示删除按钮 */
.photo-item:hover .photo-delete-btn {
    opacity: 1;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* === 图片查看器模态框样式 === */
#photo-viewer-modal {
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 1002;
    -webkit-backdrop-filter: blur(5px);
    backdrop-filter: blur(5px);
}

.photo-viewer-content {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
}

#photo-viewer-image {
    max-width: 90vw;  /* 图片最大宽度为视口的90% */
    max-height: 85vh; /* 图片最大高度为视口的85% */
    object-fit: contain;
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    /* 为图片的切换添加一点平滑的淡入淡出效果 */
    transition: opacity 0.2s ease-in-out;
}

/* 关闭按钮 */
#photo-viewer-close-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    background: none;
    border: none;
    color: white;
    font-size: 40px;
    font-weight: 200;
    cursor: pointer;
    line-height: 1;
    text-shadow: 0 0 5px black;
}

/* 左右导航箭头 */
#photo-viewer-modal .nav-arrow {
    position: absolute; /* 现在我们用绝对定位来控制箭头 */
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    font-size: 50px; /* 在手机屏幕上，可以稍微小一点 */
    font-weight: 100;
    cursor: pointer;
    padding: 10px; /* 调整内边距 */
    user-select: none;
    transition: color 0.2s;
    z-index: 1003; /* 确保箭头在最上层 */
}

#photo-viewer-prev-btn {
    left: 5px; /* 定位左箭头 */
}

#photo-viewer-next-btn {
    right: 5px; /* 定位右箭头 */
}

#photo-viewer-modal .nav-arrow:hover {
    color: white;
}

/* 当箭头被禁用时（比如第一张或最后一张） */
#photo-viewer-modal .nav-arrow:disabled {
    color: rgba(255, 255, 255, 0.2);
    cursor: default;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* ▼▼▼ 请用这块新CSS替换掉上一版的交互区CSS ▼▼▼ */

/* === 帖子内容区 - 相对定位容器 === */
/* === 帖子内容区 === */
.post-main-content {
    /* 它现在只是一个普通的内容容器，不再需要特殊样式了 */
}

/* === 帖子互动图标区 (新样式) === */
.post-feedback-icons {
    display: flex;
    justify-content: flex-end; /* 让图标靠右对齐 */
    align-items: center;
    gap: 12px;
    padding: 8px 0; /* 核心修改：给图标区域上下各8px的留白 */
}

.action-icon {
    cursor: pointer;
    color: var(--text-secondary); /* 默认灰色 */
    transition: all 0.2s ease-in-out;
}

.action-icon svg {
    width: 22px;
    height: 22px;
    fill: none;
    stroke: currentColor;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
}

/* 图标激活(点赞/收藏后)的样式 */
.action-icon.active {
    color: #ff5252; /* 激活后变红色 */
    transform: scale(1.1); /* 轻微放大 */
}

.action-icon.active.favorite {
    color: #ffc107; /* 收藏用黄色 */
}

.action-icon.active svg {
    fill: currentColor; /* 激活后填充颜色 */
}

/* 点击时的动画效果 */
.animate-like {
    animation: like-bounce 0.4s ease-in-out;
}

@keyframes like-bounce {
    0%   { transform: scale(1); }
    25%  { transform: scale(0.8); }
    50%  { transform: scale(1.2); }
    75%  { transform: scale(1.05); }
    100% { transform: scale(1.1); }
}


/* === 帖子底部评论区样式 (现在是独立部分) === */
.post-footer {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid #f0f0f0; /* 用一条浅色线分隔 */
    display: flex;
    align-items: center;
    gap: 8px; /* 调整整体间距 */
}

/* 评论区容器 */
.comment-section {
    flex-grow: 1; /* 占据大部分空间 */
    display: flex;
    align-items: center;
    gap: 8px;
}

.comment-section .comment-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}

.comment-section .comment-input {
    width: 100%;
    padding: 8px 12px;
    border: none;
    background-color: #F7F7F7;
    border-radius: 14px;
    font-size: 13px;
    outline: none;
}

/* 新增的发送按钮样式 */
.comment-send-btn {
    flex-shrink: 0; /* 防止被压缩 */
    padding: 8px 15px;
    border: none;
    background-color: var(--accent-color);
    color: white;
    border-radius: 14px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 未读消息小红点通用样式 === */
.unread-indicator {
    position: absolute;
    top: -8px;      
    right: -15px;    
    min-width: 18px;
    height: 18px;
    padding: 0 5px;
    background-color: #AB4D3F;
    color: white;
    font-size: 11px;
    font-weight: bold;
    line-height: 18px;
    text-align: center;
    border-radius: 9px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    display: none;
    z-index: 1;
}

/* 聊天界面返回按钮上的小红点 (只显示点，不显示数字) */
.back-btn-indicator {
    top: 0;
    right: -8px; /* 放到返回箭头右上角 */
    width: 10px;
    height: 10px;
    min-width: 10px;
    padding: 0;
    border-radius: 50%;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 评论列表容器 === */
.post-comments-container {
    padding: 10px 0; /* 上下留白 */
    display: flex;
    flex-direction: column;
    gap: 8px; /* 评论之间的间距 */
    font-size: 13px; /* 统一评论区字体大小 */
}

/* 每一条评论 */
.comment-item {
    line-height: 1.5;
}

/* 评论者的名字，加粗并使用主题色 */
.comment-item .commenter-name {
    font-weight: 600;
    color: var(--accent-color);
    cursor: pointer;
    margin-right: 5px; /* 和评论内容之间留点空隙 */
}

/* 评论内容 */
.comment-item .comment-text {
    color: var(--text-primary);
    word-break: break-word;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 帖子点赞区域样式 === */
.post-likes-section {
    display: flex;
    align-items: center;
    gap: 6px; /* 图标和文字的间距 */
    padding: 8px 10px; /* 内边距 */
    font-size: 13px;
    color: var(--accent-color); /* 使用主题蓝色 */
    background-color: #f0f5fa; /* 给一个淡淡的背景色 */
    border-top: 1px solid #e9eef3;
    border-bottom: 1px solid #e9eef3;
    margin-top: 5px; /* 和上方的图标保持一点距离 */
}

.post-likes-section .like-icon {
    width: 16px;
    height: 16px;
    fill: currentColor; /* 让SVG图标继承父元素的颜色 */
    flex-shrink: 0; /* 防止图标被压缩 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === @提及 弹出菜单样式 === */
.at-mention-popup {
    position: absolute; /* 相对于父元素定位 */
    bottom: 100%; /* 显示在输入框的上方 */
    left: 40px; /* 和输入框左侧对齐 (考虑了头像宽度) */
    width: calc(100% - 40px); /* 宽度和输入框差不多 */
    max-height: 120px;
    overflow-y: auto;
    background-color: var(--secondary-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
    z-index: 10;
    display: none; /* 默认隐藏 */
}

.at-mention-item {
    padding: 8px 12px;
    font-size: 14px;
    cursor: pointer;
    color: var(--text-primary);
    border-bottom: 1px solid #f0f0f0;
}

.at-mention-item:last-child {
    border-bottom: none;
}

.at-mention-item:hover {
    background-color: #f5f5f5;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* ▼▼▼ 请用下面这段【新样式】替换掉你现有的 #favorites-list 样式 ▼▼▼ */

/* 让收藏视图成为一个flex容器, 从上到下排列 */
#favorites-view {
    display: flex;
    flex-direction: column;
}

/* 确保收藏页的header高度固定，不被压缩 */
#favorites-view > .header {
    flex-shrink: 0;
}

/* === 收藏列表样式 (修正后) === */
#favorites-list {
    flex-grow: 1; 
    overflow-y: auto; 
    overflow-x: hidden; /* <-- 新增这行，禁止水平滚动 */
    padding: 15px; 
    display: flex;
    flex-direction: column;
    gap: 15px; 
}

/* ▲▲▲ 替换结束 ▲▲▲ */

.favorite-item-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    position: relative; /* 为了定位删除按钮 */
}

/* 卡片头部，包含头像、名字和来源 */
.fav-card-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.fav-card-header .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
}

.fav-card-header .info {
    flex-grow: 1;
}

.fav-card-header .name {
    font-weight: 600;
    font-size: 15px;
}

.fav-card-header .source {
    font-size: 12px;
    color: var(--text-secondary);
}

/* 卡片内容 */
.fav-card-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap;
    word-break: break-word;
}

.fav-card-content .chat-image {
    margin-top: 8px; /* 图片和文字的间距 */
}

/* 删除按钮 */
.fav-delete-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 28px;
    height: 28px;
    background: #F7F7F7;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    font-size: 18px;
    color: var(--text-secondary);
    line-height: 28px;
    text-align: center;
}

.fav-delete-btn:hover {
    background-color: #e9ecef;
    color: #AB4D3F;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 搜索栏样式 === */
.search-bar-container {
    padding: 10px 15px;
    background-color: #f9f9f9; /* 和列表背景色保持一致 */
    position: relative; /* 为了定位清除按钮 */
    flex-shrink: 0;
}

#favorites-search-input {
    width: 100%;
    padding: 10px 30px 10px 15px; /* 右侧留出清除按钮的位置 */
    font-size: 14px;
    border: 1px solid var(--border-color);
    border-radius: 18px; /* 圆角矩形，更现代化 */
    background-color: var(--secondary-bg);
    box-sizing: border-box;
    outline: none;
}
#favorites-search-input:focus {
    border-color: var(--accent-color);
}

.search-clear-btn {
    position: absolute;
    right: 25px;
    top: 50%;
    transform: translateY(-50%);
    background: #ccc;
    color: white;
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    font-size: 16px;
    cursor: pointer;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* === 聊天界面多选操作栏优化 === */
#chat-interface-screen .header .selection-controls {
    display: flex;
    align-items: center;
    width: 100%;
    position: relative;
}
/* 左侧取消按钮 */
#chat-interface-screen .selection-controls #selection-cancel-btn {
    position: absolute;
    left: 0;
}
/* 右侧操作按钮组 */
#chat-interface-screen .selection-controls .header-actions {
    position: absolute;
    right: 0;
    display: flex;
    gap: 5px;
}
#chat-interface-screen .selection-controls .action-btn.circle-btn {
    width: 30px !important;
    height: 30px !important;
    min-width: 30px !important;
    flex-shrink: 0 !important;
    border-radius: 50% !important;
}
/* 确保选择计数文本居中 */
#chat-interface-screen .selection-controls #selection-count {
    width: 100%;
    text-align: center;
    font-size: 16px;
    font-weight: 600;
}

/* === 收藏页面多选模式样式 === */
#favorites-view.selection-mode .favorite-item-card {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

/* 选择框的样式 */
.favorite-item-card::before {
    content: '';
    position: absolute;
    left: -25px; /* 把它放在卡片左边外面 */
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    background-color: white;
    transition: all 0.2s ease;
    opacity: 0; /* 默认隐藏 */
}

/* 进入选择模式时，卡片向右移动，露出选择框 */
#favorites-view.selection-mode .favorite-item-card {
    transform: translateX(35px);
}
#favorites-view.selection-mode .favorite-item-card::before {
    opacity: 1;
}

/* 选中后的样式 */
#favorites-view.selection-mode .favorite-item-card.selected::before {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}

/* 底部操作栏 (终极修正版) */
#favorites-action-bar {
    position: absolute; /* ★ 改为 absolute，相对于 #phone-screen 定位 */
    bottom: 0;
    left: 0;
    right: 0;           /* ★ 新增 right: 0，和 left: 0 一起撑满宽度 */
    width: auto;        /* ★ 改为 auto，让 left/right 决定宽度 */
    padding: 10px 15px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom)); /* 适配iPhone底部安全区 */
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color);
    box-sizing: border-box;
    z-index: 5;
    display: none;
    /* max-width 已经不需要了，因为父元素已经限制了宽度 */
}

#favorites-action-bar .action-bar-btn {
    width: 100%;
    padding: 12px;
    border-radius: 8px;
    border: none;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    background-color: #AB4D3F;
    color: white;
}

/* === 【修正】聊天界面头部控件切换逻辑 === */

/* 默认状态：隐藏多选控件 */
#chat-interface-screen .header .selection-controls {
    display: none;
}

/* 默认状态：显示默认控件，并让它撑满整个头部 */
#chat-interface-screen .header .default-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

/* 当进入多选模式时：隐藏默认控件 */
#chat-interface-screen.selection-mode .header .default-controls {
    display: none;
}

/* 当进入多选模式时：显示多选控件，并让它撑满整个头部 */
#chat-interface-screen.selection-mode .header .selection-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 修正：放大所有主要的“+”号按钮 === */
#add-chat-btn,
#add-world-book-btn,
#create-album-btn-page {
    font-size: 28px;   /* 显著增大字体大小，使其视觉上与旁边的图标匹配 */
    font-weight: 300;  /* 使用更细的字重，让加号看起来更清爽，不显粗笨 */
    position: relative;/* 允许进行位置微调 */
    top: -1px;         /* 字体放大后，通常需要稍微向上移动一点，使其视觉上更居中 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 预览区容器样式 */
#settings-preview-area {
    width: 100%;
    height: 180px; /* 给一个固定的高度 */
    background-color: #F7F7F7;
    border-radius: 8px;
    padding: 15px;
    box-sizing: border-box;
    overflow: hidden; /* 防止内容溢出 */
    display: flex;
    flex-direction: column;
    gap: 10px; /* 预览气泡之间的间距 */
    border: 1px solid var(--border-color);
    position: relative; /* 为了定位背景 */
}

/* 预览区的背景，可以和真实聊天界面同步 */
#settings-preview-area::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-size: cover;
    background-position: center;
    z-index: 1;
    opacity: 0.8;
}

/* 让预览气泡在背景之上 */
#settings-preview-area .message-wrapper {
    position: relative;
    z-index: 2;
}

/* 预览区内使用的头像要小一点 */
#settings-preview-area .message-bubble .avatar {
    width: 30px;
    height: 30px;
}

#settings-preview-area .message-bubble .timestamp {
    display: none; /* 预览区不需要显示时间戳 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
.existing-group-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    background-color: #f9f9f9;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.existing-group-item .group-name {
    font-weight: 500;
}

.existing-group-item .delete-group-btn {
    color: #AB4D3F;
    font-size: 20px;
    cursor: pointer;
    padding: 5px;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
.chat-group-container {
    border-bottom: 1px solid var(--border-color);
}
.chat-group-container:first-child {
    border-top: 1px solid var(--border-color);
}

.chat-group-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    cursor: pointer;
    background-color: #f7f7f7;
}

.chat-group-header .arrow {
    font-size: 14px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}

.chat-group-header.collapsed .arrow {
    transform: rotate(-90deg);
}

.chat-group-header .group-name {
    font-weight: 600;
    font-size: 15px;
}

.chat-group-content {
    max-height: 1000px; /* 一个足够大的值 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}

.chat-group-content.collapsed {
    max-height: 0;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* 格式助手按钮的容器 */
.format-helpers {
    display: flex;
    gap: 10px;
    margin-bottom: 15px; /* 与下方的文本框拉开距离 */
    flex-wrap: wrap; /* 如果按钮太多可以换行 */
}

/* 单个格式助手按钮的样式 */
.format-btn {
    background-color: #e9ecef;
    color: var(--text-primary);
    border: none;
    padding: 6px 12px;
    border-radius: 16px; /* 胶囊形状，更友好 */
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s;
}

.format-btn:hover {
    background-color: #dcdfe3;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* “…”按钮的样式 */
.post-actions-btn {
    margin-left: auto; /* 关键：让它自动靠到最右边 */
    padding: 5px 10px;
    font-size: 20px;
    font-weight: bold;
    color: var(--text-secondary);
    cursor: pointer;
    border-radius: 50%;
    line-height: 1;
}
.post-actions-btn:hover {
    background-color: #f0f0f0;
}

/* 动态编辑模态框的样式 (它将复用现有的操作菜单样式) */
#post-actions-modal .custom-modal-footer button {
    width: 100%;
    border: none;
    border-bottom: 1px solid #dbdbdb;
    padding: 14px;
    font-size: 18px;
}
#post-actions-modal .custom-modal-footer button:last-child {
    border-bottom: none;
}
#post-actions-modal #cancel-post-action-btn {
    margin-top: 8px;
    border-radius: 8px;
    background-color: #f0f0f0;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* 统一重置转账卡片内所有文字的特效和颜色 */
#chat-messages .transfer-card .transfer-title,
#chat-messages .transfer-card .transfer-amount,
#chat-messages .transfer-card .transfer-note {
    text-shadow: none !important; /* 强制移除任何发光或阴影效果 */
    color: white !important;      /* 强制锁定文字颜色为白色 */
}

/* 分别锁定各自的字体大小和字重，防止被篡改 */
#chat-messages .transfer-card .transfer-title {
    font-size: 16px !important;
    font-weight: 600 !important;
}

#chat-messages .transfer-card .transfer-amount {
    font-size: 28px !important;
    font-weight: bold !important;
}

#chat-messages .transfer-card .transfer-note {
    font-size: 13px !important;
    opacity: 0.9 !important;
}

/* ▼▼▼ 这是新增的样式，用于修正所有头部标题的居中问题 ▼▼▼ */
.header > span:nth-child(2),
#chat-header-title {
    position: absolute;
    left: 50%;
    transform: translateX(calc(-50% - 2px)); /* 在-50%的基础上，再向左推2像素 */
    
    /* (可选但推荐) 防止长标题与两边按钮重叠 */
    max-width: 60%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
/* ▲▲▲ 粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】可视化消息编辑器样式 ▼▼▼ */
#message-editor-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.message-editor-block {
    background-color: #f9f9f9;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
}

.message-editor-block textarea {
    width: 100%;
    min-height: 60px;
    resize: vertical;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 8px;
    font-size: 14px;
    box-sizing: border-box;
}

.message-editor-block .format-helpers {
    margin-top: 8px;
    margin-bottom: 0; /* 覆盖默认的 margin-bottom */
}

.message-editor-block .delete-block-btn {
    float: right;
    margin-top: -5px;
    background: none;
    border: none;
    color: #AB4D3F;
    font-size: 20px;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】联系人选择器样式 ▼▼▼ */
.contact-picker-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
.contact-picker-item .checkbox {
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    margin-right: 15px;
    transition: all 0.2s ease;
}
.contact-picker-item.selected .checkbox {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}
.contact-picker-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
}
.contact-picker-item .name {
    font-weight: 500;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】群成员管理界面样式 ▼▼▼ */
#member-management-list {
    padding: 0; /* 移除默认padding，让列表项撑满 */
}

.member-management-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
}

.member-management-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
}

.member-management-item .name {
    flex-grow: 1;
    font-weight: 500;
}

.member-management-item .remove-member-btn {
    background-color: #AB4D3F;
    color: white;
    border: none;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    font-size: 20px;
    line-height: 28px;
    text-align: center;
    cursor: pointer;
    flex-shrink: 0;
}

#member-management-actions {
    flex-shrink: 0;
    padding: 15px;
    border-top: 1px solid var(--border-color);
    background-color: #f7f7f7;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

#member-management-actions button {
    width: 100%;
    padding: 15px;
    background-color: var(--accent-color);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
}
#member-management-actions #create-new-member-btn {
    background-color: #657f49; /* 新建用绿色，以示区分 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外卖代付卡片样式 ▼▼▼ */
.message-bubble.is-waimai-request .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.waimai-card {
    width: 240px;
    border-radius: 12px;
    overflow: hidden;
    background-color: #fff;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

.waimai-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    border-bottom: 1px solid #f0f0f0;
}

.waimai-header .icon {
    width: 20px;
    height: 20px;
}

.waimai-header .title-group {
    display: flex;
    align-items: baseline;
    font-size: 14px;
    color: #8a8a8a;
}
.waimai-header .title-group .brand {
    font-weight: 600;
    color: #555;
    margin-right: 5px;
}
.waimai-header .title-group .separator {
    margin: 0 5px;
}

.waimai-catchphrase {
    font-size: 13px;
    color: #1f1f1f;
    padding: 12px;
}

.waimai-main {
    background-color: #FFD66B; /* 橙黄色背景 */
    padding: 12px;
    text-align: center;
}

.waimai-main .request-title {
    font-size: 12px;
    color: #856404;
    margin-bottom: 8px;
}

.waimai-main .payment-box {
    background-color: #fff;
    border-radius: 8px;
    padding: 15px 10px;
}

.waimai-main .payment-label {
    font-size: 13px;
    color: #8a8a8a;
}

.waimai-main .amount {
    font-size: 32px;
    font-weight: 700;
    color: #1f1f1f;
    margin: 4px 0 12px 0;
}

.waimai-main .countdown-label {
    font-size: 13px;
    color: #8a8a8a;
}
.waimai-main .countdown-timer {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    margin-left: 5px;
}
.waimai-main .countdown-timer span {
    background-color: #333;
    color: white;
    padding: 2px 4px;
    border-radius: 2px;
    font-weight: bold;
    font-size: 12px;
}

.waimai-details-btn {
    width: 100%;
    padding: 10px 0;
    margin-top: 15px;
    border: none;
    border-radius: 6px;
    background-color: #FFC33A;
    color: #49380a;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外卖响应状态样式 ▼▼▼ */

/* === 同意支付后的样式 === */
.message-bubble.status-paid .waimai-card {
    border: 2px solid #28a745; /* 绿色边框 */
}
.message-bubble.status-paid .waimai-main .request-title::before {
    content: '✅  ';
}
.message-bubble.status-paid .waimai-main .request-title {
    color: #155724;
    font-weight: 600;
    /* 重写 request-title 的内容 */
    content: "我已为您买单，请尽情享用吧～" !important;
    display: block;
    margin-bottom: 15px;
}

.message-bubble.status-paid .payment-box {
    display: none; /* 隐藏支付详情 */
}
.message-bubble.status-paid .waimai-details-btn {
    background-color: #28a745;
    color: white;
}

/* === 拒绝支付后的样式 === */
.message-bubble.status-rejected .waimai-card {
    border: 2px solid #dc3545; /* 红色边框 */
    opacity: 0.8;
}
.message-bubble.status-rejected .waimai-main {
    background-color: #e9ecef;
}
.message-bubble.status-rejected .waimai-main .request-title::before {
    content: '❌ ';
}
.message-bubble.status-rejected .waimai-main .request-title {
    color: #721c24;
    font-weight: 600;
    /* 重写 request-title 的内容 */
    content: "我拒绝了您的代付请求" !important;
    display: block;
    margin-bottom: 15px;
}
.message-bubble.status-rejected .payment-box {
    display: none; /* 隐藏支付详情 */
}
 .message-bubble.status-rejected .waimai-details-btn {
    background-color: #6c757d;
    color: white;
}

/* 强制重写 request-title 内容的技巧 */
.message-bubble[class*="status-"] .request-title {
    font-size: 0; /* 隐藏原始文本 */
}
.message-bubble[class*="status-"] .request-title::after {
    font-size: 14px; /* 让伪元素显示新文本 */
}
.message-bubble.status-paid .request-title::after {
    content: "我已为您买单，请尽情享用吧～";
}
.message-bubble.status-rejected .request-title::after {
    content: "我拒绝了您的代付请求";
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外卖请求的用户操作按钮样式 ▼▼▼ */
.waimai-user-actions {
    display: flex;
    gap: 10px;
    padding: 0 12px 12px 12px; /* 在卡片底部留出空间 */
    background-color: #fff;
}

.waimai-user-actions button {
    flex: 1;
    padding: 10px;
    border-radius: 8px;
    border: 1.5px solid;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.waimai-pay-btn {
    background-color: #28a745;
    border-color: #1f7a33;
    color: white;
}
.waimai-pay-btn:hover {
    background-color: #218838;
}

.waimai-decline-btn {
    background-color: #f8f9fa;
    border-color: #ced4da;
    color: #495057;
}
.waimai-decline-btn:hover {
    background-color: #e2e6ea;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* === 【新增】统一设置页面的背景色 (已修正) === */
#api-settings-screen,
#font-settings-screen,
#wallpaper-screen,
#memories-view,
#contact-picker-screen,
#member-management-screen,
#world-book-editor-screen {  
    background-color: #F7F7F7;
}

/* 确保这些页面的内容区能正确滚动 */
#api-settings-screen .form-container,
#font-settings-screen .form-container,
#wallpaper-screen .form-container {
    padding-top: 100px;
    margin-top: -80px;
    background-color: #F7F7F7;
}

/* 壁纸设置页面的预览区比较特殊，需要额外调整 */
#wallpaper-screen .form-container {
    align-items: center; /* 保持内容居中 */
}

/* ▼▼▼ 【全新】来电请求与视频通话界面样式 ▼▼▼ */

/* --- 来电请求模态框 --- */
#incoming-call-modal .incoming-call-content {
    background-color: rgba(40, 40, 40, 0.85);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 20px;
    width: 280px;
    padding: 30px 20px;
    text-align: center;
    color: white;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

.caller-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 12px;
    border: 3px solid rgba(255,255,255,0.5);
}

.caller-name {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 5px;
}

.caller-text {
    font-size: 14px;
    color: #ccc;
    margin-bottom: 30px;
}

.incoming-call-actions {
    display: flex;
    justify-content: space-around;
    align-items: center;
}

.action-button-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #e0e0e0;
}

.call-action-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    background-size: 50%;
    background-repeat: no-repeat;
    background-position: center;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}
.call-action-btn:active {
    transform: scale(0.9);
}

.call-action-btn.decline {
    background-color: #AB4D3F;
    /* 【核心修改】将图标的SVG代码换成一个简单的“X” */
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>');
}

.call-action-btn.accept {
    background-color: #657f49;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>');
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0.7); }
    70% { box-shadow: 0 0 0 15px rgba(76, 217, 100, 0); }
    100% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0); }
}

/* --- 视频通话界面 --- */
/* ▼▼▼ 请用这一整块【最终修正版】的代码，替换所有旧的 video-call 相关CSS ▼▼▼ */

/* 1. 通话屏幕总容器 (保持不变) */
#video-call-screen {
    background-color: #1c1c1e;
    color: white;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* 2. 顶部栏和底部控制栏 (保持不变) */
.video-call-top-bar {
    position: absolute;
    top: 0; left: 0; width: 100%;
    padding: 15px 20px;
    padding-top: 50px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
    z-index: 10;
    text-align: center;
    box-sizing: border-box;
    pointer-events: none;
}
#call-timer {
    font-size: 16px;
    font-weight: 500;
    letter-spacing: 1px;
}
.video-call-controls {
    position: absolute;
    bottom: 0; left: 0; width: 100%;
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 20px;
    padding-bottom: 40px;
    background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
    z-index: 10;
    box-sizing: border-box;
}

/* 3. 参与者头像显示区 (保持不变) */
.video-call-avatar-area {
    flex-shrink: 0; 
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    padding-top: 80px; /* 确保顶部有足够空间 */
    box-sizing: border-box;
    overflow-y: auto; /* ★ 新增：如果头像太多，允许此区域滚动 */
}

/* 4. 头像网格容器 (保持不变) */
#participant-avatars-grid {
    display: flex;
    flex-wrap: wrap; 
    justify-content: center;
    align-items: center;
    gap: 15px; /* ★ 稍微减小头像间距 */
    max-width: 100%;
}

/* 5. 单个参与者的头像容器 (头像缩小) */
.participant-avatar-wrapper {
    position: relative;
    text-align: center;
    flex-shrink: 0;
}
.participant-avatar {
    width: 70px;   /* ★ 从 80px 缩小到 70px */
    height: 70px;  /* ★ 从 80px 缩小到 70px */
    border-radius: 50%;
    object-fit: cover;
    border: 3px solid rgba(255, 255, 255, 0.2);
    transition: all 0.3s ease;
}
.participant-name {
    margin-top: 8px;
    font-size: 12px;
    color: #ccc;
}

/* 6. 发言者头像高亮效果 (保持不变) */
.participant-avatar.speaking {
    border-color: #657f49;
    box-shadow: 0 0 20px #657f49;
    transform: scale(1.05);
}

/* 7. 【最终版】对话框区域 */
#video-call-main {
    flex-grow: 1; 
    min-height: 40%; 
    margin: 0 15px 130px 15px; 
    overflow-y: auto;
    padding: 15px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    /* ▼▼▼ 修改2：新增这一行 ▼▼▼ */
    align-items: flex-start; /* 让气泡宽度自适应，不再强制拉伸 */
    /* ▲▲▲ 修改结束 ▲▲▲ */
    gap: 15px;
    box-sizing: border-box;
    
}

/* 8. 控制按钮样式 (保持不变) */
.control-btn {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    background-repeat: no-repeat;
    background-position: center;
    transition: transform 0.2s, background-color 0.2s;
}
.control-btn:active {
    transform: scale(0.9);
}
.control-btn.speak-btn {
    background-color: rgba(255,255,255,0.2);
    background-size: 55%;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><path d="M12 19v4"></path><path d="M8 23h8"></path></svg>');
}
.control-btn.hangup-btn {
    background-color: #AB4D3F;
    background-size: 50%;
    /* 【核心修改】将图标的SVG代码换成一个简单的“X” */
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>');
}
.control-btn.join-btn {
    background-color: #1E1E1E;
    background-size: 50%;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="17" y1="11" x2="23" y2="11"></line></svg>');
}

/* ▲▲▲ 新CSS替换结束 ▲▲▲ */

/* ▼▼▼ 【全新】视频通话对话气泡样式 ▼▼▼ */
.call-message-bubble {
    padding: 10px 15px;
    border-radius: 12px;
    max-width: 85%;
    line-height: 1.6;
    word-break: break-word;
    white-space: pre-wrap;
    /* ▼▼▼ 修改1：为所有气泡增加下方间距 ▼▼▼ */
    margin-bottom: 10px; 
    /* ▲▲▲ 修改结束 ▲▲▲ */
}

.call-message-bubble.ai-speech {
    background-color: rgba(255, 255, 255, 0.15);
    align-self: flex-start; /* AI发言靠左 */
    position: relative; /* 为重roll按钮定位 */
    cursor: pointer; /* 显示可点击 */
}

/* 重roll按钮样式 */
.reroll-btn {
    position: absolute;
    right: -40px;
    top: 50%;
    transform: translateY(-50%);
    width: 28px;
    height: 28px;
    background-color: rgba(255, 255, 255, 0.9);
    border: none;
    border-radius: 50%;
    display: none;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 100;
    transition: all 0.2s ease;
    backdrop-filter: blur(10px);
}

.reroll-btn:hover {
    background-color: rgba(255, 255, 255, 1);
    transform: translateY(-50%) scale(1.1);
}

.reroll-btn svg {
    width: 16px;
    height: 16px;
    fill: #666;
}

.call-message-bubble.user-speech {
    background-color: #5f9668; /* 用户发言用绿色，类似微信 */
    align-self: flex-end;   /* 用户发言靠右 */
    text-align: left; /* 确保用户气泡内的文字是左对齐的 */
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */

/* ▼▼▼ 【全新添加】正在呼叫界面样式 ▼▼▼ */
#outgoing-call-screen {
    background-color: #1c1c1e;
    color: white;
    justify-content: center; /* 垂直居中 */
    align-items: center;   /* 水平居中 */
}

.outgoing-call-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.outgoing-call-actions {
    margin-top: 50px; /* 和上方文字拉开距离 */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #e0e0e0;
}
/* ▲▲▲ 添加结束 ▲▲▲ */

/* 1. 动态帖子的外层容器，我们需要它来定位和裁剪 */
.qzone-post-container {
    position: relative; /* 让内部的删除按钮可以相对于它定位 */
    overflow: hidden;   /* 隐藏掉超出部分的删除按钮 */
    border-radius: 12px;/* 和内部卡片保持一致的圆角 */
}

/* 2. 可滑动的内容卡片，增加一个平滑的过渡效果 */
.qzone-post-item {
    transition: transform 0.3s ease;
    background-color: var(--secondary-bg); /* 确保它有背景色，能盖住下面的删除按钮 */
    position: relative; /* 确保它在最上层 */
    z-index: 2;
}

/* 3. 【核心】这就是那个“删除”按钮的样式！*/
.qzone-post-delete-action {
    position: absolute; /* 绝对定位，脱离文档流 */
    top: 0;
    right: 0;
    bottom: 0;
    width: 90px; /* 删除按钮的宽度 */
    background-color: #AB4D3F; /* 您想要的红色背景 */
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 500;
    cursor: pointer;
    z-index: 1; /* 确保它在卡片下面 */
}

/* 4. 当卡片左滑时，把它向左移动，露出删除按钮 */
.qzone-post-item.swiped {
    transform: translateX(-90px); /* 移动的距离和删除按钮的宽度一致 */
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这【一整块】全新的“拍一拍”样式，粘贴到 <style> 的末尾 ▼▼▼ */

/* 1. “拍一拍”的屏幕震动动画 */
@keyframes pat-shake {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
    20%, 40%, 60%, 80% { transform: translateX(3px); }
}

.pat-animation {
    animation: pat-shake 0.4s ease-in-out;
}

/* 2. “拍一拍”系统提示消息的样式 */
.system-message {
    align-self: center; /* 居中显示 */
    padding: 4px 12px;
    margin: 5px 0;
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    border-radius: 10px;
    text-align: center;
    max-width: 80%;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* 让“拍一拍”类型的 wrapper 居中 */
.message-wrapper.system-pat {
    justify-content: center;
    align-self: center;
    margin: 5px 0;
    max-width: 80%;
}
/* “拍一-拍”消息气泡的样式 */
.message-bubble.system-bubble {
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    padding: 4px 12px;
    border-radius: 10px;
}

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* === 修正：让顶部操作栏可以横向滚动 === */
#chat-input-actions-top {
    display: flex;
    gap: 8px;
    padding: 0 5px;

    /* --- 核心代码开始 --- */
    overflow-x: auto;      
    flex-wrap: nowrap;     
    -webkit-overflow-scrolling: touch; 

    scrollbar-width: none; 
    -ms-overflow-style: none;  
}

#chat-input-actions-top::-webkit-scrollbar {
    display: none; 
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* === 【全新】聊天界面头部状态栏样式 === */

/* 1. 标题和状态的总容器，使用flex布局让它们垂直排列 */
#chat-header-title-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center; /* 水平居中 */
    gap: 2px; /* 标题和状态之间的微小间距 */
    
    /* 为了让它能在flex布局中正确居中 */
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    max-width: 60%;
}

/* 2. 主标题的样式微调 */
#chat-header-title {
    font-size: 16px; /* 可以稍微缩小一点，给状态栏留出空间 */
    font-weight: 600;
    position: static; /* 覆盖掉旧的absolute定位 */
    transform: none;  /* 覆盖掉旧的transform */
    /* 保证长标题也能正确显示省略号 */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
}

/* 3. 状态栏容器 */
#chat-header-status {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 11px;
    color: var(--text-secondary);
    transition: all 0.3s ease;
}

/* 4. 状态小圆点 */
.status-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background-color: #657f49; /* 默认绿色，代表在线 */
    transition: background-color 0.3s ease;
    flex-shrink: 0; /* 新增此行，防止被压缩 */
}

/* 当AI状态为“忙碌”或“离开”时，让圆点变灰色 */
#chat-header-status.busy .status-dot {
    background-color: #cccccc;
}

/* 5. 状态文本 */
.status-text {
    font-weight: 500;
}

/* ★★★★★【全新美化】状态更新加载动画气泡★★★★★ */
.status-updating-bubble {
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    margin-top: 0px;
    
    padding: 1px 6px;
    border-radius: 20px;
    
    /* 毛玻璃背景效果 */
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    
    /* 浅灰色边框 */
    border: 1px solid rgba(200, 200, 200, 0.6);
    
    /* 阴影效果 */
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    
    font-size: 10px;
    font-weight: 500;
    color: var(--text-secondary);
    
    /* 动画效果 */
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
    
    white-space: nowrap;
    z-index: 10;
}

.status-updating-bubble.visible {
    opacity: 1;
}

.status-updating-bubble::after {
    content: '更新中';
    animation: status-loading-dots 1.5s infinite;
}

@keyframes status-loading-dots {
    0%, 20% { content: '更新中.'; }
    25%, 45% { content: '更新中..'; }
    50%, 70% { content: '更新中...'; }
    75%, 95% { content: '更新中'; }
    100% { content: '更新中.'; }
}

/* 确保状态栏容器有相对定位，以便气泡正确定位 */
#chat-header-status {
    position: relative;
}
/* ★★★★★【状态更新动画结束】★★★★★ */

/* === 【全新美化版】回忆卡片样式 === */

/* 1. 卡片总容器：这里负责定义整体的背景色和边框 */
.memory-card {
    background-color: #FFFFFF;
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* 修改点：更换为更清晰柔和的阴影 */
    border: 1px solid #EAEAEA; /* 修改点：替换掉border-left，改为完整的细灰色边框 */
    display: flex;
    flex-direction: column;
    gap: 8px;
}

/* 2. 头部容器：现在只负责布局和分割线 */
.memory-card .header {
    background-color: #FFFFFF;
    border-bottom: 1px solid rgba(109, 110, 131, 0.15); /* 分割线颜色可以稍微加深一点 */
    padding-bottom: 8px; 
}

/* 3. 日期样式 (保持不变) */
.memory-card .header .date {
    font-size: 11px;
    color: #1E1E1E;
    margin-bottom: 4px; 
}

/* 4. 作者样式 (保持不变) */
.memory-card .header .author {
    font-weight: 600;
    color: #1E1E1E;
    font-size: 15px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 5. 内容区样式 (保持不变) */
.memory-card .content {
    font-size: 14px;
    line-height: 1.7;
    color: #1E1E1E;
    white-space: pre-wrap;
}

/* === 【全新】约定/倒计时卡片样式 === */
.countdown-card {
    background: linear-gradient(135deg, #1E1E1E, #1E1E1E);
    color: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(104, 97, 111, 0.4);
    text-align: center;
    position: relative;
    overflow: hidden;
    flex-shrink: 0;
}
.countdown-card::before {
    
    position: absolute;
    top: -10px;
    left: -10px;
    font-size: 50px;
    opacity: 0.1;
    transform: rotate(-15deg);
}
.countdown-card .title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 15px;
}
.countdown-card .timer {
    font-size: 28px;
    font-weight: 300;
    letter-spacing: 2px;
    margin-bottom: 15px;
}
.countdown-card .target-date {
    font-size: 12px;
    opacity: 0.8;
    border-top: 1px solid rgba(255,255,255,0.2);
    padding-top: 10px;
}

/* === 【全新】聊天锁定遮罩层样式 === */
#chat-lock-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: #F7F7F7;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    z-index: 100; /* 比输入框高，比贴纸面板低 */
    display: none; /* 默认隐藏 */
    align-items: center;
    justify-content: center;
    padding: 10px;
    box-sizing: border-box;
    border-top: 1px solid var(--border-color);
    text-align: flex-end;
    
}
#chat-lock-content {
    display: flex;
    flex-direction: column;
    gap: 5px;
    align-items: center;
    text-align: center;
}
#chat-lock-content .lock-text {
    color: var(--text-secondary);
    font-size: 14px;
}
#chat-lock-content .lock-action-btn {
    padding: 8px 15px;
    border-radius: 14px;
    border: 1px solid var(--accent-color);
    background-color: var(--accent-color);
    color: white;
    cursor: pointer;
}
#chat-lock-content .lock-action-btn.secondary {
    background-color: transparent;
    color: var(--accent-color);
}
/* ▼▼▼ 在这里粘贴新代码 ▼▼▼ */
.lock-actions-row {
    display: flex;
    gap: 10px; /* 按钮之间的间距 */
    align-items: center; /* 垂直居中对齐 */
    width: 100%;
}
#toggle-dev-panel-btn {
    width: 32px;
    height: 32px;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    /* ▼▼▼ 全新添加的样式 ▼▼▼ */
    background-color: #1E1E1E !important; /* 主色调背景 */
    border-radius: 50%; /* 变为圆形 */
    border: none; /* 移除边框 */
    cursor: pointer;
}
/* ▲▲▲ 新代码粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】红包卡片样式 ▼▼▼ */
.message-bubble.is-red-packet .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.red-packet-card {
    width: 220px;
    border-radius: 8px;
    background: linear-gradient(160deg, #F96259, #E44D44);
    color: #ffd700; /* 金色文字 */
    padding: 12px;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    position: relative;
    overflow: hidden;
}

.red-packet-card.opened {
    background: linear-gradient(160deg, #d3c4a0, #c4b693);
    cursor: default;
}

.red-packet-card::before {
    content: '🧧';
    position: absolute;
    top: -5px;
    left: -5px;
    font-size: 30px;
    opacity: 0.2;
    transform: rotate(-10deg);
}

.rp-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}

.rp-icon {
    width: 20px;
    height: 20px;
}

.rp-greeting {
    font-size: 15px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.rp-type {
    font-size: 11px;
    color: white;
    opacity: 0.8;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    padding-top: 8px;
    margin-top: 8px;
}

.rp-claimed-info {
    font-size: 13px;
    color: white;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid rgba(255,255,255,0.3);
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】红包详情列表样式 ▼▼▼ */
.rp-details-item {
    display: flex;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid #eee;
}
.rp-details-item:last-child {
    border-bottom: none;
}
.rp-details-item .name {
    flex-grow: 1;
    font-weight: 500;
    color: #333;
}
.rp-details-item .amount {
    font-weight: 500;
    color: #555;
}
.rp-details-item .lucky-king-tag {
    font-size: 10px;
    background-color: #ffd700;
    color: #a67c00;
    padding: 2px 5px;
    border-radius: 4px;
    margin-left: 8px;
    font-weight: bold;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】投票功能样式 ▼▼▼ */

/* 投票卡片在消息气泡中的样式 */
.message-bubble.is-poll .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

/* 投票卡片主体 */
.poll-card {
    width: 250px;
    background-color: #f9f9f9;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    padding: 12px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.poll-card.closed {
    background-color: #e9ecef; /* 结束后变灰 */
}

/* 投票问题 */
.poll-question {
    font-weight: 600;
    font-size: 15px;
    margin-bottom: 12px;
    line-height: 1.4;
    word-break: break-word;
}

/* 投票选项列表 */
.poll-options-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

/* 单个投票选项 */
.poll-option-item {
    background-color: white;
    border: 1px solid #dcdcdc;
    border-radius: 8px;
    padding: 10px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: background-color 0.2s;
}

.poll-card:not(.closed) .poll-option-item:hover {
    background-color: #f0f8ff;
}

/* 用户已投票的选项样式 */
.poll-option-item.voted {
    border-color: var(--accent-color);
    background-color: #e7f3ff;
    font-weight: 500;
}

/* 投票进度条 */
.poll-option-bar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background-color: rgba(0, 123, 255, 0.1);
    z-index: 1;
    transition: width 0.3s ease-in-out;
}

/* 选项内容（文字和票数），确保在进度条之上 */
.poll-option-content {
    position: relative;
    z-index: 2;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.poll-option-text {
    font-size: 14px;
}

.poll-option-votes {
    font-size: 13px;
    color: #8a8a8a;
    font-weight: 500;
}

/* 投票卡片底部 */
.poll-footer {
    margin-top: 12px;
    padding-top: 8px;
    border-top: 1px solid #e9e9e9;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: var(--text-secondary);
}

.poll-total-votes {
    font-weight: 500;
}

.poll-action-btn {
    background: none;
    border: 1px solid var(--accent-color);
    color: var(--accent-color);
    padding: 4px 10px;
    border-radius: 15px;
    cursor: pointer;
    font-size: 12px;
}
.poll-card.closed .poll-action-btn {
    background-color: #6c757d;
    color: white;
    border-color: #6c757d;
}

/* 创建投票模态框的选项输入 */
.poll-option-input-wrapper {
    display: flex;
    align-items: center;
    gap: 8px;
}
.poll-option-input-wrapper input {
    flex-grow: 1;
}
.poll-option-input-wrapper .remove-option-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: #f0f0f0;
    color: #AB4D3F;
    border: none;
    cursor: pointer;
    font-size: 18px;
    line-height: 28px;
    text-align: center;
    flex-shrink: 0;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* === 【全新】聊天头部“正在输入”状态样式 === */
#chat-header-title.typing-status {
    color: var(--text-secondary);
    animation: typing-pulse 1.5s infinite;
}

@keyframes typing-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
}

#chat-header-title {
    transition: opacity 0.2s ease-in-out;
}

@keyframes message-pop-in {
  from {
    opacity: 0;
    transform: translateY(15px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message-wrapper.animate-in {
  animation: message-pop-in 0.3s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
  }

/* ▼▼▼ 【全新】App图标设置样式 ▼▼▼ */
#icon-settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 20px;
    width: 100%;
    padding: 0 10px;
    box-sizing: border-box;
}

.icon-setting-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.icon-preview {
    width: 60px;
    height: 60px;
    border-radius: 15px;
    background-size: cover;
    background-position: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.change-icon-btn {
    padding: 4px 12px; /* 稍微增加左右间距，让文字更舒展 */
    font-size: 12px;
    border: none; /* 修改点：移除了边框 */
    background-color: #1E1E1E; /* 修改点：更换为您想要的背景色，例如主题黑色 */
    color: #FFFFFF; /* 新增：文字颜色改为白色以保证清晰 */
    border-radius: 20px; /* 修改点：将圆角改大，使其更圆润 */
    cursor: pointer;
    transition: background-color 0.2s; /* 新增：添加一个简单的悬浮过渡效果 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外观设置页面布局修正 ▼▼▼ */

/* 1. 修正滚动问题 */
#wallpaper-screen .form-container {
    /* 核心修正1: 解决flex布局下的滚动冲突，让滚动条能正常出现 */
    min-height: 0; 
}

/* 2. 修正壁纸预览被压扁的问题 */
#wallpaper-preview {
    /* 核心修正2: 防止预览框被过多的内容挤压变形，让它保持自己的高度 */
    flex-shrink: 0; 
}
/* ▲▲▲ 修正结束 ▲▲▲ */

/* ▼▼▼ 【全新】分享链接功能样式 (无图版) ▼▼▼ */

/* 1. 浏览器界面背景色和内容区样式 (保持不变) */
#browser-screen {
    background-color: #f8f9fa;
}
#browser-content {
    padding: 20px;
    font-size: 16px;
    line-height: 1.8;
    color: #333;
    overflow-y: auto;
    background-color: #f8f9fa;
}
#browser-content .article-title {
    font-size: 24px;
    font-weight: 700;
    margin-bottom: 10px;
}
#browser-content .article-meta {
    font-size: 13px;
    color: #8a8a8a;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid #e0e0e0;
}
#browser-content .article-body {
    white-space: pre-wrap;
    word-break: break-word;
}
#browser-content .article-body p {
    margin-bottom: 1em;
}

/* 2. 聊天气泡中的链接卡片样式 (无图版) */
.message-bubble.is-link-share .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.link-share-card {
    width: 210px; 
    background-color: #fff;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    padding: 12px;
    cursor: pointer;
    transition: background-color 0.2s;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.link-share-card:hover {
    background-color: #f9f9f9;
}

.link-share-card .title {
    font-weight: 600;
    font-size: 15px;
    line-height: 1.4;
    color: #1f1f1f;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-share-card .description {
    font-size: 13px;
    color: #8a8a8a;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-share-card .footer {
    display: flex; /* 让图标和文字水平对齐 */
    align-items: center;
    gap: 6px; /* 图标和文字的间距 */
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px; /* 和上面的描述拉开一点距离 */
}
.link-share-card .footer-icon {
    width: 14px;
    height: 14px;
    flex-shrink: 0; /* 防止图标被压缩 */
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 单条评论的容器，现在需要相对定位 */
.comment-item {
    position: relative;
    padding-right: 25px; /* 在右侧留出删除按钮的空间 */
}

/* 评论删除按钮的样式 */
.comment-delete-btn {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    line-height: 22px;
    text-align: center;
    border-radius: 50%;
    color: var(--text-secondary);
    font-size: 18px;
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0; /* 默认隐藏 */
}

/* 鼠标悬停在评论上时，显示删除按钮 */
.comment-item:hover .comment-delete-btn {
    opacity: 1;
}

.comment-delete-btn:hover {
    background-color: #f0f0f0;
    color: #AB4D3F;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* === 【全新】夜间模式样式 === */

/* 核心：当 #phone-screen 拥有 .dark-mode 类时，激活以下所有样式 */

/* 1. 全局背景和文本颜色 */
#phone-screen.dark-mode {
    --secondary-bg: #1c1c1e; /* 主要卡片背景色 */
    --border-color: #38383a;  /* 边框颜色 */
    --text-primary: #ffffff;   /* 主要文字颜色 */
    --text-secondary: #8d8d92; /* 次要文字/图标颜色 */
}

/* 2. 各个页面的主背景色 */
#phone-screen.dark-mode #chat-list-screen,
#phone-screen.dark-mode #qzone-screen .qzone-content,
#phone-screen.dark-mode #memories-view {
    background-color: #000000;
}

/* 3. 聊天列表 */
#phone-screen.dark-mode #chat-list {
    background-color: #000000;
}
#phone-screen.dark-mode .chat-list-item {
    border-bottom-color: rgba(255, 255, 255, 0.15);
}
#phone-screen.dark-mode .chat-group-header {
    background-color: #1c1c1e; /* 从白色改为深灰色 */
    border-bottom: 1px solid #38383a; /* 给它一个细微的下边框 */
}
#phone-screen.dark-mode .chat-list-item .name,
#phone-screen.dark-mode .chat-group-header .group-name {
    color: #ffffff;
}
#phone-screen.dark-mode .chat-list-item:hover {
    background-color: #1c1c1e;
}

/* 4. 顶部/底部导航栏 */
#phone-screen.dark-mode .header,
#phone-screen.dark-mode .qzone-header {
    background-color: #191919;
    
    border-bottom-color: rgba(255, 255, 255, 0.15);
    color: #ffffff;
}
#phone-screen.dark-mode .header .back-btn,
#phone-screen.dark-mode .header .action-btn,
#phone-screen.dark-mode .header .save-btn {
    color: #ffffff;
}
#phone-screen.dark-mode #chat-list-bottom-nav {
    background-color: rgba(25, 25, 25, 0.9);
    border-top-color: rgba(255, 255, 255, 0.15);
}
#phone-screen.dark-mode .nav-item.active {
    color: #ffffff;
}

/* 5. 聊天界面 */
#phone-screen.dark-mode #chat-input-area {
    background-color: #191919;
    border-top: none;
    padding-bottom: 28px; /* 与普通模式保持一致：原8px + 新增10px = 18px */
}
#phone-screen.dark-mode #chat-input {
    background-color: #1E1E1E;
    color: #ffffff;
}
#phone-screen.dark-mode #chat-input::placeholder {
    color: #8d8d92;
}
#phone-screen.dark-mode .chat-action-icon-btn {
    color: #ffffff;
    background-color: rgba(255, 255, 255, 0.1);
    border: none;
}
#phone-screen.dark-mode #send-btn {
    background-color: var(--accent-color);
}

/* 6. 动态 (QZone) 界面 */
#phone-screen.dark-mode .qzone-actions-bar,
#phone-screen.dark-mode .qzone-post-item {
    background-color: #1c1c1e;
    border: 1px solid #333;
    box-shadow: 0 2px 8px rgba(255, 255, 255, 0.05);
}
#phone-screen.dark-mode .action-item:not(:last-child)::after {
    background-color: #333;
}
#phone-screen.dark-mode .post-footer,
#phone-screen.dark-mode .post-likes-section {
    border-top-color: #333;
}
#phone-screen.dark-mode .post-likes-section {
    background-color: rgba(0, 123, 255, 0.1);
}
#phone-screen.dark-mode .comment-input {
    background-color: #333;
    color: #ffffff;
}
#phone-screen.dark-mode .comment-input::placeholder {
    color: #8d8d92;
}
#phone-screen.dark-mode .post-actions-btn:hover {
    background-color: #333;
}
#phone-screen.dark-mode .at-mention-popup {
    background-color: #1c1c1e;
    border-color: #333;
}
#phone-screen.dark-mode .at-mention-item {
    border-bottom-color: #333;
}
#phone-screen.dark-mode .at-mention-item:hover {
    background-color: #333;
}

/* 7. 回忆录界面 */
#phone-screen.dark-mode .memory-card {
    background-color: #1c1c1e;
    border-left-color: #e6a753;
    box-shadow: 0 4px 12px rgba(255, 255, 255, 0.08);
}
#phone-screen.dark-mode .memory-card .header {
    background-color: #2c2c2e;
    border-bottom-color: #38383a;
    margin: -15px -15px 8px -15px;
    padding: 12px 15px;
    border-radius: 12px 12px 0 0;
}
#phone-screen.dark-mode .memory-card .header .date,
#phone-screen.dark-mode .memory-card .header .author,
#phone-screen.dark-mode .memory-card .content {
    color: #e0e0e0;
}

/* 8. 其他设置和列表页 */
#phone-screen.dark-mode #api-settings-screen,
#phone-screen.dark-mode #font-settings-screen,
#phone-screen.dark-mode #wallpaper-screen,
#phone-screen.dark-mode #contact-picker-screen,
#phone-screen.dark-mode #member-management-screen,
#phone-screen.dark-mode #world-book-editor-screen,
#phone-screen.dark-mode #world-book-list,
#phone-screen.dark-mode .list-item:hover,
#phone-screen.dark-mode .list-container,
#phone-screen.dark-mode .form-container {
    background-color: #000000;
}
#phone-screen.dark-mode .form-group input, 
#phone-screen.dark-mode .form-group select, 
#phone-screen.dark-mode .form-group textarea {
    background-color: #1c1c1e;
    color: #ffffff;
    border-color: #38383a;
}
#phone-screen.dark-mode .form-button-secondary {
    background-color: #333;
    border-color: #555;
    color: #fff;
}
#phone-screen.dark-mode #font-preview {
    background-color: #1c1c1e;
    border-color: #38383a;
}
#phone-screen.dark-mode #font-preview p {
    color: #ffffff;
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */

/* ▼▼▼ 把这一整块【全新的修正CSS】，粘贴到 <style> 的末尾 ▼▼▼ */

/* === 【全新】夜间模式视觉修正 === */

/* 1. 修正动态卡片内的文字颜色 */
#phone-screen.dark-mode .qzone-post-item .post-nickname,
#phone-screen.dark-mode .qzone-post-item .post-content {
    color: #f0f0f0; /* 从深灰色改为明亮的浅灰色 */
}

/* 2. 修正收藏卡片内的文字颜色 */
#phone-screen.dark-mode .favorite-item-card .fav-card-header .name,
#phone-screen.dark-mode .favorite-item-card .fav-card-content {
    color: #f0f0f0; /* 同样改为浅灰色 */
}
#phone-screen.dark-mode .favorite-item-card .fav-card-header .source {
    color: #8d8d92; /* 来源文字用次要灰色 */
}

/* 3. 修正收藏页的搜索栏背景和输入框样式 */
#phone-screen.dark-mode .search-bar-container {
    background-color: #000000; /* 容器背景变为纯黑 */
}
#phone-screen.dark-mode #favorites-search-input {
    background-color: #1c1c1e; /* 输入框背景变为深灰 */
    border-color: #38383a;     /* 边框颜色变暗 */
    color: #ffffff;            /* 输入文字变为白色 */
}
#phone-screen.dark-mode #favorites-search-input::placeholder {
    color: #8d8d92; /* 占位符文字颜色变暗 */
}

/* ▲▲▲ 修正CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* === 【全新】iOS风格的Toggle Switch开关样式 === */

/* 1. 开关的容器 */
.toggle-switch {
    position: relative;
    display: inline-block;
    width: 51px;
    height: 31px;
}

/* 2. 隐藏掉原始的 checkbox 输入框 */
.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

/* 3. 开关的背景（那个椭圆） */
.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #e9e9eb; /* 关闭时的背景色 */
    transition: .4s;
    border-radius: 34px;
}

/* 4. 开关上的圆点 */
.slider:before {
    position: absolute;
    content: "";
    height: 27px;
    width: 27px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

/* 5. 【核心】当 checkbox 被选中时（即开启状态） */
input:checked + .slider {
    background-color: #34c759; /* 开启时的背景色（iOS绿色）*/
}

input:checked + .slider:before {
    transform: translateX(20px); /* 让圆点滑动到右边 */
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】引用回复功能样式 ▼▼▼ */

/* === 【全新美化版】回复预览栏样式 === */
#reply-preview-bar {
    display: none; /* 默认隐藏 */
    position: relative;

    /* 毛玻璃气泡核心样式 */
    background: rgba(255, 255, 255, 0.6);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);

    /* 修改点1：调整边距和圆角，使其成为一个独立的气泡 */
    margin: 0 8px 10px 8px;
    padding: 8px 30px 8px 12px; /* 右侧留出关闭按钮的位置 */
    border-radius: 12px;

    /* 修改点2：移除了旧的 border-left */
    border-left: none;
}

/* 夜间模式适配 */
#phone-screen.dark-mode #reply-preview-bar {
    background: rgba(28, 28, 30, 0.7);
    border-color: rgba(255, 255, 255, 0.2);
}

/* 美化内部文字颜色 */
.reply-preview-content .sender {
    font-weight: 600;
    color: var(--text-primary);
    font-size: 13px;
}

.reply-preview-content .text {
    font-size: 13px;
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: block;
    max-width: 100%;
}

/* 美化关闭按钮 */
#cancel-reply-btn {
    position: absolute;
    top: 50%;
    right: 8px;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    line-height: 22px;
    text-align: center;
    border-radius: 50%;
    background-color: rgba(0, 0, 0, 0.1);
    cursor: pointer;
    font-size: 16px;
    font-weight: 300;
    color: var(--text-secondary);
    transition: background-color 0.2s;
}

#cancel-reply-btn:hover {
    background-color: rgba(0, 0, 0, 0.2);
}

#phone-screen.dark-mode #cancel-reply-btn {
    background-color: rgba(255, 255, 255, 0.15);
    color: var(--text-secondary);
}


/* === 【全新美化版】引用消息气泡样式 (已支持换行) === */
.quoted-message {
    padding: 6px 12px;
    margin-bottom: 8px;
    background-color: rgba(0, 0, 0, 0.04);
    border-left: none;
    border-radius: 10px;
    font-size: 13px;
    color: inherit; /* ★ 核心修改：从固定颜色改为继承父元素颜色 */
    opacity: 0.8;   /* (推荐) 增加一点透明度，让引用文字和主消息有区分度 */

    /* ▼▼▼ 其他样式保持不变 ▼▼▼ */
    white-space: pre-wrap;
    overflow: visible;
    text-overflow: clip;
    word-break: break-word;
    display: block;
}

/* 夜间模式适配 */
#phone-screen.dark-mode .quoted-message {
    background-color: rgba(255, 255, 255, 0.08); /* 夜间模式下更亮的背景 */
    border-left: none; /* 同样移除竖线 */
}

/* 引用消息中的发送者名字加粗 */
.quoted-message .quoted-sender-name {
    font-weight: 500;
}

/* === 字体预览框样式 (修正后) === */

/* 默认（日间模式）的样式 */
#font-preview {
    padding: 20px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: #f9f9f9; /* 日间模式的浅灰色背景 */
    transition: background-color 0.3s, border-color 0.3s;
}

/* 预览框里的文字颜色，默认是黑色 */
#font-preview p {
    color: var(--text-primary);
}

/* 夜间模式下的修正样式 */
#phone-screen.dark-mode #font-preview {
    background-color: #1c1c1e; /* 深灰色背景 */
    border-color: #38383a;     /* 暗色边框 */
}

/* 夜间模式下，预览框里的文字变为白色 */
#phone-screen.dark-mode #font-preview p {
    color: #ffffff;
}

/* ▼▼▼ 【全新】精致版转账操作弹窗样式 ▼▼▼ */
.transfer-actions-content {
    background-color: #ffffff; /* 粉嫩的背景色 */
    border-radius: 20px;
    width: 290px;
    padding: 20px;
    box-shadow: 0 5px 25px rgba(68, 73, 92, 0.3); /* 粉色阴影 */
    text-align: center;
    position: relative;
    border: 1px solid #fafafa;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.transfer-actions-header {
    font-size: 20px;
    font-weight: bold;
    color: #1E1E1E; /* 深粉色标题 */
    margin-bottom: 15px;
}

.transfer-actions-body p {
    font-size: 15px;
    color: #555;
    margin: 0 0 25px 0;
    line-height: 1.5;
}

.transfer-actions-footer {
    display: flex;
    justify-content: space-between;
    gap: 15px;
}

.transfer-actions-footer .action-btn {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    color: white;
}

.transfer-actions-footer .action-btn:active {
    transform: scale(0.95);
}

.transfer-actions-footer .action-btn.accept {
    background: linear-gradient(135deg, #1E1E1E, #1E1E1E);
    box-shadow: 0 4px 10px #F7F7F7;
}

.transfer-actions-footer .action-btn.decline {
    background: #F7F7F7;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

.transfer-actions-content .cancel-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: none;
    background-color: rgba(0, 0, 0, 0.1);
    color: #1E1E1E;
    font-size: 20px;
    line-height: 28px;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 未读消息红点样式 === */
.unread-count-wrapper {
    flex-shrink: 0;
    width: 40px;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding-top: 20px; /* 让红点和名字差不多高 */
}

.unread-count {
        position: relative; /* 新增：开启相对定位，为移动做准备 */
        left: 4px; /* 新增：向右移动5px */
        min-width: 20px;
        height: 20px;
        padding: 0 6px;
        background-color: #AB4D3F; /* iOS 风格的红色 */
        color: white;
        font-size: 13px;
        font-weight: 500;
        line-height: 20px;
        text-align: center;
        border-radius: 10px; /* 圆角矩形 */
        box-shadow: 0 1px 2px rgba(0,0,0,0.15);
        display: none; /* 默认隐藏 */
        justify-content: center;
        align-items: center;
    }
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】通话记录页面与卡片样式 ▼▼▼ */

/* 确保页面背景色统一 */
#call-history-screen {
    background-color: #F7F7F7;
}

/* 通话记录卡片样式 */
.call-record-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
   
}
.call-record-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.1);
}

/* 卡片头部：包含日期和时长 */
.call-record-card .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 13px;
    color: var(--text-secondary);
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
}
.call-record-card .card-header .duration {
    font-weight: 500;
    color: var(--text-primary);
}

/* 卡片主体：参与者头像 */
.call-record-card .card-body {
    display: flex;
    align-items: center;
}
.call-record-card .participants-avatars {
    display: flex;
    align-items: center;
}
.call-record-card .participant-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid white;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
/* 让头像有一个漂亮的堆叠效果 */
.call-record-card .participant-avatar:not(:first-child) {
    margin-left: -12px;
}
.call-record-card .participants-names {
    margin-left: 12px;
    font-weight: 600;
    color: var(--text-primary);
    font-size: 15px;
}

/* --- 通话详情弹窗样式 --- */
#transcript-modal-body {
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 15px;
}
.transcript-entry {
    padding: 8px 12px;
    border-radius: 10px;
    max-width: 85%;
    line-height: 1.5;
    word-break: break-word;
}
.transcript-entry.user {
    background-color: #dcf8c6; /* 类似微信的绿色 */
    align-self: flex-end;
}
.transcript-entry.assistant {
    background-color: #ffffff;
    align-self: flex-start;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

#chat-list-title {
    cursor: pointer;
}

/* ▼▼▼ 【全新】通话记录卡片美化样式 ▼▼▼ */

.call-record-card .card-body {
    /* 将 body 改为 flex 布局，让标题和参与者信息垂直排列 */
    display: flex;
    flex-direction: column;
    gap: 8px; /* 标题和参与者信息之间的间距 */
}

.call-record-card .custom-title {
    font-size: 16px;
    font-weight: 600; /* 加粗，让它像个标题 */
    color: var(--text-primary);
    padding-bottom: 8px; /* 标题下的留白 */
    border-bottom: 1px solid var(--border-color); /* 在标题下加一条分割线 */
    margin-bottom: 4px; /* 和下面的参与者信息拉开一点距离 */
}

.call-record-card .participants-info {
    /* 这个新容器让头像和“与xx”能水平对齐 */
    display: flex;
    align-items: center;
}

/* 参与者名字的样式微调，让它不那么突出 */
.call-record-card .participants-names {
    margin-left: 12px;
    font-weight: 500; /* 不再加粗 */
    font-size: 14px; /* 稍微小一点 */
    color: var(--text-secondary); /* 使用次要文字颜色 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】语音转文字功能样式 ▼▼▼ */

/* 1. 语音文字内容的样式 (已修复移动端显示BUG) */
.voice-transcript ,
.translation-text {
    /* ▼▼▼ 核心修改：移除绝对定位，让其回归文档流 ▼▼▼ */
    /* position: absolute;  <-- 已删除 */
    /* top: 100%;           <-- 已删除 */
    /* left: 0;             <-- 已删除 */
    /* ▲▲▲ 修改结束 ▲▲▲ */
    width: 100%; /* 新增：让其宽度与父容器对齐 */
    max-width: 260px;
    box-sizing: border-box;

    font-size: 14px;
    line-height: 1.6;
    color: var(--text-secondary);
    padding: 5px 8px;
    margin-top: 6px;
    background-color: rgba(255, 255, 255, 0.4);
    border-radius: 6px;
    word-break: break-word;
    display: none;
}


#phone-screen.dark-mode .voice-transcript,
#phone-screen.dark-mode .translation-text {
    background-color: rgba(255, 255, 255, 0.1); /* 夜间模式下的背景色 */
}


/* 2. 旋转加载动画的样式 */
.loading-spinner {
    display: none; /* 默认隐藏 */
    width: 16px;
    height: 16px;
    border: 2px solid rgba(0, 0, 0, 0.2);
    border-top-color: var(--accent-color); /* 旋转部分的颜色 */
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 8px; /* 和波形图、时长保持一点间距 */
}

/* 3. 定义旋转动画 */
@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】分享记录查看器样式修正 ▼▼▼ */
#shared-history-viewer-content {
    display: flex;
    flex-direction: column; /* 让气泡垂直排列 */
    gap: 20px; /* 在每个气泡之间增加20像素的间距 */
    padding: 15px; /* 在容器四周也增加一些内边距，避免气泡贴边 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】播放器和歌词样式 ▼▼▼ */
#music-player-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 50;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding-top: 60px;
    background-color: rgba(0,0,0,0.3);
    opacity: 0;
    visibility: hidden;
    transform: translateY(-50px);
    transition: opacity 0.4s ease-out, transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}

#music-player-overlay.visible {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
}

.music-player-window { 
    width: 70%; 
    min-height: 420px;
    background-color: rgba(255, 255, 255, 0.6); 
    backdrop-filter: blur(20px); 
    -webkit-backdrop-filter: blur(20px); 
    border-radius: 25px; 
    box-shadow: 0 8px 32px 0 rgba(25, 25, 25, 0.37); 
    border: 1px solid rgba(255, 255, 255, 0.18); 
    padding: 25px; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    color: #1f1f1f; 
    position: relative;
    justify-content: space-between;
    padding-bottom: 15px;
}

.music-player-top-actions {
    position: absolute;
    top: 15px;
    left: 15px;
    right: 15px;
    width: calc(100% - 30px);
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.top-left-cluster {
    display: flex;
    align-items: center;
    gap: 15px;
}
#music-return-btn, #music-exit-btn {
    background: none;
    border: none;
    font-size: 28px;
    font-weight: 300;
    cursor: pointer;
    color: #555;
    padding: 5px;
    line-height: 1;
}
#music-exit-btn {
    font-size: 24px;
    font-weight: 400;
}

.music-progress-bar-container {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 25px;
    margin-bottom: 10px;
}
.time-display {
    font-size: 11px;
    color: #888;
    width: 35px;
    text-align: center;
    flex-shrink: 0;
    font-family: 'SF Mono', 'Menlo', monospace;
}
.progress-bar {
    flex-grow: 1;
    height: 5px;
    background-color: #e5e5e5;
    border-radius: 2.5px;
    cursor: pointer;
}
.progress-bar-fill {
    width: 0%;
    height: 100%;
    background-color: #333;
    border-radius: 2.5px;
}

#music-lyrics-container {
    width: 100%;
    height: 192px;
    overflow: hidden;
    position: relative;
    -webkit-mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
    mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
}

#music-lyrics-list {
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: transform 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
}

.lyric-line {
    padding: 4px 0;
    font-size: 14px;
    color: #666;
    text-align: center;
    line-height: 1.5;
    transition: all 0.5s ease;
    opacity: 0.7;
    transform: scale(0.95);
}

.lyric-line.active {
    font-size: 16px;
    color: #000;
    opacity: 1;
    transform: scale(1);
}

.music-player-controls-wrapper {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.music-controls {
    margin-top: 0;
}

#music-return-btn, #music-exit-btn, #music-playlist-btn {
    position: relative;
}

#music-return-btn { top: -2px; }
#music-playlist-btn { top: -3px; }

.playlist-item-actions {
    display: flex;
    align-items: center;
    gap: 15px;
}
.playlist-action-btn {
    font-size: 18px;
    color: #888;
    cursor: pointer;
    transition: color 0.2s;
}
.playlist-action-btn:hover { color: #000; }
.delete-track-btn { font-size: 24px; color: #AB4D3F; }
.delete-track-btn:hover { color: #c00; }
.lyrics-btn { font-weight: 500; }

/* --- 【核心修正】确保头像尺寸 --- */
.message-bubble .avatar {
    width: 34px;
    height: 34px;
    border-radius: 20%;
    object-fit: cover;
    flex-shrink: 0; /* 防止被压缩 */
}

/* ▼▼▼ 【全新】撤回消息样式 ▼▼▼ */

/* 1. 撤回消息的占位符样式 */
.recalled-message-placeholder {
    align-self: center; /* 居中显示 */
    padding: 4px 12px;
    margin: 5px 0;
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    border-radius: 10px;
    text-align: center;
    max-width: 80%;
    cursor: pointer; /* 让它看起来可以点击 */
}

/* 2. 夜间模式下的适配 */
#phone-screen.dark-mode .recalled-message-placeholder {
    background-color: rgba(255, 255, 255, 0.15);
}

/* 3. AI撤回消息时的动画效果 */
@keyframes recall-animation {
  from {
    opacity: 1;
    transform: scale(1);
  }
  to {
    opacity: 0;
    transform: scale(0.8);
  }
}

.message-wrapper.recalled-animation {
  animation: recall-animation 0.3s ease-out forwards;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】撤回消息样式修正 ▼▼▼ */

/* 强制撤回消息的占位符不换行，并保持内容居中 */
.recalled-message-placeholder {
    white-space: nowrap; /* 核心：禁止文本换行 */
    display: inline-block; /* 让背景根据内容自适应宽度 */
    padding: 4px 12px;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】世界书分类列表样式 ▼▼▼ */
.world-book-group-container {
    margin-bottom: 24px;
}
.world-book-group-container:first-child {
    margin-top: 0;
}
.world-book-group-container:last-child {
    margin-bottom: 0;
}
.world-book-group-header {
    display: flex;
    align-items: center;
    cursor: pointer;
    background: transparent !important;
    margin: 0;
}
.world-book-group-header .arrow {
    font-size: 14px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}
.world-book-group-header.collapsed .arrow {
    transform: rotate(-90deg);
}
.world-book-group-header .group-name {
    font-weight: 600;
    font-size: 15px;
}
.world-book-group-content {
    max-height: 50000px; /* 一个足够大的值 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}
.world-book-group-content.collapsed {
    max-height: 0;
}
#phone-screen.dark-mode .world-book-group-header {
    background-color: #1c1c1e;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】红包/转账模态框页签样式 ▼▼▼ */
.frame-tabs {
    display: flex;
    background-color: #f0f0f0;
    padding: 4px;
    margin: 15px;
    border-radius: 8px;
}
.frame-tab {
    flex: 1;
    text-align: center;
    padding: 8px;
    font-size: 14px;
    font-weight: 500;
    color: #555;
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.2s ease-in-out;
}
.frame-tab.active {
    background-color: #ffffff;
    color: #000000;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段全新的CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* 1. 分类文件夹的样式 */
.wb-category-header {
    display: flex;
    align-items: center;
    padding: 10px 12px;
    cursor: pointer;
    background-color: #ffffff; /* 纯白色背景 */
    font-weight: 600; /* 加粗字体 */
}
#phone-screen.dark-mode .wb-category-header {
    background-color: #2c2c2e; /* 夜间模式下的背景色 */
}


/* 2. 展开/收起的小箭头 */
.wb-category-header .arrow {
    font-size: 12px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}

/* 3. 当文件夹收起时，箭头旋转 */
.wb-category-header.collapsed .arrow {
    transform: rotate(-90deg);
}

/* 4. 存放书籍条目的容器 */
.wb-book-container {
    padding-left: 0px; /* 修改：去掉左侧缩进，消除空白 */
    max-height: 1000px; /* 一个足够大的值，用于动画 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}

/* 5. 当文件夹收起时，书籍容器的高度变为0，实现动画效果 */
.wb-book-container.collapsed {
    max-height: 0;
}

/* 6. 单个书籍条目（覆盖默认的label样式，微调间距） */
.wb-book-container label {
    display: flex !important; /* 修复：改用flexbox布局确保元素在同一行 */
    align-items: center !important;
    gap: 0px !important; /* 修改：去掉gap，因为不再有勾选框 */
    padding: 8px 12px !important;
    cursor: pointer;
    width: 100%;
    box-sizing: border-box;
    flex-wrap: nowrap !important; /* 核心：强制不换行 */
    background-color: #ffffff; /* 默认白色背景 */
    transition: background-color 0.2s ease; /* 添加背景色过渡动画 */
    margin: 0 !important; /* 去掉外边距 */
}

/* 书籍名称不换行 */
.wb-book-container label span {
    white-space: nowrap !important;
    overflow: hidden !important; /* 确保溢出隐藏 */
    text-overflow: ellipsis !important; /* 确保溢出显示省略号 */
    flex: 1 1 auto; /* 修复：在flex布局中占据剩余空间并可以缩放 */
    min-width: 0; /* 关键：允许元素在flex布局中被压缩 */
    line-height: normal !important;
    margin: 0 !important;
    padding: 0 !important;
    font-weight: normal;
    color: var(--text-primary);
    font-size: 15px;
}

/* 勾选后的背景色样式 */
.wb-book-container label.checked {
    background-color: #F7F7F7 !important;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】世界书关联选择器 - 视觉优化 ▼▼▼ */

/* 1. 让分类标题更突出 */
.wb-category-header > span:last-of-type {
    font-size: 14px;
    font-weight: 700; /* 加粗 */
    color: var(--text-primary);
}

/* 彩色箭头已移除，统一使用黑色箭头 */

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */


/* --- 请将这段全新的CSS粘贴到<style>标签末尾，并删除上次为时间戳添加的旧CSS --- */

/* 1. 将时间戳通过“绝对定位”固定在右上角 */
.chat-list-item .time {
    position: absolute;
    top: 12px;  /* 与顶部的距离，使其和名字差不多高 */
    right: 15px; /* 与右侧的距离，和列表的边距一致 */
    font-size: 12px;
    color: var(--text-secondary);
}

/* 2. 给中间的信息区域增加右边距，防止名字或消息过长时，与时间戳重叠 */
.chat-list-item .info {
    padding-right: 50px;
}

/* 3. 确保名字过长时能显示省略号 */
.chat-list-item .name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* ▼▼▼ 在这里粘贴日记和心声的CSS样式 ▼▼▼ */

/* === 日记卡片样式 === */

/* ▼▼▼ 左滑置顶功能样式 ▼▼▼ */
.chat-list-item {
    overflow: hidden;
}

.chat-list-item .swipe-actions {
    position: absolute;
    top: 0;
    right: -80px;
    width: 80px;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: transparent;
    transition: right 0.3s ease;
    z-index: 5;
}

.chat-list-item.swiped .swipe-actions {
    right: 0;
}

.pin-btn {
    background-color: #1E1E1E;
    color: white;
    border: none;
    border-radius: 6px;
    padding: 10px 12px;
    font-size: 13px;
    width: 78px;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.2s ease;
}

.pin-btn:hover {
    background-color: #2a2a2a;
}

.pin-btn:active {
    transform: scale(0.95);
}

/* 暗色模式适配 */
#phone-screen.dark-mode .chat-list-item .swipe-actions {
    background-color: transparent;
}

#phone-screen.dark-mode .pin-btn {
    background-color: #1E1E1E;
    color: #ffffff;
}

#phone-screen.dark-mode .pin-btn:hover {
    background-color: #2a2a2a;
}

/* 置顶聊天样式 */
.chat-list-item.pinned {
    background-color: #F7F7F7;
}

.chat-list-item.pinned:hover {
    background-color: #f0f0f0;
}

.chat-list-item.pinned .swipe-actions {
    background-color: transparent;
}

#phone-screen.dark-mode .chat-list-item.pinned {
    background-color: #2c2c2e;
}

#phone-screen.dark-mode .chat-list-item.pinned:hover {
    background-color: #2c2c2e;
}

#phone-screen.dark-mode .chat-list-item.pinned .swipe-actions {
    background-color: transparent;
}

/* ▼▼▼ 在这里粘贴新按钮的CSS ▼▼▼ */
.diary-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    border-left: none; /* 去掉左侧边框 */
}
#phone-screen.dark-mode .diary-card {
    background-color: #1c1c1e;
    border-left-color: #E6A753;
}

.diary-card .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 13px;
    color: var(--text-secondary);
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
}
.diary-card .card-header .actions button {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-secondary);
    padding: 5px;
}

.diary-card .card-body {
    font-size: 14px;
    line-height: 1.7;
    color: var(--text-primary);
    white-space: pre-wrap;
}

/* ▼▼▼ 在这里粘贴新代码 ▼▼▼ */
/* === 日记页面背景色 === */
#diary-screen, #diary-list {
    background-color: #ffffff;
}
#phone-screen.dark-mode #diary-screen,
#phone-screen.dark-mode #diary-list {
    background-color: #1c1c1e; /* 夜间模式用深灰色背景 */
}
/* ▲▲▲ 粘贴结束 ▲▲▲ */

/* ▲▲▲ CSS样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的末尾 ▼▼▼ */

/* === 【全新】群聊心声弹窗样式 === */
#group-status-list {
    display: flex;
    flex-direction: column;
    gap: 18px; /* 每个成员之间的间距 */
}

.group-status-item {
    display: flex;
    align-items: flex-start; /* 头像和文字顶部对齐 */
    gap: 12px;
    padding-bottom: 18px;
    border-bottom: 1px solid var(--border-color);
}
#group-status-list .group-status-item:last-child {
    border-bottom: none; /* 最后一个不显示下边框 */
}
#phone-screen.dark-mode .group-status-item {
    border-bottom-color: #38383a;
}

.group-status-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0; /* 防止头像被压缩 */
}

.group-status-item .content-wrapper {
    display: flex;
    flex-direction: column;
}

.group-status-item .name {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-primary);
    margin-bottom: 5px;
}

.group-status-item .thought {
    font-size: 14px;
    line-height: 1.6;
    color: var(--text-secondary);
    white-space: pre-wrap; /* 保留换行符 */
    margin: 0; /* 移除 p 标签的默认边距 */
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】论坛功能样式 ▼▼▼ */

#forum-screen {
    background-color: #F7F7F7;
}
#phone-screen.dark-mode #forum-screen {
    background-color: #000000;
}

#forum-posts-container {
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.forum-placeholder {
    text-align: center;
    color: var(--text-secondary);
    padding: 80px 20px;
    font-size: 15px;
    line-height: 1.8;
}

.forum-post-item {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
}
#phone-screen.dark-mode .forum-post-item {
    background-color: #1c1c1e;
    border: 1px solid #333;
}

.forum-post-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}
.forum-post-header .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
}
.forum-post-header .name {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-primary);
}

.forum-post-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap;
    word-break: break-word;
    margin-bottom: 15px;
}
#phone-screen.dark-mode .forum-post-content {
    color: #f0f0f0;
}

.forum-post-footer {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 15px;
    font-size: 13px;
    color: var(--text-secondary);
    padding-top: 10px;
    border-top: 1px solid var(--border-color);
}
#phone-screen.dark-mode .forum-post-footer {
    border-top-color: #38383a;
}
.footer-action {
    display: flex;
    align-items: center;
    gap: 5px;
    cursor: pointer;
}
.footer-action svg {
    width: 18px;
    height: 18px;
}
.footer-action.liked {
    color: #ff5252;
}
.footer-action.liked svg {
    fill: #ff5252;
}
.footer-action.forward-btn {
    align-items: center;
}
.footer-action.forward-btn svg {
    width: 22px;
    height: 22px;
    margin-top: -3px;
}

.forum-comments-section {
    margin-top: 15px;
    background-color: #f9f9f9;
    border-radius: 8px;
    padding: 10px;
}
#phone-screen.dark-mode .forum-comments-section {
    background-color: #2c2c2e;
}

.forum-comment-item {
    font-size: 13px;
    line-height: 1.5;
    padding: 8px 0;
    border-bottom: 1px solid #e9e9e9;
}
#phone-screen.dark-mode .forum-comment-item {
    border-bottom-color: #38383a;
}
.forum-comment-item:last-child {
    border-bottom: none;
}
.forum-comment-item .commenter-name {
    font-weight: 600;
    color: var(--accent-color);
    margin-right: 5px;
}
.forum-comment-item .comment-text {
    color: var(--text-primary);
}

.forum-comment-input-area {
    display: flex;
    gap: 8px;
    margin-top: 12px;
}
.forum-comment-input-area input {
    flex-grow: 1;
    border: 1px solid var(--border-color);
    border-radius: 15px;
    padding: 8px 12px;
    font-size: 13px;
    background-color: var(--secondary-bg);
}
#phone-screen.dark-mode .forum-comment-input-area input {
    background-color: #3a3a3c;
    border-color: #545458;
    color: #ffffff;
}
.forum-comment-input-area button {
    border: none;
    background-color: var(--accent-color);
    color: white;
    border-radius: 15px;
    padding: 0 15px;
    font-size: 13px;
    cursor: pointer;
}

#forum-character-selector .forum-char-item {
    display: flex;
    align-items: center;
    padding: 8px;
    cursor: pointer;
    gap: 15px;
    margin: 4px 0;
    border-radius: 12px;
    transition: background-color 0.2s ease;
}
#forum-character-selector .forum-char-item:hover {
    background-color: #f0f0f0;
}
#forum-character-selector .forum-char-item.selected {
    background-color: #6B6B6B;
    margin: 4px 0;
}
#forum-character-selector .forum-char-item.selected:hover {
    background-color: #5A5A5A;
}
#forum-character-selector .forum-char-item.selected .forum-char-name {
    color: white;
}
.forum-char-avatar {
    width: 35px;
    height: 35px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}
.forum-char-name {
    font-size: 14px;
    line-height: 1.4;
}
#forum-worldbook-selector .forum-wb-item {
    display: flex;
    align-items: center;
    padding: 8px;
    cursor: pointer;
    margin: 4px 0;
    border-radius: 12px;
    transition: background-color 0.2s ease;
}
#forum-worldbook-selector .forum-wb-item:hover {
    background-color: #f0f0f0;
}
#forum-worldbook-selector .forum-wb-item.selected {
    background-color: #6B6B6B;
    margin: 4px 0;
}
#forum-worldbook-selector .forum-wb-item.selected:hover {
    background-color: #5A5A5A;
}
#forum-worldbook-selector .forum-wb-item.selected .forum-wb-name {
    color: white;
}
.forum-wb-name {
    font-size: 14px;
    line-height: 1.4;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】论坛AI回复等待动画 ▼▼▼ */
.ai-reply-loader {
    font-size: 13px;
    color: var(--text-secondary);
    padding: 10px 0;
    text-align: left;
    margin-left: 10px; /* 让它和评论稍微对齐 */
}
.ai-reply-loader span {
    animation: blink 1.4s infinite both;
}
.ai-reply-loader span:nth-child(2) {
    animation-delay: 0.2s;
}
.ai-reply-loader span:nth-child(3) {
    animation-delay: 0.4s;
}
@keyframes blink {
    0%, 80%, 100% { opacity: 0; }
    40% { opacity: 1; }
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【强力修正】限制动态、论坛和聊天内容里的图片最大宽度 ▼▼▼ */
.qzone-post-item .chat-image,
.forum-post-item .chat-image,
#chat-messages .message-bubble .chat-image { /* <-- 就是新增了这一行 */
    max-width: 200px !important; /* 你可以随意调整这个数值 */
    width: auto !important;      /* 确保宽度自适应 */
    height: auto !important;     /* 保持图片原始的宽高比 */
}
/* ▲▲▲ 修正结束 ▲▲▲ */

/* ▼▼▼ 请将这【一整块】全新的CSS，粘贴到 <style> 标签的末尾 ▼▼▼ */

/* === 【核心】修正主输入行布局 === */
#chat-input-main-row {
    align-items: flex-end; /* 保持所有元素底部对齐 */
}

#chat-input-main-row .chat-action-icon-btn {
    width: 40px;  /* 统一左右按钮大小 */
    height: 40px;
    flex-shrink: 0; /* 防止按钮被压缩 */
}

/* === 【核心】移除旧的顶部按钮栏 === */
#chat-input-actions-top {
    display: none !important; /* 强制隐藏，不再需要 */
}

/* ▼▼▼ 请用这段【新代码】替换旧的 #chat-plus-panel 和 #plus-panel-grid 样式 ▼▼▼ */

/* === 【全新】加号功能面板样式 (已修改为类选择器) === */
.chat-plus-panel {
    max-height: 0; /* 默认收起 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out;
    padding: 0 15px; /* 收起时没有上下内边距 */
    box-sizing: border-box;
    display: none; /* 【核心修改】默认不显示，由JS控制 */
    position: relative; /* 确保定位正确 */
    z-index: 1; /* 确保在合适的层级 */
}
.chat-plus-panel.visible {
    display: block; /* 【核心修改】激活时设为block，让动画生效 */
    max-height: 300px; /* 展开时给一个足够大的高度 */
    padding: 20px 15px; /* 展开时增加上下内边距 */
}

/* 当面板展开时，聊天消息区域的调整 */
#chat-interface-screen.panel-expanded #chat-messages {
    /* 核心修改：让聊天记录底部“弹起”的高度，大致等于功能面板的高度 */
    /* 这个值可以根据你的面板实际高度微调，240px 是一个比较好的初始值 */
    padding-bottom: 240px; 
}

/* === 【全新】功能面板内网格布局 (已修改为类选择器) === */
.plus-panel-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr); /* 每行4个 */
    gap: 25px 15px; /* 上下间距25px，左右间距15px */
    justify-items: center; /* 水平居中 */
}

/* ▲▲▲ 替换结束 ▲▲▲ */

/* === 【全新】网格内单个功能项样式 === */
.plus-panel-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px; /* 图标和文字的间距 */
}

.plus-panel-icon-bg {
    width: 58px;
    height: 58px;
    background-color: #FFFFFF;
    border-radius: 12px;
    border: 1px solid rgba(0,0,0,0.05);
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: background-color 0.2s;
    color: var(--text-primary);
}
.plus-panel-icon-bg:active {
    background-color: #f0f0f0;
}
.plus-panel-icon-bg svg {
    width: 28px;
    height: 28px;
    stroke: var(--text-primary); /* 让SVG颜色跟随主题 */
}
.plus-panel-icon-bg {
    font-size: 24px; /* 为“转账”按钮的“￥”设置大小 */
}

.plus-panel-label {
    font-size: 12px;
    color: var(--text-secondary);
}

/* 滑动容器样式 */
.plus-panel-container {
    overflow: hidden;
    width: 100%;
}

.plus-panel-pages {
    display: flex;
    width: 200%;
    transition: transform 0.3s ease;
}

.plus-panel-page {
    width: 50%;
    flex-shrink: 0;
}

.plus-panel-page:not(.active) {
    pointer-events: none; /* 禁用非活动页面的交互 */
}

/* 第二页的空页面样式 */
.empty-page {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 120px;
}

.empty-placeholder {
    color: #999;
    font-size: 14px;
    text-align: center;
}

/* 分页指示器样式 */
.plus-panel-pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    margin-top: 15px;
    padding-bottom: 10px;
}

.pagination-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background-color: #D0D0D0; /* 浅灰色 - 未选择状态 */
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.pagination-dot.active {
    background-color: #808080; /* 深灰色 - 当前页面状态 */
}

/* ▼▼▼ 请用这段【新代码】替换旧的 “发送按钮与加号按钮的切换逻辑” 样式 ▼▼▼ */

/* === 【全新】右侧常驻按钮显示样式 === */
#open-sticker-panel-btn,
#chat-plus-btn,
#wait-reply-btn {
    display: flex; /* 确保这些图标按钮总是可见并居中 */
}
#send-btn {
    display: block; /* 确保发送按钮总是可见 */
}

/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▼▼▼ 请将这段新样式添加到 <style> 标签内 ▼▼▼ */

/* 强制隐藏“发送”按钮，但保留其功能，让回车键可以继续使用 */
#send-btn {
    display: none !important;
}

/* ▲▲▲ 新样式添加结束 ▲▲▲ */

/* ▼▼▼ 请将这段【新代码】粘贴到 <style> 的末尾 ▼▼▼ */

/* 【最终强力修正版】强制统一聊天界面右上角所有操作按钮和内部图标的尺寸与对齐 */
.header .header-actions .action-btn {
    width: 35px !important;      /* 强制宽度 */
    
    padding: 0 !important;       /* 移除内边距对尺寸的影响 */
    box-sizing: border-box !important; /* 统一盒子模型计算方式 */
}

.header .header-actions .action-btn svg,
.header .header-actions .action-btn img {
    width: 24px !important;      /* 强制图标宽度 */
    height: 24px !important;     /* 强制图标高度 */
    vertical-align: middle !important; /* 【关键】强制所有图标垂直居中对齐 */
}

/* ▲▲▲ 新代码粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段【新代码】粘贴到 <style> 的末尾 ▼▼▼ */

/* === 【全新】气泡预设功能区样式 === */
#bubble-presets-list {
    display: flex;
    flex-direction: column;
    gap: 8px; /* 预设条目之间的间距 */
    max-height: 120px; /* 给一个最大高度，超出则滚动 */
    overflow-y: auto;
}

.bubble-preset-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background-color: var(--secondary-bg);
    border-radius: 6px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

.bubble-preset-item .preset-name {
    font-weight: 500;
    color: var(--text-primary);
}

/* === 【全新修正】气泡预设 - 图标按钮样式 === */

/* 1. 【核心修复】让按钮容器（preset-actions）横向排列内部的按钮 */
.bubble-preset-item .preset-actions {
    display: flex;
    align-items: center;
    gap: 8px; /* 使用 gap 来设置按钮之间的间距，比 margin 更现代 */
}

/* 2. 统一设置两个按钮的圆形基础样式 (移除了 margin-left) */
.bubble-preset-item .preset-actions button {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: #1E1E1E;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s ease, opacity 0.2s ease;
    font-size: 0;
    color: transparent;
    padding: 0;
    background-repeat: no-repeat;
    background-position: center;
    background-size: 60%;
}

/* 3. 鼠标悬浮时给一点反馈 (不变) */
.bubble-preset-item .preset-actions button:hover {
    opacity: 0.8;
    transform: scale(1.1);
}

/* 4. 为“应用”按钮设置“对勾”SVG图标 (不变) */
.bubble-preset-item .preset-actions .apply-btn {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z'/%3E%3C/svg%3E");
}

/* 5. 为“删除”按钮设置“X”SVG图标 (不变) */
.bubble-preset-item .preset-actions .delete-btn {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z'/%3E%3C/svg%3E");
}
/* ▼▼▼ 在这里粘贴新代码 ▼▼▼ */
/* 6. 【全新】为“编辑”按钮设置“铅笔”SVG图标 */
.bubble-preset-item .preset-actions .edit-btn {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z'/%3E%3C/svg%3E");
}
/* ▲▲▲ 新代码粘贴结束 ▲▲▲ */
.preset-placeholder {
    text-align: center;
    color: var(--text-secondary);
    font-size: 14px;
    margin: 10px 0;
}

/* ▲▲▲ 新代码粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】约定绑定角色功能样式 ▼▼▼ */

/* 1. 绑定按钮的样式 */
.bind-char-btn {
    position: absolute;
    top: 15px;
    right: 15px;
    width: 32px;
    height: 32px;
    background-color: #FFFFFF;
    border: 1px solid #EAEAEA;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    box-shadow: 0 2px 6px rgba(0,0,0,0.08);
}
.bind-char-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 4px 10px rgba(0,0,0,0.12);
}
.bind-char-btn svg {
    width: 18px;
    height: 18px;
    fill: #1E1E1E;
}

/* 2. 绑定模态框的网格布局 */
#bind-character-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 20px;
    padding: 10px;
}

/* 3. 单个角色选项的样式 */
.bind-char-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    padding: 10px;
    border-radius: 12px;
    cursor: pointer;
    transition: background-color 0.2s;
}
.bind-char-item .avatar {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    object-fit: cover;
}
.bind-char-item .name {
    font-size: 12px;
    color: var(--text-primary);
    text-align: center;
}

/* 4. 角色被选中时的样式 */
.bind-char-item.selected {
    background-color: #F7F7F7;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ========== 【晴空】API设置页面美化方案开始 ========== */

/* 1. 应用晴空色彩方案到API设置页面 */
#api-settings-screen {
    background-color: #F7F7F7 !important; /* 主背景色 - 带有极微灰度的柔和白 */
}

#api-settings-screen .form-container {
    background-color: #F7F7F7 !important; /* 确保内容背景统一 */
}

/* 2. 输入框美化格式 - 晴空方案 */
#api-settings-screen .form-group input,
#api-settings-screen .form-group textarea,
#wallpaper-screen .form-group input,
#wallpaper-screen .form-group textarea{
    background-color: #FFFFFF !important; /* 纯白背景 */
    color: #1E1E1E !important; /* 炭黑色文字 */
    border: 1px solid #DCDCDC !important; /* 浅灰色边框 */
    border-radius: 8px !important; /* 小圆角 */
    padding: 12px 16px !important; /* 内边距 */
    font-size: 16px !important;
    transition: all 0.2s ease-in-out !important;
    box-sizing: border-box !important;
    width: 100% !important; /* 确保宽度正常 */
    display: block !important; /* 确保正常显示 */
    position: relative !important; /* 恢复正常定位 */
    z-index: auto !important; /* 恢复正常层级 */
}

#api-settings-screen .form-group input::placeholder,
#api-settings-screen .form-group textarea::placeholder {
    color: #A0A0A0 !important; /* 占位符文字 */
}

#api-settings-screen .form-group input:focus,
#api-settings-screen .form-group textarea:focus {
    outline: none !important;
    border-color: #1E1E1E !important; /* 焦点时边框变为炭黑色 */
    box-shadow: 0 0 0 3px rgba(30, 30, 30, 0.1) !important; /* 柔和外发光 */
}

/* 3. 下拉框样式 - 晴空方案 */
#api-settings-screen .form-group select {
    background-color: #FFFFFF !important;
    color: #1E1E1E !important;
    border: 1px solid #DCDCDC !important;
    border-radius: 8px !important;
    padding: 12px 16px !important;
    font-size: 16px !important;
    transition: all 0.2s ease-in-out !important;
    box-sizing: border-box !important;
    width: 100% !important; /* 确保宽度正常 */
    display: block !important; /* 确保正常显示 */
    position: relative !important; /* 恢复正常定位 */
    z-index: auto !important; /* 恢复正常层级 */
    appearance: none !important;
    -webkit-appearance: none !important;
    -moz-appearance: none !important;
    background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 4 5"><path fill="%236B6B6B" d="M2 0L0 2h4zm0 5L0 3h4z"/></svg>') !important;
    background-repeat: no-repeat !important;
    background-position: right 16px center !important;
    background-size: 12px !important;
    cursor: pointer !important;
}

#api-settings-screen .form-group select:focus {
    outline: none !important;
    border-color: #1E1E1E !important;
    box-shadow: 0 0 0 3px rgba(30, 30, 30, 0.1) !important;
}

/* 4. 表单分组毛玻璃气泡容器样式 */
#api-settings-screen .form-group,
#wallpaper-screen .form-group {
    background: rgba(255, 255, 255, 0.7) !important; /* 半透明白色背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important; /* 中等圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和悬浮阴影 */
    padding: 20px !important; /* 内边距 */
    margin-bottom: 20px !important;
    min-height: auto !important; /* 高度自适应 */
    height: auto !important; /* 高度自适应 */
    overflow: visible !important; /* 允许内容完全显示 */
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
}

#api-settings-screen .form-group:hover {
    transform: translateY(-2px) !important; /* 悬浮时微微上浮，去掉缩放避免影响布局 */
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.12) !important;
}

/* 5. 标签样式优化 */
#api-settings-screen .form-group label,
#wallpaper-screen .form-group label {
    color: #1E1E1E !important; /* 一级文本色 */
    font-weight: 500 !important;
    margin-bottom: 8px !important;
    display: block !important;
    position: relative !important; /* 确保正常定位 */
    z-index: 1 !important; /* 确保文字在上层显示 */
    line-height: 1.4 !important; /* 增加行高确保文字完整显示 */
}

/* 6. 按钮美化 */
#api-settings-screen .form-button {
    background-color: #1E1E1E !important; /* 炭黑色背景 */
    color: #FFFFFF !important; /* 白色文字 */
    border: none !important;
    border-radius: 8px !important;
    padding: 12px 20px !important;
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
}

#api-settings-screen .form-button:hover {
    background-color: #000000 !important; /* 悬浮时变为纯黑 */
    transform: translateY(-2px) !important; /* 悬浮效果 */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
}

/* 7. 特殊按钮样式 - 让保存预设按钮与拉取模型按钮一致 */
#api-settings-screen #save-api-preset-btn {
    background-color: #1E1E1E !important; /* 与拉取模型按钮保持一致的深色背景 */
    color: #FFFFFF !important;
    border: none !important;
    border-radius: 12px !important;
    padding: 12px 20px !important;
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    margin-bottom: 10px !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
}

#api-settings-screen #save-api-preset-btn:hover {
    background-color: #000000 !important; /* 悬浮时变为纯黑 */
    transform: translateY(-2px) !important; /* 悬浮效果 */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
}

/* 8. 开关按钮美化 */
#api-settings-screen input[type="checkbox"] {
    appearance: none !important;
    -webkit-appearance: none !important;
    -moz-appearance: none !important;
    width: 44px !important;
    height: 24px !important;
    background-color: #DCDCDC !important; /* 关闭状态轨道颜色 */
    border-radius: 24px !important;
    position: relative !important;
    cursor: pointer !important;
    transition: background-color 0.2s ease-in-out !important;
    margin: 0 !important;
}

#api-settings-screen input[type="checkbox"]:before {
    content: '' !important;
    position: absolute !important;
    width: 20px !important;
    height: 20px !important;
    border-radius: 50% !important;
    top: 2px !important;
    left: 2px !important;
    background-color: #FFFFFF !important; /* 滑块颜色 */
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2) !important; /* 微妙立体感 */
    transition: transform 0.2s ease-in-out !important;
}

#api-settings-screen input[type="checkbox"]:checked {
    background-color: #1E1E1E !important; /* 开启状态轨道颜色 */
}

#api-settings-screen input[type="checkbox"]:checked:before {
    transform: translateX(20px) !important; /* 滑块移动 */
}

/* 9. 数字输入框特殊样式 */
#api-settings-screen input[type="number"] {
    text-align: center !important;
    width: 80px !important; /* 固定较小宽度 */
    min-width: 80px !important;
    max-width: 80px !important;
    flex-shrink: 0 !important; /* 防止被压缩 */
    margin-left: auto !important; /* 推到右边 */
}

/* 移除数字输入框的上下调节箭头 */
#api-settings-screen input[type="number"]::-webkit-outer-spin-button,
#api-settings-screen input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none !important;
    margin: 0 !important;
}

#api-settings-screen input[type="number"] {
    -moz-appearance: textfield !important; /* Firefox */
}

/* 为包含数字输入框的表单组优化布局 */
#api-settings-screen .form-group[style*="display: flex"] {
    align-items: flex-start !important; /* 顶部对齐 */
    gap: 15px !important; /* 增加间距 */
}

#api-settings-screen .form-group[style*="display: flex"] label {
    flex: 1 !important; /* 标签占据剩余空间 */
    margin-bottom: 0 !important; /* 移除底部间距 */
}

/* 10. 分割线美化 */
#api-settings-screen hr {
    border: none !important;
    height: 1px !important;
    background-color: rgba(0, 0, 0, 0.1) !important; /* 半透明边框色 */
    margin: 20px 0 !important;
}

/* 11. 提示信息美化 */
#api-settings-screen p,
#wallpaper-screen p {
    color: #6B6B6B !important; /* 二级文本色 */
    font-size: 14px !important;
    line-height: 1.5 !important; /* 增加行高 */
    margin: 5px 0 !important; /* 适当的上下间距 */
    position: relative !important; /* 确保正常定位 */
    z-index: 1 !important; /* 确保文字显示在上层 */
}

/* 12. 代码标签美化 */
#api-settings-screen code {
    background-color: rgba(0, 0, 0, 0.05) !important; /* 极淡的半透明黑色 */
    color: #1E1E1E !important;
    padding: 2px 6px !important;
    border-radius: 4px !important;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace !important;
    display: inline !important; /* 确保正常显示 */
}

/* 13. API预设列表容器美化 */
#api-settings-screen #api-presets-list {
    margin-top: 10px !important;
    position: relative !important;
    z-index: 1 !important;
}

/* 14. 警告文字样式 */
#api-settings-screen p[style*="color: #ff6b6b"] {
    color: #ff6b6b !important;
    font-size: 12px !important;
    line-height: 1.4 !important;
    margin-top: 5px !important;
}

/* 15. 辅助说明文字样式 */
#api-settings-screen p[style*="color: #999"] {
    color: #6B6B6B !important;
    font-size: 12px !important;
    line-height: 1.4 !important;
    margin-top: 5px !important;
}

/* 16. 确保所有文本内容正常显示 */
#api-settings-screen .form-group * {
    position: relative !important;
    z-index: 1 !important;
}

/* ========== 【晴空】API设置页面美化方案结束 ========== */

/* ========== 外观设置页面优化开始 ========== */

/* 1. 调整上传壁纸按钮和夜间模式开关的距离 */
#wallpaper-screen .form-group[style*="display: flex"] {
    margin-top: 30px !important; /* 增加与上方元素的距离 */
    margin-bottom: 20px !important;
}

/* 2. 夜间模式开关按钮样式 - 完整的开关样式 */
#wallpaper-screen .toggle-switch {
    position: relative !important;
    display: inline-block !important;
    width: 44px !important;  /* 宽度 */
    height: 24px !important; /* 高度 */
}

/* 隐藏原生的checkbox */
#wallpaper-screen .toggle-switch input {
    opacity: 0 !important;
    width: 0 !important;
    height: 0 !important;
}

/* 轨道样式 */
#wallpaper-screen .toggle-switch .slider {
    position: absolute !important;
    cursor: pointer !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    background-color: #DCDCDC !important; /* 关闭状态的轨道颜色 */
    border-radius: 24px !important; /* 使其变为圆角矩形 */
    transition: background-color 0.2s ease-in-out !important;
}

/* 滑块样式 (使用::before伪元素创建) */
#wallpaper-screen .toggle-switch .slider::before {
    position: absolute !important;
    content: "" !important;
    height: 20px !important; /* 滑块直径 */
    width: 20px !important;  /* 滑块直径 */
    left: 2px !important;    /* 初始位置 */
    bottom: 2px !important;  /* 初始位置 */
    background-color: #FFFFFF !important; /* 滑块颜色 */
    border-radius: 50% !important; /* 使其变为圆形 */
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2) !important; /* 微妙的立体感阴影 */
    transition: transform 0.2s ease-in-out !important;
}

/* --- 核心交互逻辑 --- */
/* 当checkbox被选中时，改变轨道的背景色 */
#wallpaper-screen .toggle-switch input:checked + .slider {
    background-color: #1E1E1E !important; /* 开启状态的轨道颜色 */
}

/* 当checkbox被选中时，移动滑块 */
#wallpaper-screen .toggle-switch input:checked + .slider::before {
    transform: translateX(20px) !important; /* 滑块移动距离 = 轨道宽度 - 滑块宽度 - (左边距*2) */
}

/* 3. 优化夜间模式标签样式 */
#wallpaper-screen .form-group[style*="display: flex"] label[for="theme-toggle-switch"] {
    color: var(--text-primary) !important;
    font-weight: 500 !important;
    flex: 1 !important;
}

/* ========== 外观设置页面优化结束 ========== */

/* ========== 【晴空】转账卡片美化开始 ========== */

/* 1. 转账卡片主体美化 - 毛玻璃气泡效果 */
.transfer-card {
    width: 200px !important;
    background: rgba(255, 255, 255, 0.7) !important; /* 半透明白色背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important; /* 中等圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和悬浮阴影 */
    padding: 20px !important; /* 增加内边距 */
    color: #1E1E1E !important; /* 炭黑色文字 */
    position: relative !important;
    overflow: hidden !important; /* 防溢出处理 */
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
}

/* 2. 悬浮效果 */
.transfer-card:hover {
    transform: translateY(-2px) !important; /* 悬浮时微微上浮 */
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.12) !important;
}

/* 3. 移除原有背景样式 */
.message-bubble.user .transfer-card,
.message-bubble.ai .transfer-card {
    background: rgba(255, 255, 255, 0.7) !important;
}

/* 4. 转账标题样式 */
.transfer-title {
    font-size: 16px !important;
    font-weight: 600 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    display: flex !important;
    align-items: center !important;
    gap: 6px !important;
    margin-bottom: 12px !important;
    text-shadow: none !important;
}

/* 5. 转账金额样式 */
.transfer-amount {
    font-size: 28px !important;
    font-weight: bold !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin-bottom: 8px !important;
    text-shadow: none !important;
}

/* 6. 转账备注样式 */
.transfer-note {
    font-size: 13px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    opacity: 1 !important; /* 重置透明度 */
    border-top: 1px solid rgba(0, 0, 0, 0.1) !important; /* 半透明边框色 */
    padding-top: 8px !important;
    margin-top: 8px !important;
    word-break: break-all !important;
    text-shadow: none !important;
}

/* 7. 移除原有装饰图标 */
.transfer-card::before {
    display: none !important; /* 移除原有的🐾图标 */
}

/* 8. 添加新的装饰元素 - 更简洁的设计 */
.transfer-card::after {
   
    position: absolute !important;
    right: 15px !important;
    top: 15px !important;
    font-size: 20px !important;
    opacity: 0.3 !important;
}

/* 9. 强制覆盖聊天消息中的样式 */
#chat-messages .transfer-card .transfer-title,
#chat-messages .transfer-card .transfer-amount,
#chat-messages .transfer-card .transfer-note {
    text-shadow: none !important;
}

#chat-messages .transfer-card .transfer-title {
    color: #1E1E1E !important;
    font-size: 16px !important;
    font-weight: 600 !important;
}

#chat-messages .transfer-card .transfer-amount {
    color: #1E1E1E !important;
    font-size: 28px !important;
    font-weight: bold !important;
}

#chat-messages .transfer-card .transfer-note {
    color: #6B6B6B !important;
    font-size: 13px !important;
    opacity: 1 !important;
}

/* ========== 【晴空】转账卡片美化结束 ========== */

/* ========== 【晴空】礼物卡片美化开始 ========== */

/* 1. 礼物卡片主体美化 - 毛玻璃气泡效果 */
.gift-card {
    width: 200px !important;
    background: rgba(255, 255, 255, 0.7) !important; /* 白色半透明背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important; /* 中等圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和灰色阴影 */
    padding: 20px !important; /* 增加内边距 */
    color: #1E1E1E !important; /* 炭黑色文字 */
    position: relative !important;
    overflow: hidden !important;
}

/* 2. 悬浮效果 */
.gift-card:hover {
    transform: translateY(-2px) !important; /* 悬浮时微微上浮 */
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.15) !important;
}

/* 3. 消息气泡样式统一 */
.message-bubble.user .gift-card,
.message-bubble.ai .gift-card {
    background: rgba(255, 255, 255, 0.7) !important;
}

/* 4. 礼物标题样式 */
.gift-title {
    font-size: 16px !important;
    font-weight: 600 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    display: flex !important;
    align-items: center !important;
    gap: 6px !important;
    margin-bottom: 12px !important;
}

/* 5. 礼物名称样式 */
.gift-name {
    font-size: 20px !important;
    font-weight: bold !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin-bottom: 8px !important;
    text-align: center !important;
}

/* 6. 礼物价格样式 */
.gift-price {
    font-size: 16px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    text-align: center !important;
    font-weight: 500 !important;
}

/* 7. 强制覆盖聊天消息中的样式 */
#chat-messages .gift-card .gift-title,
#chat-messages .gift-card .gift-name,
#chat-messages .gift-card .gift-price {
    text-shadow: none !important;
}

#chat-messages .gift-card .gift-title {
    color: #1E1E1E !important;
    font-size: 16px !important;
    font-weight: 600 !important;
}

#chat-messages .gift-card .gift-name {
    color: #1E1E1E !important;
    font-size: 20px !important;
    font-weight: bold !important;
}

#chat-messages .gift-card .gift-price {
    color: #6B6B6B !important;
    font-size: 16px !important;
    font-weight: 500 !important;
}

/* 8. 礼物消息气泡背景透明化 */
.message-bubble.is-gift .content { 
    padding: 0 !important; 
    background: transparent !important; 
    box-shadow: none !important; 
    border: none !important; 
    backdrop-filter: none !important; 
    -webkit-backdrop-filter: none !important; 
}

/* 9. 礼物状态文本样式 */
.gift-status {
    text-align: center !important;
    font-size: 14px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    margin-top: 12px !important;
    padding-top: 8px !important;
    border-top: 1px solid rgba(0, 0, 0, 0.1) !important;
}

/* 10. 礼物操作按钮样式 */
.gift-actions {
    display: flex !important;
    gap: 12px !important;
    margin-top: 15px !important;
    padding-top: 12px !important;
    border-top: 1px solid rgba(0, 0, 0, 0.1) !important;
}

.gift-decline-btn, 
.gift-accept-btn {
    flex: 1 !important;
    padding: 10px 16px !important;
    border: 1px solid !important;
    border-radius: 8px !important;
    cursor: pointer !important;
    font-size: 14px !important;
    font-weight: 500 !important;
    transition: all 0.2s ease !important;
    background: none !important;
}

.gift-decline-btn {
    color: #6B6B6B !important;
    border-color: #DCDCDC !important;
}

.gift-decline-btn:hover {
    background-color: #f5f5f5 !important;
    transform: translateY(-1px) !important;
}

.gift-accept-btn {
    color: #1E1E1E !important;
    border-color: #1E1E1E !important;
    background-color: #1E1E1E !important;
    color: white !important;
}

.gift-accept-btn:hover {
    background-color: #000000 !important;
    transform: translateY(-1px) !important;
}

/* ========== 【晴空】礼物卡片美化结束 ========== */

/* ========== 【晴空】转账模态框美化开始 ========== */

/* 1. 转账模态框背景 */
#transfer-modal {
    background-color: rgba(0, 0, 0, 0.3) !important; /* 更柔和的遮罩 */
}

/* 2. 转账内容容器 - 毛玻璃效果 */
.transfer-content {
    background: rgba(255, 255, 255, 0.7) !important; /* 半透明白色背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 20px !important;
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和悬浮阴影 */
    width: 290px !important;
    padding: 30px !important; /* 增加内边距 */
    text-align: center !important;
    background-image: none !important; /* 移除原有背景图 */
}

/* 3. 转账模态框标题 */
.transfer-header {
    font-size: 20px !important;
    font-weight: bold !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin-bottom: 25px !important;
}

/* 4. 转账输入组 */
.transfer-input-group {
    margin-bottom: 20px !important;
    text-align: left !important;
}

.transfer-input-group label {
    display: block !important;
    font-size: 14px !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin-bottom: 8px !important;
    font-weight: 500 !important;
}

.transfer-input-group input {
    width: 100% !important;
    padding: 12px 16px !important;
    border-radius: 8px !important; /* 小圆角 */
    border: 1px solid #DCDCDC !important; /* 浅灰色边框 */
    background-color: #FFFFFF !important; /* 纯白背景 */
    color: #1E1E1E !important; /* 炭黑色文字 */
    font-size: 16px !important;
    box-sizing: border-box !important;
    transition: all 0.2s ease-in-out !important;
}

.transfer-input-group input::placeholder {
    color: #A0A0A0 !important; /* 占位符文字 */
}

.transfer-input-group input:focus {
    border-color: #1E1E1E !important; /* 焦点时边框变为炭黑色 */
    outline: none !important;
    box-shadow: 0 0 0 3px rgba(30, 30, 30, 0.1) !important; /* 柔和外发光 */
}

/* 5. 转账按钮组 */
.transfer-actions {
    display: flex !important;
    justify-content: space-between !important;
    gap: 15px !important;
    margin-top: 25px !important;
}

.transfer-actions button {
    flex: 1 !important;
    padding: 12px 20px !important;
    border: none !important;
    border-radius: 8px !important;
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
}

.transfer-actions button:active {
    transform: scale(0.98) !important;
}

/* 6. 取消按钮样式 */
#transfer-cancel-btn {
    background-color: #f5f5f5 !important;
    color: #6B6B6B !important; /* 二级文本色 */
    border: 1px solid #DCDCDC !important;
}

#transfer-cancel-btn:hover {
    background-color: #eeeeee !important;
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important;
}

/* 7. 确认按钮样式 */
#transfer-confirm-btn {
    background-color: #1E1E1E !important; /* 炭黑色背景 */
    color: #FFFFFF !important; /* 白色文字 */
}

#transfer-confirm-btn:hover {
    background-color: #000000 !important; /* 悬浮时变为纯黑 */
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
}

/* ========== 【晴空】转账模态框美化结束 ========== */

/* ========== 【晴空】外卖卡片美化开始 ========== */

/* 1. AI发送的外卖卡片 - 改为晴空样式 */
.message-bubble.ai .waimai-card {
    width: 240px !important;
    background: rgba(255, 255, 255, 0.7) !important; /* 毛玻璃背景 */
    backdrop-filter: blur(20px) !important;
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important; /* 中等圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important;
    overflow: hidden !important;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif !important;
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
}

.message-bubble.ai .waimai-card:hover {
    transform: translateY(-2px) !important;
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.12) !important;
}

/* 2. 用户发送的外卖卡片 - 毛玻璃气泡效果 */
.message-bubble.user .waimai-card {
    width: 240px !important;
    background: rgba(255, 255, 255, 0.7) !important; /* 半透明白色背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important; /* 中等圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和悬浮阴影 */
    overflow: hidden !important;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif !important;
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
}

.message-bubble.user .waimai-card:hover {
    transform: translateY(-2px) !important; /* 悬浮时微微上浮 */
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.12) !important;
}

/* 3. AI外卖卡片的晴空样式 */
.message-bubble.ai .waimai-header {
    display: flex !important;
    align-items: center !important;
    gap: 8px !important;
    padding: 15px !important;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1) !important;
}

.message-bubble.ai .waimai-header .title-group {
    font-size: 14px !important;
    color: #6B6B6B !important; /* 二级文本色 */
}

.message-bubble.ai .waimai-header .title-group .brand {
    font-weight: 600 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin-right: 5px !important;
}

.message-bubble.ai .waimai-catchphrase {
    font-size: 13px !important;
    color: #1E1E1E !important; /* 一级文本色 */
    padding: 15px !important;
    line-height: 1.4 !important;
}

.message-bubble.ai .waimai-main {
    background: rgba(248, 249, 250, 0.8) !important; /* 极浅的背景色 */
    padding: 15px !important;
    text-align: center !important;
}

.message-bubble.ai .waimai-main .request-title {
    font-size: 12px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    margin-bottom: 10px !important;
}

.message-bubble.ai .waimai-main .payment-box {
    background-color: #FFFFFF !important; /* 纯白背景 */
    border-radius: 12px !important;
    padding: 20px 15px !important;
    border: 1px solid rgba(0, 0, 0, 0.05) !important;
}

.message-bubble.ai .waimai-main .payment-label {
    font-size: 13px !important;
    color: #6B6B6B !important; /* 二级文本色 */
}

.message-bubble.ai .waimai-main .amount {
    font-size: 32px !important;
    font-weight: 700 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin: 8px 0 15px 0 !important;
}

.message-bubble.ai .waimai-main .countdown-label {
    font-size: 13px !important;
    color: #6B6B6B !important; /* 二级文本色 */
}

.message-bubble.ai .waimai-main .countdown-timer span {
    background-color: #1E1E1E !important; /* 炭黑色背景 */
    color: white !important;
    padding: 3px 6px !important;
    border-radius: 4px !important;
    font-size: 12px !important;
    font-weight: 500 !important;
}

/* 4. 用户外卖卡片的晴空样式 */
.message-bubble.user .waimai-header {
    display: flex !important;
    align-items: center !important;
    gap: 8px !important;
    padding: 15px !important;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1) !important;
}

.message-bubble.user .waimai-header .title-group {
    font-size: 14px !important;
    color: #6B6B6B !important; /* 二级文本色 */
}

.message-bubble.user .waimai-header .title-group .brand {
    font-weight: 600 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin-right: 5px !important;
}

.message-bubble.user .waimai-catchphrase {
    font-size: 13px !important;
    color: #1E1E1E !important; /* 一级文本色 */
    padding: 15px !important;
    line-height: 1.4 !important;
}

.message-bubble.user .waimai-main {
    background: rgba(248, 249, 250, 0.8) !important; /* 极浅的背景色 */
    padding: 15px !important;
    text-align: center !important;
}

.message-bubble.user .waimai-main .request-title {
    font-size: 12px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    margin-bottom: 10px !important;
}

.message-bubble.user .waimai-main .payment-box {
    background-color: #FFFFFF !important; /* 纯白背景 */
    border-radius: 12px !important;
    padding: 20px 15px !important;
    border: 1px solid rgba(0, 0, 0, 0.05) !important;
}

.message-bubble.user .waimai-main .payment-label {
    font-size: 13px !important;
    color: #6B6B6B !important; /* 二级文本色 */
}

.message-bubble.user .waimai-main .amount {
    font-size: 32px !important;
    font-weight: 700 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin: 8px 0 15px 0 !important;
}

.message-bubble.user .waimai-main .countdown-label {
    font-size: 13px !important;
    color: #6B6B6B !important; /* 二级文本色 */
}

.message-bubble.user .waimai-main .countdown-timer span {
    background-color: #1E1E1E !important; /* 炭黑色背景 */
    color: white !important;
    padding: 3px 6px !important;
    border-radius: 4px !important;
    font-size: 12px !important;
    font-weight: 500 !important;
}

/* 5. 外卖详情按钮美化 */
.message-bubble.user .waimai-details-btn {
    background-color: rgba(0, 0, 0, 0.05) !important;
    color: #1E1E1E !important;
    padding: 10px !important;
    text-align: center !important;
    font-size: 13px !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
    border: none !important;
}

.message-bubble.user .waimai-details-btn:hover {
    background-color: rgba(0, 0, 0, 0.08) !important;
}

.message-bubble.ai .waimai-details-btn {
    background-color: rgba(0, 0, 0, 0.05) !important;
    color: #1E1E1E !important;
    padding: 10px !important;
    text-align: center !important;
    font-size: 13px !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
    border: none !important;
}

.message-bubble.ai .waimai-details-btn:hover {
    background-color: rgba(0, 0, 0, 0.08) !important;
}

/* 6. 外卖操作按钮美化 - 晴空样式 */
.waimai-user-actions {
    display: flex !important;
    gap: 15px !important;
    padding: 20px !important;
    background: transparent !important;
}

.waimai-user-actions button {
    flex: 1 !important;
    padding: 10px 20px !important; /* 按照晴空方案调整 */
    border-radius: 8px !important;
    border: none !important;
    font-size: 12px !important; /* 缩小字体防止换行 */
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
    white-space: nowrap !important; /* 防止文字换行 */
    overflow: hidden !important; /* 隐藏溢出 */
    text-overflow: ellipsis !important; /* 文字溢出显示省略号 */
}

.waimai-decline-btn {
    background-color: #f5f5f5 !important;
    color: #6B6B6B !important; /* 二级文本色 */
    border: 1px solid #DCDCDC !important;
}

.waimai-decline-btn:hover {
    background-color: #eeeeee !important;
    transform: translateY(-2px) !important; /* 按照晴空方案标准 */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important;
}

.waimai-pay-btn {
    background-color: #1E1E1E !important; /* 炭黑色背景 */
    color: #FFFFFF !important; /* 白色文字 */
}

.waimai-pay-btn:hover {
    background-color: #000000 !important; /* 悬浮时变为纯黑 */
    transform: translateY(-2px) !important; /* 按照晴空方案标准 */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
}

/* 7. 外卖状态样式优化 */
.message-bubble.status-paid .waimai-main {
    background: rgba(230, 247, 235, 0.8) !important; /* 淡绿色背景表示已支付 */
}

.message-bubble.status-rejected .waimai-main {
    background: rgba(254, 242, 242, 0.8) !important; /* 淡红色背景表示已拒绝 */
    opacity: 0.8 !important;
}

/* ========== 【晴空】外卖卡片美化结束 ========== */

/* ========== 【晴空】链接卡片美化开始 ========== */

/* 1. 链接卡片主体美化 - 毛玻璃气泡效果 */
.link-share-card {
    width: 210px !important;
    background: rgba(255, 255, 255, 0.7) !important; /* 半透明白色背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important; /* 中等圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和悬浮阴影 */
    padding: 16px !important; /* 增加内边距 */
    cursor: pointer !important;
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
    display: flex !important;
    flex-direction: column !important;
    gap: 10px !important;
}

.link-share-card:hover {
    transform: translateY(-2px) !important; /* 悬浮时微微上浮 */
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.12) !important;
    background: rgba(255, 255, 255, 0.8) !important; /* 悬浮时稍微增加不透明度 */
}

/* 2. 链接标题样式 */
.link-share-card .title {
    font-weight: 600 !important;
    font-size: 15px !important;
    line-height: 1.4 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    display: -webkit-box !important;
    -webkit-line-clamp: 2 !important;
    -webkit-box-orient: vertical !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
}

/* 3. 链接描述样式 */
.link-share-card .description {
    font-size: 13px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    line-height: 1.4 !important;
    display: -webkit-box !important;
    -webkit-line-clamp: 3 !important;
    -webkit-box-orient: vertical !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
}

/* 4. 链接底部信息样式 */
.link-share-card .footer {
    display: flex !important;
    align-items: center !important;
    gap: 6px !important;
    font-size: 12px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    margin-top: 6px !important;
    padding-top: 8px !important;
    border-top: 1px solid rgba(0, 0, 0, 0.05) !important; /* 微妙分割线 */
}

.link-share-card .footer-icon {
    width: 14px !important;
    height: 14px !important;
    flex-shrink: 0 !important;
    opacity: 0.7 !important;
}

/* 5. 链接卡片在消息气泡中的样式 */
.message-bubble.is-share-link .content {
    padding: 0 !important;
    background: transparent !important;
    box-shadow: none !important;
    border: none !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

/* ========== 【晴空】链接卡片美化结束 ========== */

/* ========== 【晴空】位置卡片美化开始 ========== */

/* 1. 位置卡片主体美化 - 毛玻璃气泡效果 */
.location-card {
    width: 240px !important;
    background: rgba(255, 255, 255, 0.8) !important; /* 半透明白色背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 16px !important; /* 中等圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和悬浮阴影 */
    padding: 16px !important; /* 增加内边距 */
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
    display: flex !important;
    flex-direction: column !important;
    gap: 12px !important;
}

.location-card:hover {
    transform: translateY(-1px) !important; /* 悬浮时微微上浮 */
    box-shadow: 0 10px 32px 0 rgba(0, 0, 0, 0.12) !important;
    background: rgba(255, 255, 255, 0.85) !important; /* 悬浮时稍微增加不透明度 */
}

/* 2. 位置卡片头部样式 */
.location-header {
    display: flex !important;
    align-items: center !important;
    gap: 8px !important;
    padding-bottom: 8px !important;
    border-bottom: 1px solid rgba(0, 0, 0, 0.08) !important; /* 微妙分割线 */
}

.location-icon {
    width: 20px !important;
    height: 20px !important;
    color: #34C759 !important; /* 绿色位置图标，类似微信 */
    flex-shrink: 0 !important;
}

.location-title {
    font-weight: 600 !important;
    font-size: 16px !important;
    color: #1E1E1E !important; /* 一级文本色 */
}

/* 3. 位置内容区域 */
.location-content {
    display: flex !important;
    flex-direction: column !important;
    gap: 8px !important;
}

/* 4. 位置信息项 */
.location-item {
    display: flex !important;
    align-items: flex-start !important;
    gap: 12px !important;
}

.location-label {
    font-size: 13px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    font-weight: 500 !important;
    min-width: 60px !important; /* 确保标签对齐 */
    flex-shrink: 0 !important;
}

.location-value {
    font-size: 14px !important;
    color: #1E1E1E !important; /* 一级文本色 */
    line-height: 1.4 !important;
    word-break: break-all !important; /* 长文本换行 */
}

/* 5. 位置卡片在消息气泡中的样式 */
.message-bubble.is-location .content {
    padding: 0 !important;
    background: transparent !important;
    box-shadow: none !important;
    border: none !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

/* ========== 【晴空】位置卡片美化结束 ========== */

/* ========== 【晴空】模态框页面美化开始 ========== */

/* 1. 通用模态框背景美化 */
.modal {
    background-color: rgba(0, 0, 0, 0.3) !important; /* 更柔和的遮罩 */
}

/* 2. 通用模态框内容容器 - 毛玻璃效果 */
.modal-content {
    background: rgba(255, 255, 255, 0.7) !important; /* 半透明白色背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 20px !important; /* 增加圆角 */
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和悬浮阴影 */
    overflow: hidden !important;
}

/* 3. 模态框头部美化 */
.modal-header {
    background: transparent !important;
    padding: 20px !important;
    font-weight: 600 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    text-align: center !important;
    display: flex !important;
    justify-content: center !important; /* 居中对齐 */
    align-items: center !important;
}

/* 4. 模态框主体区域美化 */
.modal-body {
    padding: 20px !important;
    overflow-y: auto !important;
}

/* 5. 表单组样式统一 */
.modal-body .form-group {
    margin-bottom: 20px !important;
}

.modal-body .form-group label {
    display: block !important;
    font-size: 14px !important;
    color: #1E1E1E !important; /* 一级文本色 */
    margin-bottom: 8px !important;
    font-weight: 500 !important;
}

.modal-body .form-group input,
.modal-body .form-group textarea {
    width: 100% !important;
    padding: 12px 16px !important;
    border-radius: 8px !important; /* 小圆角 */
    border: 1px solid #DCDCDC !important; /* 浅灰色边框 */
    background-color: #FFFFFF !important; /* 纯白背景 */
    color: #1E1E1E !important; /* 炭黑色文字 */
    font-size: 16px !important;
    box-sizing: border-box !important;
    transition: all 0.2s ease-in-out !important;
}

.modal-body .form-group input::placeholder,
.modal-body .form-group textarea::placeholder {
    color: #A0A0A0 !important; /* 占位符文字 */
}

.modal-body .form-group input:focus,
.modal-body .form-group textarea:focus {
    outline: none !important;
    border-color: #1E1E1E !important; /* 焦点时边框变为炭黑色 */
    box-shadow: 0 0 0 3px rgba(30, 30, 30, 0.1) !important; /* 柔和外发光 */
}

/* 6. 模态框底部按钮美化 */
.modal-footer {
    background: transparent !important;
    padding: 20px !important;
    display: flex !important;
    justify-content: space-between !important;
    gap: 15px !important;
}

.modal-footer button {
    flex: 1 !important;
    padding: 12px 20px !important;
    border-radius: 8px !important;
    border: none !important;
    cursor: pointer !important;
    font-size: 16px !important;
    font-weight: 500 !important;
    transition: all 0.2s ease-in-out !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
}

.modal-footer .save {
    background-color: #1E1E1E !important; /* 炭黑色背景 */
    color: #FFFFFF !important; /* 白色文字 */
}

.modal-footer .save:hover {
    background-color: #000000 !important; /* 悬浮时变为纯黑 */
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
}

.modal-footer .cancel {
    background-color: #f5f5f5 !important;
    color: #6B6B6B !important; /* 二级文本色 */
    border: 1px solid #DCDCDC !important;
}

.modal-footer .cancel:hover {
    background-color: #eeeeee !important;
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important;
}

/* ========== 【晴空】模态框页面美化结束 ========== */

/* ========== 【晴空】转账操作模态框特殊美化开始 ========== */

/* 1. 转账操作模态框容器 */
.transfer-actions-content {
    background: rgba(255, 255, 255, 0.7) !important; /* 半透明白色背景 */
    backdrop-filter: blur(20px) !important; /* 背景模糊滤镜 */
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 20px !important;
    border: 1px solid rgba(255, 255, 255, 0.4) !important; /* 半透明白色边框 */
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important; /* 柔和悬浮阴影 */
    width: 280px !important;
    padding: 0 !important;
    position: relative !important;
    overflow: hidden !important;
}

/* 2. 转账操作头部 */
.transfer-actions-header {
    background: transparent !important;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1) !important;
    padding: 20px !important;
    font-weight: 600 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    text-align: center !important;
    font-size: 18px !important;
}

/* 3. 转账操作主体 */
.transfer-actions-body {
    padding: 20px !important;
    text-align: center !important;
}

.transfer-actions-body p {
    color: #6B6B6B !important; /* 二级文本色 */
    font-size: 14px !important;
    line-height: 1.5 !important;
    margin: 0 !important;
}

.transfer-actions-body strong {
    color: #1E1E1E !important; /* 一级文本色 */
    font-weight: 600 !important;
}

/* 4. 转账操作按钮区域 */
.transfer-actions-footer {
    padding: 0 20px 20px 20px !important;
    display: flex !important;
    gap: 15px !important;
    justify-content: space-between !important;
}

/* 【开心收下】按钮 - 主按钮样式 */
#transfer-action-accept {
    flex: 1 !important;
    background-color: #1E1E1E !important; /* 炭黑色背景 */
    color: #FFFFFF !important; /* 纯白色文字 */
    border: none !important; /* 无边框设计 */
    border-radius: 8px !important; /* 8px圆角 */
    padding: 10px 20px !important; /* 标准内边距 */
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
}

#transfer-action-accept:hover {
    background-color: #000000 !important; /* 悬浮时变为纯黑 */
    transform: translateY(-2px) !important; /* 向上平移2px */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important; /* 柔和阴影 */
}

/* 【残忍拒绝】按钮 - 次要按钮样式 */
#transfer-action-decline {
    flex: 1 !important;
    background-color: #FFFFFF !important; /* 浅灰背景 */
    color: #6B6B6B !important; /* 二级文本色 */
    border: 1px solid #F7F7F7 !important; /* 浅边框 */
    border-radius: 8px !important; /* 8px圆角 */
    padding: 10px 20px !important; /* 标准内边距 */
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
}

#transfer-action-decline:hover {
    background-color: #FFFFFF !important; /* 悬浮时背景变浅 */
    transform: translateY(-2px) !important; /* 向上平移2px */
    
}

/* 保留通用样式作为后备 */
.transfer-actions-footer .action-btn {
    flex: 1 !important;
    padding: 10px 20px !important;
    border-radius: 8px !important;
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
}

/* 5. 转账操作关闭按钮 */
.transfer-actions-content .cancel-btn {
    position: absolute !important;
    top: 15px !important;
    right: 15px !important;
    background: rgba(0, 0, 0, 0.05) !important;
    border: none !important;
    border-radius: 50% !important;
    width: 30px !important;
    height: 30px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    cursor: pointer !important;
    color: #6B6B6B !important;
    font-size: 18px !important;
    transition: all 0.2s ease-in-out !important;
}

.transfer-actions-content .cancel-btn:hover {
    background: rgba(0, 0, 0, 0.1) !important;
    transform: scale(1.1) !important;
}

/* ========== 【晴空】转账操作模态框特殊美化结束 ========== */

/* ========== 【晴空】自定义提示框美化开始 ========== */

/* 1. 自定义提示框背景 */
#custom-modal-overlay {
    background-color: rgba(0, 0, 0, 0.3) !important; /* 更柔和的遮罩 */
}

/* ▼▼▼ 用这段新代码替换旧的 #custom-modal 样式 ▼▼▼ */
/* 2. 自定义提示框容器 - 毛玻璃效果 */
#custom-modal {
    background: rgba(255, 255, 255, 0.7) !important;
    backdrop-filter: blur(20px) !important;
    -webkit-backdrop-filter: blur(20px) !important;
    border-radius: 20px !important;
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important;
    width: 280px !important;

    /* --- 以下是保证垂直居中的核心代码 --- */
    display: flex !important;
    flex-direction: column !important;
    justify-content: center !important;
    min-height: 240px !important; /* 可以适当调高最小高度以获得更好看的间距 */
}

/* 3. 自定义提示框头部美化 */
.custom-modal-header {
    background: transparent !important;
    padding: 20px !important;
    font-size: 18px !important;
    font-weight: 600 !important;
    color: #1E1E1E !important; /* 一级文本色 */
    text-align: center !important;
}

/* 4. 自定义提示框主体区域美化 */
.custom-modal-body {
    padding: 20px !important;
    text-align: center !important;
    font-size: 14px !important;
    color: #6B6B6B !important; /* 二级文本色 */
    line-height: 1.5 !important;
}

.custom-modal-body p {
    margin: 0 0 15px 0 !important;
    color: #6B6B6B !important; /* 二级文本色 */
}

/* 5. 自定义提示框输入框美化 */
.custom-modal-body input,
.custom-modal-body textarea {
    width: 100% !important;
    padding: 12px 16px !important;
    border-radius: 8px !important; /* 小圆角 */
    border: 1px solid #DCDCDC !important; /* 浅灰色边框 */
    background-color: #FFFFFF !important; /* 纯白背景 */
    color: #1E1E1E !important; /* 炭黑色文字 */
    font-size: 16px !important;
    box-sizing: border-box !important;
    transition: all 0.2s ease-in-out !important;
    margin-top: 10px !important;
}

.custom-modal-body input::placeholder,
.custom-modal-body textarea::placeholder {
    color: #A0A0A0 !important; /* 占位符文字 */
}

.custom-modal-body input:focus,
.custom-modal-body textarea:focus {
    outline: none !important;
    border-color: #1E1E1E !important; /* 焦点时边框变为炭黑色 */
    box-shadow: 0 0 0 3px rgba(30, 30, 30, 0.1) !important; /* 柔和外发光 */
}

.custom-modal-body textarea {
    resize: vertical !important;
    min-height: 80px !important;
}

/* 6. 自定义提示框底部按钮美化 */
.custom-modal-footer {
    background: transparent !important;
    padding: 0 !important;
    display: flex !important;
}

.custom-modal-footer button {
    flex: 1 !important;
    background: none !important;
    border: none !important;
    padding: 15px 20px !important;
    font-size: 16px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
    color: #6B6B6B !important; /* 二级文本色 */
}

.custom-modal-footer button:first-child {
    border-bottom-left-radius: 20px !important;
}

.custom-modal-footer button:last-child {
    border-bottom-right-radius: 20px !important;
}

.custom-modal-footer button:hover {
    background-color: rgba(0, 0, 0, 0.05) !important; /* 极淡的半透明背景 */
}

/* 7. 确定按钮特殊样式 - 晴空主按钮风格 */
.custom-modal-footer .confirm-btn {
    background-color: #1E1E1E !important; /* 炭黑色背景 */
    color: #FFFFFF !important; /* 白色文字 */
    font-weight: 600 !important;
    margin: 10px !important;
    border-radius: 20px !important; /* 所有四个角都与模态框一致 */
    padding: 10px 20px !important; /* 晴空方案标准内边距 */
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important; /* 与外卖按钮相同的阴影 */
}

.custom-modal-footer .confirm-btn:hover {
    background-color: #000000 !important; /* 悬浮时变为纯黑 */
    transform: translateY(-2px) !important; /* 向上平移2px */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important; /* 柔和阴影 */
}

/* 8. 取消按钮调整 */
.custom-modal-footer button:not(.confirm-btn) {
    background-color: #f5f5f5 !important; /* 与外卖按钮相同的背景色 */
    color: #6B6B6B !important; /* 与外卖按钮相同的文字色 */
    border: 1px solid #DCDCDC !important; /* 与外卖按钮相同的边框 */
    margin: 10px 5px 10px 10px !important;
    border-radius: 20px !important; /* 所有四个角都与模态框一致 */
    padding: 10px 15px !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important; /* 与外卖按钮相同的阴影 */
}

.custom-modal-footer button:not(.confirm-btn):hover {
    background-color: #eeeeee !important;
    transform: translateY(-2px) !important; /* 与外卖按钮相同的悬浮效果 */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important; /* 与外卖按钮相同的悬浮阴影 */
}

/* 9. 危险按钮样式 */
.custom-modal-footer .confirm-btn.btn-danger {
    background-color: #AB4D3F !important;
    color: #FFFFFF !important;
}

.custom-modal-footer .confirm-btn.btn-danger:hover {
    background-color: #d70015 !important;
}

/* ========== 【晴空】自定义提示框美化结束 ========== */
#chat-input:focus {
    outline: none; /* 首先移除浏览器默认样式 */
    
}
/* ▼▼▼ API预设按钮圆形美化样式开始 ▼▼▼ */
/* API预设列表中的操作按钮重新设计为圆形按钮 */
#api-settings-screen .preset-action-btn {
    width: 36px !important;
    height: 36px !important;
    border-radius: 50% !important;
    background-color: #1E1E1E !important;
    color: #FFFFFF !important;
    border: none !important;
    cursor: pointer !important;
    display: inline-flex !important;
    align-items: center !important;
    justify-content: center !important;
    margin: 0 4px !important;
    padding: 0 !important;
    font-size: 0 !important; /* 隐藏文字 */
    transition: all 0.3s ease !important;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15) !important;
}

#api-settings-screen .preset-action-btn:hover {
    transform: translateY(-2px) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25) !important;
}

/* 应用按钮SVG图标 */
#api-settings-screen .preset-action-btn[onclick*="applyApiPreset"]::before {
    content: '' !important;
    width: 18px !important;
    height: 18px !important;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23FFFFFF'%3E%3Cpath d='M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z'/%3E%3C/svg%3E") !important;
    background-size: contain !important;
    background-repeat: no-repeat !important;
    background-position: center !important;
    display: block !important;
}

/* 编辑按钮SVG图标 */
#api-settings-screen .preset-action-btn[onclick*="editApiPreset"]::before {
    content: '' !important;
    width: 18px !important;
    height: 18px !important;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23FFFFFF'%3E%3Cpath d='M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z'/%3E%3C/svg%3E") !important;
    background-size: contain !important;
    background-repeat: no-repeat !important;
    background-position: center !important;
    display: block !important;
}

/* 删除按钮SVG图标 */
#api-settings-screen .preset-action-btn[onclick*="deleteApiPreset"]::before {
    content: '' !important;
    width: 18px !important;
    height: 18px !important;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23FFFFFF'%3E%3Cpath d='M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z'/%3E%3C/svg%3E") !important;
    background-size: contain !important;
    background-repeat: no-repeat !important;
    background-position: center !important;
    display: block !important;
}
/* ▲▲▲ API预设按钮圆形美化样式结束 ▲▲▲ */

/* ▼▼▼ 【全新】可见范围切换按钮美化样式 ▼▼▼ */

/* 1. 切换器的整体容器样式 */
.visibility-switcher {
    display: flex;
    background-color: #F7F7F7; /* 容器的浅灰色背景板 */
    border-radius: 8px;
    padding: 4px;
    margin-bottom: 15px; /* 调整与下方元素的间距 */
}

/* 2. 隐藏原始的radio圆点 */
.visibility-switcher input[type="radio"] {
    display: none;
}

/* 3. 将<span>标签美化成按钮样式 */
.visibility-switcher span {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 32px;
    padding: 0 16px;
    line-height: 1;
    position: relative; /* 新增：开启相对定位，为微调做准备 */
    top: 1px; /* 新增：将文字整体向下移动1像素 */
    font-size: 14px;
    font-weight: 500;
    color: var(--text-secondary);
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.2s ease-in-out;
}

/* 4. 【核心】当radio被选中时，改变它后面<span>的样式 */
.visibility-switcher input[type="radio"]:checked + span {
    background-color: #1E1E1E; /* 您现有的主色调 */
    color: #FFFFFF; /* 纯白色文字 */
    box-shadow: 0 1px 4px rgba(0,0,0,0.15); /* 添加一点微妙的阴影 */
}

/* 5. 让两个按钮平分宽度 */
.visibility-switcher label {
    flex: 1;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【最终修正版】动态可见范围 - 分组选择器样式 ▼▼▼ */

/* 1. 整体容器改为灵活的标签式布局 */
#post-visibility-groups {
    display: flex;
    flex-wrap: wrap; /* 允许换行，实现横向显示 */
    gap: 10px; /* 标签之间的间距 */
    background-color: transparent;
    border: none;
    padding: 0;
    margin-top: 10px;
}

/* 2. 隐藏原始的复选框 */
#post-visibility-groups input[type="checkbox"] {
    display: none;
}

/* 3. 将label本身设计成一个圆角气泡（未选中状态）*/
#post-visibility-groups label {
    display: inline-block; /* 宽度根据内容自适应 */
    padding: 8px 16px;
    background-color: #F7F7F7; /* 修改点：将背景色改为 #F7F7F7 */
    color: var(--text-secondary);
    border: 2px solid transparent;
    border-radius: 20px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

/* 4. 【核心】使用:has()选择器，当label内的复选框被选中时，改变label的样式 */
#post-visibility-groups label:has(input[type="checkbox"]:checked) {
    background-color: #FFFFFF;
    color: #1E1E1E;
    border: 2px solid #1E1E1E;
    font-weight: 600;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】动态上传按钮美化样式 ▼▼▼ */
.post-image-upload-options button {
    flex: 1;
    margin-top: 0;
    padding: 10px 15px; /* 设置合适的内边距 */
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    background-color: #F7F7F7; /* 您指定的背景色 */
    color: #1E1E1E; /* 黑色文字 */
    border: 2px solid #1E1E1E; /* 您指定的黑色边框 */
    border-radius: 12px; /* 圆润的边角 */
    transition: background-color 0.2s ease; /* 添加悬浮过渡效果 */
}

.post-image-upload-options button:hover {
    background-color: #e9ecef; /* 鼠标悬浮时颜色变得稍深 */
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【修复】强制显示动态上传按钮 ▼▼▼ */
#image-mode-content.active .post-image-upload-options {
    display: flex !important; /* 强制使用flex布局并显示 */
    width: 100%;
    gap: 10px; /* 确保按钮间有空隙 */
}
/* ▲▲▲ 修复代码粘贴结束 ▲▲▲ */

/* 聊天字体大小滑块样式 - 重新设计 */
#font-size-slider {
    -webkit-appearance: none;
    appearance: none;
    width: 60%;
    height: 10px;
    border-radius: 5px;
    background: #ddd;
    outline: none;
    opacity: 0.8;
    transition: opacity 0.2s;
    margin: 15px 0;
    cursor: pointer; /* <-- 新增：让整个滑块条都可以点击 */
}

#font-size-slider:hover {
    opacity: 1;
}

/* Webkit浏览器 (Chrome, Safari) */
#font-size-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    /* ▼▼▼ 核心修改：通过设置宽高为0来隐藏圆球 ▼▼▼ */
    width: 0;
    height: 0;
}

/* 隐藏圆球的悬浮效果 */
#font-size-slider::-webkit-slider-thumb:hover {
    transform: none;
    background: transparent;
}

/* Mozilla Firefox */
#font-size-slider::-moz-range-thumb {
    /* ▼▼▼ 核心修改：通过设置宽高为0并移除边框来隐藏圆球 ▼▼▼ */
    width: 0;
    height: 0;
    border: none;
}

/* 隐藏圆球的悬浮效果 */
#font-size-slider::-moz-range-thumb:hover {
    transform: none;
    background: transparent;
}

#font-size-slider::-moz-range-track {
    width: 100%;
    height: 10px;
    cursor: pointer;
    background: #ddd;
    border-radius: 5px;
}

/* IE样式 */
#font-size-slider::-ms-track {
    width: 100%;
    height: 6px;
    cursor: pointer;
    background: transparent;
    border-color: transparent;
    border-width: 16px 0;
    color: transparent;
}

#font-size-slider::-ms-fill-lower {
    background: #000;
    border-radius: 10px;
}

#font-size-slider::-ms-fill-upper {
    background: #ddd;
    border-radius: 10px;
}

#font-size-slider::-ms-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #000;
    cursor: pointer;
    border: none;
}

/* 玻璃气泡按钮样式 */
.glass-bubble-button {
    background: rgba(255, 255, 255, 0.7) !important;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 16px !important;
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1) !important;
    overflow: hidden;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.glass-bubble-button:hover {
    transform: translateY(-4px) scale(1.02) !important;
    box-shadow: 0 12px 32px 0 rgba(0, 0, 0, 0.12) !important;
}
  
  /* ▼▼▼ 【全新】统一上传/移除背景按钮的文字样式 ▼▼▼ */
.bg-upload-container button {
    font-size: 14px;
    font-weight: 500;
}

/* ▼▼▼ 【全新】微信风格操作面板样式 ▼▼▼ */
#wechat-style-actions-panel {
    position: absolute;
    z-index: 1001;
    display: none;
    opacity: 0;
    background-color: #333333;
    border-radius: 8px;
    padding: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 16px;
    min-width: 240px;
    transform-origin: center center;
    transition: opacity 0.2s ease, transform 0.2s ease;
}

/* 按压渐出动画 */
@keyframes wechat-panel-press-in {
    0% {
        transform: scale(0.5);
        opacity: 0;
    }
    60% {
        transform: scale(1.02);
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}

/* 按压渐灭动画 */
@keyframes wechat-panel-press-out {
    0% {
        transform: scale(1);
        opacity: 1;
    }
    100% {
        transform: scale(0.8);
        opacity: 0;
    }
}

/* 动画状态类 */
#wechat-style-actions-panel.press-in {
    animation: wechat-panel-press-in 0.18s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}

#wechat-style-actions-panel.press-out {
    animation: wechat-panel-press-out 0.12s ease-out forwards;
}

#wechat-style-actions-panel::after {
    content: '';
    position: absolute;
    bottom: -8px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    border-top: 8px solid #333333;
}

/* 当面板在消息下方时，小三角指向上方 */
#wechat-style-actions-panel.below-message::after {
    top: -8px;
    bottom: auto;
    border-top: none;
    border-bottom: 8px solid #333333;
}

.wechat-action-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 8px;
    min-height: 60px;
    cursor: pointer;
    border-radius: 6px;
    transition: background-color 0.2s;
}

.wechat-action-btn:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.wechat-action-btn svg {
    width: 24px;
    height: 24px;
    margin-bottom: 6px;
    fill: #FFFFFF;
}

.wechat-action-btn button {
    background: none;
    border: none;
    padding: 0;
    font-family: inherit;
    font-size: 11px;
    color: white;
    cursor: pointer;
    text-align: center;
    line-height: 1.2;
}
/* ▲▲▲ 微信风格操作面板样式结束 ▲▲▲ */

/* ▼▼▼ 圆形勾选框样式 ▼▼▼ */
.share-target-checkbox {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    width: 20px;
    height: 20px;
    border: 2px solid #1E1E1E;
    border-radius: 50%;
    background-color: transparent;
    cursor: pointer;
    position: relative;
    transition: all 0.3s ease;
}

.share-target-checkbox:checked {
    background-color: #1E1E1E;
    border-color: #1E1E1E;
}

.share-target-checkbox:hover {
    border-color: #333333;
}

.share-target-checkbox:hover:checked {
    background-color: #333333;
}
/* ▲▲▲ 圆形勾选框样式结束 ▲▲▲ */
  /* --- 【最终强力修正】自定义弹窗垂直居中 --- */

/* 1. 强制弹窗容器为Flex布局并给予最小高度 */
#custom-modal {
    display: flex !important;
    flex-direction: column !important;
    min-height: 240px !important; /* 确保有足够的垂直空间 */
}

/* 2. 让头部和脚部占据固定空间，不要伸缩 */
#custom-modal .custom-modal-header,
#custom-modal .custom-modal-footer {
    flex-shrink: 0 !important;
}

/* 3. 【核心】让中间的内容区占据所有剩余空间，并将其内部内容（输入框）改为顶部对齐 */
#custom-modal .custom-modal-body {
    flex-grow: 1 !important;
    display: flex !important;
    flex-direction: column !important;
    /* ▼▼▼ 核心修改就在这里 ▼▼▼ */
    justify-content: flex-start !important; /* 将垂直居中 (center) 改为顶部对齐 (flex-start) */
    padding-top: 20px !important;           /* (推荐) 增加一点上边距，避免输入框紧贴标题 */
}

/* --- 【强力修正】隐藏单聊和群聊心声弹窗的头部 --- */
#status-modal .modal-header,
#group-status-modal .modal-header {
    display: none !important; /* 关键：添加 !important 标记 */
}

/* ▼▼▼ 【全新】外观设置 - 左右并排布局样式 ▼▼▼ */
.settings-row-container {
    display: flex; /* 开启flex布局，让内部元素横向排列 */
    gap: 15px; /* 在两个设置项之间增加15像素的间距 */
    width: 100%;
    box-sizing: border-box;
    padding: 0 10px; /* 保证左右两边有边距 */
    margin-top: 20px; /* <--- 在这里添加新代码，20px可以随意调整 */
}

/* 让容器内的每个设置项（.form-group）都占据一半的可用空间 */
.settings-row-container > .form-group {
    flex: 1; 
    min-width: 0; /* flex布局中的重要属性，防止内容溢出 */
}

/* 确保夜间模式开关的内部也正确对齐 */
.settings-row-container .form-group:not(.padding-setting-container) {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
/* ▲▲▲ 专属样式结束 ▲▲▲ */

/* ▼▼▼ 【全新】模拟翻译器功能样式 ▼▼▼ */

/* 1. 让翻译气泡的内容区透明，以便自定义内部样式 */
.message-bubble.is-translation .content {
    padding: 0 !important;
    background: transparent !important;
    box-shadow: none !important;
    border: none !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

/* 2. 翻译前（显示外语）的容器样式 */
.translation-body {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 4px 8px;
    gap: 8px; /* 图标和文字的间距 */
}




/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】自定义HTML模块样式 ▼▼▼ */
.message-wrapper.html-module-wrapper {
    
    display: flex;
    justify-content: center; /* 水平居中 */
    align-self: center; /* 确保容器本身在聊天流中居中 */
    margin: 10px 0;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】自定义HTML模块样式 ▼▼▼ */
.message-wrapper.html-module-wrapper {
    
    display: flex;
    justify-content: center; /* 水平居中 */
    align-self: center; /* 确保容器本身在聊天流中居中 */
    margin: 10px 0;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新添加】HTML模块强制居中与响应式修复 ▼▼▼ */
.message-wrapper.html-module-wrapper .message-bubble > orange > div {
    width: 100% !important;
    max-width: 420px !important;
    box-sizing: border-box !important;
    margin-left: auto !important;
    margin-right: auto !important;
}
/* ▲▲▲ 添加结束 ▲▲▲ */

/* ▼▼▼ 【全新】HTML指令输入弹窗样式 ▼▼▼ */
/* ▼▼▼ 【全新】HTML指令输入弹窗样式 ▼▼▼ */
#html-prompt-modal .modal-content {
    height: auto;
    max-height: 70%;
}

#html-prompt-modal .modal-body {
    padding: 15px;
}

#html-prompt-modal #html-prompt-input {
    width: 100%;
    min-height: 150px;
    resize: vertical;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    padding: 10px;
    font-size: 14px;
    box-sizing: border-box;
}

#html-prompt-modal .modal-footer {
    justify-content: space-between;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】半透明风格日期时间戳样式 ▼▼▼ */
.date-divider {
    align-self: center;
    padding: 3px 10px;
    margin: -3px 0;
    /* 核心修改：使用半透明的黑色作为背景 */
    background-color: rgba(0, 0, 0, 0.1);
    /* 核心修改：文字颜色调整为深灰色以保证清晰 */
    color: var(--text-secondary);
    font-size: 11px;
    font-weight: 500;
    border-radius: 4px;
    text-align: center;
}
#phone-screen.dark-mode .date-divider {
    /* 核心修改：暗色模式下使用半透明的白色 */
    background-color: rgba(255, 255, 255, 0.15);
    color: #8d8d92;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】图片及其他卡片气泡包裹问题修正 ▼▼▼ */

/* 1. 为所有“卡片式”消息的 .content 容器应用透明背景 */
/* 这会覆盖掉默认主题和自定义主题中对 .content 的样式，让卡片本身显露出来 */
.message-bubble.has-image .content,
.message-bubble.is-ai-image .content,
.message-bubble.is-transfer .content,
.message-bubble.is-waimai-request .content,
.message-bubble.is-red-packet .content,
.message-bubble.is-poll .content,
.message-bubble.is-link-share .content,
.message-bubble.is-location .content,
.message-bubble.is-gift .content {
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

/* 2. 为图片内容设置一个合适的内边距，避免图片紧贴边缘 */
.message-bubble.has-image .content,
.message-bubble.is-ai-image .content {
    padding: 5px !important;
}

/* 3. 为其他本身不需要内边距的卡片类型，移除内边距 */
.message-bubble.is-transfer .content,
.message-bubble.is-waimai-request .content,
.message-bubble.is-red-packet .content,
.message-bubble.is-poll .content,
.message-bubble.is-link-share .content,
.message-bubble.is-location .content,
.message-bubble.is-gift .content {
    padding: 0 !important;
}

/* ▲▲▲ 修正代码粘贴结束 ▲▲▲ */

/* ▼▼▼ 【修复】模拟时间戳位置修正 ▼▼▼ */
/*
  问题：您新的 .timestamp 样式使用了 position: absolute，这会错误地将居中的【模拟时间戳】也拉到气泡旁边。
  修复：我们使用一个更高优先级的规则，强制 .simulated-timestamp 恢复它原本的布局方式，而不影响普通的时间戳。
*/
.timestamp.simulated-timestamp {
    position: relative !important; /* 强制恢复其相对定位，让它回到正常的文档流中 */
    display: inline-block !important; /* 确保它能像一个独立的块一样居中 */
    z-index: 10 !important; /* 确保它在顶层 */
    
    /* 重置掉从 .user .timestamp / .ai .timestamp 继承来的错误定位 */
    left: auto !important; 
    right: auto !important;
    bottom: auto !important;

    /* 恢复它自己的外边距，用于和上下消息分隔 */
    margin-bottom: 3px !important;
}
/* ▲▲▲ 修复代码粘贴结束 ▲▲▲ */
/* ▼▼▼ 在这里粘贴新代码 ▼▼▼ */
.lock-actions-container {
    display: flex; /* 核心：让内部元素横向排列 */
    justify-content: center; /* 讓按鈕在容器內居中 */
    gap: 15px; /* 按钮之间的间距 */
    margin-top: 0px; /* 让按钮组和上面的文字有一点距离 */
    width: 100%;
}
/* ▲▲▲ 新代码粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】人设展开编辑器样式 ▼▼▼ */
.persona-label-wrapper {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px; /* 保持和原版一致的间距 */
}

.expand-persona-btn {
    /* 尺寸与定位 */
    width: 32px;
    height: 32px;
    flex-shrink: 0;
    
    /* 外观重置与美化 */
    background-color: rgba(0, 0, 0, 0.05); /* 使用半透明背景，更好地适应日间/夜间模式 */
    border: none;
    border-radius: 50%; /* 保持圆形 */
    padding: 0; /* 移除内边距，确保SVG精确定位 */
    cursor: pointer;
    
    /* 内容居中 */
    display: flex;
    align-items: center;
    justify-content: center;
    
    /* 交互效果 */
    transition: background-color 0.2s ease, transform 0.1s ease;
}

.expand-persona-btn:hover {
    background-color: rgba(0, 0, 0, 0.1); /* 悬浮时加深背景 */
}

.expand-persona-btn:active {
    transform: scale(0.9); /* 点击时轻微缩小 */
}

/* SVG图标本身样式 */
.expand-persona-btn svg {
    width: 16px; /* 图标尺寸略小于按钮 */
    height: 16px;
    color: var(--text-secondary); /* 使用次要文字颜色，确保清晰 */
}

.expand-persona-btn:hover {
    background-color: #e0e0e0;
}

.persona-editor-expanded .expanded-textarea {
    width: 100%;
    min-height: 550px; /* 展开后提供更大的编辑区 */
    resize: vertical;
    padding: 10px;
    border-radius: 6px;
    border: 1px solid var(--border-color);
    font-size: 14px;
    box-sizing: border-box;
}

.persona-editor-expanded .expanded-actions {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 10px;
}

.persona-editor-expanded .expanded-actions button {
    padding: 8px 16px;
    border-radius: 6px;
    border: 1px solid transparent;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
}

.persona-editor-expanded .expanded-actions .cancel-expanded-btn {
    background-color: #f0f0f0;
    border-color: #ddd;
    color: var(--text-primary);
}

.persona-editor-expanded .expanded-actions .save-expanded-btn {
    background-color: var(--accent-color);
    color: white;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新添加】微信风格顶栏毛玻璃效果 ▼▼▼ */
#chat-interface-screen .header {
    position: absolute; /* 1. 改为绝对定位，让其脱离文档流浮动起来 */
    top: 0;
    left: 0;
    width: 100%;
    background-color: rgba(247, 247, 247, 0.8); /* 2. 背景色改为半透明 */
    backdrop-filter: blur(15px); /* 3. 添加背景模糊（毛玻璃核心） */
    -webkit-backdrop-filter: blur(15px); /* 4. 兼容Safari浏览器 */
    border-bottom: 1px solid rgba(0, 0, 0, 0.1); /* 5. 边框也改为更柔和的半透明色 */
    box-sizing: border-box; /* 6. 确保宽度计算正确 */
}
/* ▲▲▲ 新代码粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新添加】聊天设置窗口位置微调 ▼▼▼ */
#chat-settings-modal {
    padding-top: 30px; /* 增加40px的顶部内边距，使其内容整体下移15px */
    box-sizing: border-box; /* 确保内边距不会影响整体布局 */
}
/* ▲▲▲ 添加结束 ▲▲▲ */
/* ▼▼▼ 【全新添加】角色卡导入按钮专属样式 ▼▼▼ */
#import-character-card-btn {
    margin-left: auto; /* 让它和右边的按钮之间自动产生间距 */
}
/* ▲▲▲ 添加结束 ▲▲▲ */
/* ▼▼▼ 【全新添加】修复iOS添加到桌面后，模态框遮罩无法覆盖底部安全区的问题 ▼▼▼ */
.modal,
#custom-modal-overlay,
#transfer-modal,
#battery-alert-modal,
#incoming-call-modal {
    position: fixed; /* 1. 统一并强制使用 fixed 定位，使其相对于屏幕视口 */
    top: 0;
    left: 0;
    right: 0;      /* 2. 新增 right: 0 */
    bottom: 0;     /* 3. 新增 bottom: 0 */
    height: auto;  /* 4. 将原来的 height: 100% 或类似设置改为 auto */
    width: auto;   /* 5. 将原来的 width: 100% 改为 auto */
}
/* ▲▲▲ 新代码粘贴结束 ▲▲▲ */
/* ▼▼▼ 【最终修正版】简约风格的刷新锚点按钮 ▼▼▼ */
#refresh-memory-anchor-btn {
    width: 32px;
    height: 32px;
    background-color: rgba(0, 0, 0, 0.05); /* 使用一个非常淡的灰色背景 */
    border: 1px solid rgba(0, 0, 0, 0.08); /* 添加一个几乎看不见的边框增加质感 */
    transition: background-color 0.2s ease; /* 添加悬浮过渡效果 */
}

#refresh-memory-anchor-btn:hover {
    background-color: rgba(0, 0, 0, 0.1); /* 鼠标悬浮时背景加深一点 */
}

/* 更改SVG图标的颜色并强制移除内部填充 */
#refresh-memory-anchor-btn svg {
    fill: none !important; /* 【核心修复】强制移除白色填充 */
    stroke: var(--text-secondary); 
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】“查角色手机”功能相关样式 ▼▼▼ */

/* 角色选择列表项 */
.character-select-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
}
.character-select-item:hover {
    background-color: #f5f5f5;
}
.character-select-item img {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    margin-right: 12px;
}
.character-select-item .name {
    font-weight: 500;
}

/* 角色手机的聊天气泡 (简化版) */
.character-chat-bubble {
    padding: 8px 12px;
    border-radius: 12px;
    max-width: 80%;
    word-break: break-word;
    line-height: 1.5;
}
.character-chat-bubble.sent {
    background-color: #dcf8c6;
    align-self: flex-end; /* 自己发的靠右 */
}
.character-chat-bubble.received {
    background-color: #ffffff;
    align-self: flex-start; /* 收到的靠左 */
}

/* ▼▼▼ 【美化版】角色手机数据列表项样式 ▼▼▼ */
.character-data-item {
    padding: 12px 15px;
    border-bottom: 1px solid #f0f0f0; /* 边框颜色变浅 */
    background-color: #ffffff; /* 增加白色背景 */
    margin: 8px 10px; /* 增加外边距，形成卡片感 */
    border-radius: 8px; /* 增加圆角 */
    box-shadow: 0 1px 3px rgba(0,0,0,0.05); /* 增加非常淡的阴影 */
    transition: transform 0.2s, box-shadow 0.2s; /* 增加悬浮动画 */
}

.character-data-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.08);
}

.character-data-item .title {
    font-weight: 600;
    margin-bottom: 5px;
    color: #333; /* 标题颜色加深 */
}
.character-data-item .content {
    font-size: 14px;
    color: #555;
    line-height: 1.6;
    white-space: pre-wrap;
}
.character-data-item .meta {
    font-size: 12px;
    color: #888;
    margin-top: 10px;
    padding-top: 8px; /* 在meta上方增加一点距离和分割线 */
    border-top: 1px solid #f5f5f5;
    display: flex;
    justify-content: space-between;
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* ▼▼▼ 【V3修正版】角色手机“画中画”样式修正 ▼▼▼ */

/* 1. 【核心修正1】让手机外壳容器占据整个屏幕，并用内边距把手机框“推”下来 */
#character-phone-container {
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #f0f2f5;
    padding-top: 50px; /* ★★★ 在顶部留出50px空间，把手机框推到主顶栏下方 ★★★ */
    box-sizing: border-box; /* 确保内边距计算正确 */
}

/* 2. 手机边框样式 (保持不变) */
.character-phone-frame {
    width: 95%;
    height: 98%;
    background-color: #1a1a1a;
    border-radius: 30px;
    padding: 10px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    box-sizing: border-box;
    position: relative;
    display: flex;
}

/* 3. 【核心修改1】缩小App图标的背景方格 */
#character-app-grid .app-icon .icon-bg {
    width: 55px;  /* ★★★ 从 65px 显著缩小到 50px ★★★ */
    height: 55px; /* ★★★ 高度同步缩小 ★★★ */
    border-radius: 12px; /* 圆角也可以稍微小一点 */
}

/* 3. 【核心修正2】缩小APP图标内的SVG */
#character-app-grid .app-icon .icon-bg svg {
    width: 60%;  /* ★★★ 将SVG的宽度缩小到其容器的60% ★★★ */
    height: 60%; /* ★★★ 高度也同步缩小 ★★★ */
}

/* 4. 其余样式保持不变 */
.character-phone-inner-screen {
    flex-grow: 1;
    background-color: #fff;
    border-radius: 20px;
    overflow: hidden;
    position: relative;
}
.character-phone-notch {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    height: 20px;
    background-color: #1a1a1a;
    border-radius: 0 0 10px 10px;
    z-index: 10;
}
.character-phone-page {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}
.character-phone-page.active {
    opacity: 1;
    visibility: visible;
    z-index: 5;
}
.character-phone-header {
    flex-shrink: 0;
    padding: 8px 12px;
    padding-top: 35px;
    background-color: rgba(247, 247, 247, 0.7);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    font-size: 16px;
}
.character-phone-header .action-btn svg,
.character-phone-header .back-btn svg {
    color: var(--accent-color);
}
#character-chat-history-messages {
    background-image: none !important;      /* ★★★ 移除背景图片 ★★★ */
    background-color: #F5F5F5
 !important; /* ★★★ 设置为白色背景 ★★★ */
}
/* ▲▲▲ 样式修正结束 ▲▲▲ */

/* ▼▼▼ 【V5修正版】角色手机APP图标布局修正 ▼▼▼ */
#character-app-grid.app-grid-standard {
    grid-template-columns: repeat(3, 1fr); /* 核心：从4列改为3列 */
    width: 100%; /* 稍微加宽一点，让3个图标的间距更和谐 */
    padding-top: 70px; /* 稍微增加顶部距离，避免和刘海太近 */
}
/* ▲▲▲ 样式修正结束 ▲▲▲ */

/* ▼▼▼ 【全新】角色手机微信风格聊天气泡样式 ▼▼▼ */

/* 1. 聊天记录界面的背景色 */
#character-chat-history-messages {
    background-color: #ededed; /* 微信经典的灰色背景 */
    /* 移除之前版本可能存在的背景图片 */
    background-image: none;
}

/* 2. 消息气泡的通用容器样式 */
.character-chat-bubble-container {
    display: flex;
    gap: 10px;
    align-items: flex-start;
    margin-bottom: 12px;
    max-width: 80%; /* 限制气泡最大宽度 */
}

/* 3. 气泡的内容区域 */
.character-chat-bubble {
    position: relative;
    padding: 8px 12px;
    line-height: 1.5;
    word-break: break-word;
    border-radius: 6px;
    font-size: 15px;
}

/* 4. 头像样式 */
.character-chat-avatar {
    width: 36px;
    height: 36px;
    border-radius: 6px; /* 微信风格的圆角矩形头像 */
    flex-shrink: 0;
}

/* --- 我方（角色自己）的气泡 --- */
.character-chat-bubble-container.sent {
    align-self: flex-end; /* 整体靠右 */
    flex-direction: row-reverse; /* 布局反转：内容 -> 头像 */
}
.character-chat-bubble-container.sent .character-chat-bubble {
    background-color: #95ec69; /* 微信绿 */
    color: #000;
}
/* 我方气泡的小尾巴 */
.character-chat-bubble-container.sent .character-chat-bubble::after {
    content: "";
    position: absolute;
    right: -4px;
    top: 10px;
    width: 0;
    height: 0;
    border: 4px solid transparent;
    border-left-color: #95ec69;
    border-right: 0;
}

/* --- 对方（NPC或用户）的气泡 --- */
.character-chat-bubble-container.received {
    align-self: flex-start; /* 整体靠左 */
}
.character-chat-bubble-container.received .character-chat-bubble {
    background-color: #ffffff; /* 白色 */
    color: #000;
}
/* 对方气泡的小尾巴 */
.character-chat-bubble-container.received .character-chat-bubble::before {
    content: "";
    position: absolute;
    left: -4px;
    top: 10px;
    width: 0;
    height: 0;
    border: 4px solid transparent;
    border-right-color: #ffffff;
    border-left: 0;
}

/* --- 功能性重置：针对图片/表情包，让气泡“消失” --- */
.character-chat-bubble-container .character-chat-bubble:has(img.sticker-image) {
    background: transparent !important;
    padding: 0 !important;
    border-radius: 0;
}
.character-chat-bubble-container .character-chat-bubble:has(img.sticker-image)::before,
.character-chat-bubble-container .character-chat-bubble:has(img.sticker-image)::after {
    content: none !important;
}
/* ▲▲▲ 样式添加结束 ▲▲▲ */

/* ▼▼▼ 【全新】角色手机新增APP页面样式 ▼▼▼ */

/* 1. 相册页面的网格布局 */
#character-album-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 每行3张图 */
    gap: 4px;
    padding: 4px;
}
.character-album-item {
    aspect-ratio: 1 / 1; /* 保持正方形 */
    background-color: #e0e0e0;
    cursor: pointer;
}
.character-album-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

/* 2. 银行页面的余额显示 */
.character-bank-balance-card {
    margin: 15px;
    padding: 20px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border-radius: 12px;
    text-align: center;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}
.character-bank-balance-card .label {
    font-size: 14px;
    opacity: 0.8;
}
.character-bank-balance-card .amount {
    font-size: 32px;
    font-weight: 600;
    margin-top: 5px;
}

/* 3. 银行交易记录的颜色 */
.character-data-item .transaction-amount {
    font-weight: 600;
}
.character-data-item .transaction-amount.income {
    color: #4CAF50; /* 收入为绿色 */
}
.character-data-item .transaction-amount.expense {
    color: #F44336; /* 支出为红色 */
}

/* ▲▲▲ 样式添加结束 ▲▲▲ */

/* ▼▼▼ 【V5修正版】角色手机相册网格布局 ▼▼▼ */
#character-album-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 每行3张图 */
    gap: 4px;
    padding: 4px;
}
.character-album-item {
    aspect-ratio: 1 / 1; /* 保持正方形 */
    background-color: #e0e0e0;
    cursor: pointer;
}
.character-album-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}
/* ▲▲▲ 样式修正结束 ▲▲▲ */

/* ▼▼▼ 【全新】Markdown渲染增强样式 ▼▼▼ */

/* 1. 为角色手机里的所有Markdown内容设置基础样式 */
.character-data-item .content h1,
.character-data-item .content h2,
.character-data-item .content h3,
.character-data-item .content p {
    margin: 0 0 10px 0; /* 统一标题和段落的下边距 */
}
.character-data-item .content h1 { font-size: 1.5em; font-weight: 600; }
.character-data-item .content h2 { font-size: 1.3em; font-weight: 600; }
.character-data-item .content h3 { font-size: 1.1em; font-weight: 600; }

/* 2. 删除线样式 */
.character-data-item .content del {
    color: #8a8a8a;
}

/* 3. 遮挡/剧透效果 */
.character-data-item .content .spoiler {
    background-color: #333;
    color: #333; /* 文字和背景一个色，实现隐藏 */
    padding: 0 4px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}
/* 点击或鼠标悬停时显示内容 */
.character-data-item .content .spoiler:hover,
.character-data-item .content .spoiler:active {
    background-color: #f0f0f0;
    color: #000;
}

/* ▲▲▲ 样式添加结束 ▲▲▲ */

/* ▼▼▼ 【全新】角色手机日记美化与删除功能样式 ▼▼▼ */

/* 1. 让日记列表有更好的边距 */
#character-diary-list {
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 12px; /* 增加日记之间的间距 */
}

/* 2. 美化单篇日记卡片 */
#character-diary-list .character-data-item {
    background-color: #fffaf0; /* 温暖的米黄色背景 */
    border-left: 4px solid #ffc107; /* 左侧加一条装饰线 */
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    position: relative; /* 为了定位删除按钮 */
    padding-bottom: 35px; /* 为底部的日期留出空间 */
}

/* 3. 美化日期显示，把它放到右下角 */
#character-diary-list .character-data-item .meta {
    position: absolute;
    bottom: 8px;
    right: 12px;
    border-top: none; /* 移除原来的上边框 */
    padding-top: 0;
    font-size: 11px;
    color: #bfa87a;
}

/* 4. 删除按钮的样式 */
.diary-delete-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 26px;
    height: 26px;
    border-radius: 50%;
    background-color: rgba(0,0,0,0.05);
    color: #bfa87a;
    border: none;
    cursor: pointer;
    font-size: 20px;
    line-height: 26px;
    text-align: center;
    opacity: 0; /* 默认隐藏 */
    transition: opacity 0.2s ease-in-out;
}
/* 鼠标悬停在日记上时显示按钮 */
#character-diary-list .character-data-item:hover .diary-delete-btn {
    opacity: 1;
}
.diary-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* ▲▲▲ 样式添加结束 ▲▲▲ */

/* ▼▼▼ 【V6最终修复版】角色手机相册布局防溢出 ▼▼▼ */

/* 1. 【核心】为相册网格的容器强制禁止水平滚动 */
#character-album-grid.list-container {
    overflow-x: hidden;
}

/* 2. 重新定义网格布局 */
#character-album-grid {
    display: grid;
    /* 【核心】每行3个，但这次我们用calc()精确计算宽度 */
    grid-template-columns: repeat(3, calc(33.333% - 4px)); 
    gap: 6px; /* 稍微增大间隙，让calc有计算空间 */
    padding: 6px; /* 内边距和间隙保持一致 */
    box-sizing: border-box; /* 确保内边距和边框被包含在总宽度内 */
}

/* 3. 稍微缩小图片，确保它们不会撑破容器 */
.character-album-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block; /* 移除图片下方的微小空隙 */
}

/* ▲▲▲ 样式修正结束 ▲▲▲ */

/* ▼▼▼ 【V6独家定制】角色手机信纸风格日记样式 ▼▼▼ */

/* 1. 【核心】重塑日记卡片，让它像一张信纸 */
#character-diary-list .character-data-item {
    background-color: #fdfaf2; /* 温暖、柔和的米白/浅黄色，模拟信纸 */
    border: 1px solid #eaddc7;  /* 淡淡的纸张边缘色 */
    border-left: 3px solid #d4bda5; /* 左侧加一条稍深的线，像装订线 */
    box-shadow: 2px 2px 6px rgba(0,0,0,0.06); /* 更柔和的阴影 */
    position: relative;
    padding: 20px 15px 15px 20px; /* 调整内边距，给“小东西”留出空间 */
    font-family: Georgia, 'Times New Roman', 'Kaiti TC', 'STKaiti', serif; /* 使用更典雅的衬线字体 */
}

/* 2. 【小东西】用伪元素在左上角添加一个精致的纸夹 */
#character-diary-list .character-data-item::before {
    content: '📎'; /* 这是一个Emoji纸夹，简单又有效 */
    position: absolute;
    top: -12px;
    left: 15px;
    font-size: 24px;
    transform: rotate(-25deg); /* 让纸夹有一个随意的角度 */
    opacity: 0.8;
}

/* 3. 【核心】重置Markdown内容的字体，确保它们继承信纸的字体 */
#character-diary-list .character-data-item .content,
#character-diary-list .character-data-item .content h1,
#character-diary-list .character-data-item .content h2,
#character-diary-list .character-data-item .content h3 {
    font-family: inherit; /* 强制继承父元素的字体 */
    color: #4a443b; /* 使用深棕色文字，更有质感 */
}

#character-diary-list .character-data-item .content p {
    margin: 0 0 12px 0;
}

/* 4. 将日期移动到右上角，像信纸的落款日期 */
#character-diary-list .character-data-item .meta {
    position: absolute;
    top: 10px;
    right: 12px;
    font-size: 11px;
    color: #ae9c82; /* 匹配信纸风格的日期颜色 */
    font-style: italic; /* 斜体更有手写感 */
    border-top: none;
    padding-top: 0;
}

/* 5. 美化删除按钮，让它更融入信纸风格 */
#character-diary-list .character-data-item .diary-delete-btn {
    background-color: transparent;
    color: #c9bbae;
    font-size: 22px;
    transition: all 0.2s ease;
}

#character-diary-list .character-data-item .diary-delete-btn:hover {
    background-color: #e44d44;
    color: white;
    transform: scale(1.1);
}

/* ▲▲▲ 样式添加结束 ▲▲▲ */
  </style>
</head>
<body>
        <div id="phone-screen">

            <div id="notification-bar"><img id="notification-avatar" src=""><div id="notification-content"><div class="name"></div><div class="message"></div></div></div>
            
            <div id="home-screen" class="screen active">
                <div id="clock-container"><div id="main-time">12:00</div><div id="main-date">星期一, 1月1日</div></div>
                                                <!-- ▼▼▼ 用这整块代码替换你原来的 id="app-grid" ▼▼▼ -->
<div id="app-grid">
    <div class="app-row">
        <div class="app-icon" onclick="showScreen('world-book-screen')">
            <div class="icon-bg">
                <img id="icon-img-world-book" src="https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg" alt="世界书">
            </div>
            <span class="label">世界书</span>
        </div>
        <div class="app-icon" onclick="showScreen('chat-list-screen')">
            <div class="icon-bg">
                <img id="icon-img-qq" src="https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg" alt="QQ">
            </div>
            <span class="label">Chat</span>
        </div>
        <div class="app-icon" onclick="showScreen('forum-screen')">
            <div class="icon-bg">
                <img id="icon-img-forum" src="https://i.postimg.cc/W3y7GZ1W/IMG-6443.jpg" alt="论坛">
            </div>
            <span class="label">论坛</span>
        </div>
    </div>
    <div class="app-row">
        <div class="app-icon" data-app-id="check-phone" onclick="openCharacterSelectionScreen()">
                <div class="icon-bg">
                    <img id="icon-img-check-phone" src="https://i.postimg.cc/RVwpwr0r/IMG-8348.jpg" alt="查手机">
                </div>
                <span class="label">查手机</span>
            </div>
        <div class="app-icon" onclick="showScreen('api-settings-screen')">
            <div class="icon-bg">
                <img id="icon-img-api-settings" src="https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg" alt="API设置">
            </div>
            <span class="label">API设置</span>
        </div>
        <div class="app-icon" onclick="showScreen('wallpaper-screen')">
            <div class="icon-bg">
                <img id="icon-img-wallpaper" src="https://i.postimg.cc/T1j03pQr/IMG-6440.jpg" alt="外观设置">
            </div>
            <span class="label">外观设置</span>
        </div>
        <div class="app-icon" onclick="showScreen('font-settings-screen')">
            <div class="icon-bg">
                <img id="icon-img-font" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg" alt="字体">
            </div>
            <span class="label">字体</span>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
            </div>
          
<div id="world-book-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>世界书</span>
        <div class="header-actions"> <!-- 【推荐】用一个容器把按钮包起来 -->
            <span class="action-btn" id="add-world-book-btn">+</span>
        </div>
    </div>
    <div id="world-book-list"></div>
</div>

            <div id="api-settings-screen" class="screen"><div class="header"><span class="back-btn" onclick="showScreen('home-screen')">‹</span><span>API 设置</span><span style="width: 30px;"></span></div><div class="form-container"><p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">提示: 若要使用“发送图片”功能, 请务必选择支持Vision(视觉)的模型, 如<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4o</code>或<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4-vision-preview</code>。</p><div class="form-group"><label for="proxy-url">反代地址 (不需要添加/v1噢~)</label><input type="text" id="proxy-url" placeholder="例如: https://api.openai.com"></div><div class="form-group"><label for="api-key">密钥 (直连轮询用英文逗号隔开)</label><input type="password" id="api-key" placeholder="sk-..."></div><div class="form-group"><label for="model-select">模型</label><select id="model-select"></select></div><button class="form-button" id="fetch-models-btn">拉取模型</button>

<!-- ▼▼▼ API预设功能开始 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<div class="form-group">
    <label>API预设管理</label>
    <button class="form-button" id="save-api-preset-btn" style="background-color: #28a745; margin-bottom: 10px;">保存当前配置为预设</button>
    <div id="api-presets-list" style="margin-top: 10px;">
        <!-- 预设列表将动态加载到这里 -->
    </div>
</div>
<!-- ▲▲▲ API预设功能结束 ▲▲▲ -->

<!-- ▼▼▼ 将这段代码粘贴到 API 设置页面的"保存设置"按钮上方 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
    <label for="background-activity-switch" style="margin-bottom: 0;">
        启用后台角色活动
        <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
            警告：此功能会显著增加API调用和费用！
        </p>
    </label>
    <input type="checkbox" id="background-activity-switch" style="width: auto; height: 20px;">
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 将这段代码粘贴到“启用后台角色活动”开关的下方 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label for="background-interval-input" style="margin-bottom: 0;">
        后台活动检测间隔 (秒)
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            建议值 60-300。值越大，费用越低，但角色反应越慢。
        </p>
    </label>
    <input type="number" id="background-interval-input" min="30" value="60" style="width: 80px; text-align: center;">
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 在这里新增 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label for="block-cooldown-input" style="margin-bottom: 0;">
        AI被拉黑后冷静期 (小时)
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            被拉黑超过这个时间后，AI才有几率重新申请好友。
        </p>
    </label>
    <input type="number" id="block-cooldown-input" min="0.1" step="0.1" value="1" style="width: 80px; text-align: center;">
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->

<button class="form-button" id="save-api-settings-btn">保存设置</button>
			<hr style="margin:20px 0; opacity:.3">

			<button class="form-button" id="export-data-btn">导出数据</button>

<!-- ① 普通按钮，和“导出”一个 class -->
<button class="form-button" id="import-btn">导入备份文件</button>
<hr style="margin:20px 0; opacity:.3">
<button class="form-button form-button-secondary" id="open-card-diagnostic-tool">角色卡诊断工具</button>

<!-- ② 真正的文件选择器，完全隐藏 -->
<input id="import-data-input" type="file" accept="application/json" hidden>
</div></div>
<!-- ▼▼▼ 用下面这段代码，完整替换掉你原来的 chat-list-screen ▼▼▼ -->
<div id="chat-list-screen" class="screen">
    
    <!-- 主头部 (只在消息列表显示) -->
    <div class="header" id="main-chat-list-header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
<span id="chat-list-title">消息</span>
        <div class="header-actions">
            <span class="action-btn" id="add-group-chat-btn" title="创建群聊"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M21 21L19 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
            <span class="action-btn" id="add-chat-btn">+</span>
        </div>
    </div>

    <!-- 消息列表视图 -->
    <div id="messages-view" class="chat-list-view active">
        <div id="chat-list">
            <!-- JS会在这里生成聊天列表 -->
        </div>
    </div>

    <!-- 动态界面视图 -->
    <div id="qzone-screen" class="chat-list-view">
        <div class="qzone-header">
            <span class="back-btn" id="qzone-back-btn">‹</span> <!-- 这个按钮现在只负责从动态返回 -->
            <span>好友动态</span>
        </div>
        <div class="qzone-content">
            <div class="qzone-profile-header">
                <div id="qzone-banner-container" class="qzone-banner-container">
                    <img id="qzone-banner-img" src="https://files.catbox.moe/r5heyt.gif" alt="背景">
                    <input type="file" id="qzone-banner-input" accept="image/*" hidden>
                </div>
                <div class="qzone-user-info">
                    <div id="qzone-avatar-container" class="qzone-avatar-container">
                        <img id="qzone-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" alt="头像">
                        <input type="file" id="qzone-avatar-input" accept="image/*" hidden>
                    </div>
                    <span id="qzone-nickname">{{user}}</span>
                </div>
            </div>
            <div class="qzone-actions-bar">
                <div class="action-item" id="create-shuoshuo-btn"><span>说说</span></div>
                <div class="action-item" id="create-post-btn"><span>动态</span></div>
                <div class="action-item" id="open-album-btn"><span>相册</span></div>
            </div>
            <div id="qzone-posts-list"></div>
        </div>
    </div>

    <!-- 收藏界面视图 -->
    <div id="favorites-view" class="chat-list-view">
    <div class="header"> 
        <span class="back-btn" id="favorites-back-btn">‹</span>
        <span>我的收藏</span>
        <!-- 新增的编辑按钮 -->
        <span class="action-btn" id="favorites-edit-btn">编辑</span>
    </div>

        <!-- 【新增】搜索栏容器 -->
        <div class="search-bar-container">
            <input type="search" id="favorites-search-input" placeholder="搜索收藏的标题、内容或作者...">
            <button id="favorites-search-clear-btn" class="search-clear-btn" style="display: none;">×</button>
        </div>

        <div id="favorites-list" class="list-container">
            <!-- 收藏内容将由JS动态生成在这里 -->
        </div>

<!-- 新增：收藏页底部操作栏 -->
<div id="favorites-action-bar" style="display: none;">
    <button id="favorites-delete-selected-btn" class="action-bar-btn">删除 (0)</button>
</div>

    </div>

<!-- ▼▼▼ 【全新】回忆录界面视图 ▼▼▼ -->
<div id="memories-view" class="chat-list-view">
    <div class="header"> 
        <span class="back-btn" id="memories-back-btn">‹</span>
        <span>我们的回忆</span>
            <span class="action-btn" id="add-countdown-btn">+</span>
        </div>
    <div id="memories-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        <!-- 回忆卡片将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
    
    <!-- 底部导航栏 -->
<div id="chat-list-bottom-nav">
    <div class="nav-item active" data-view="messages-view">
        <span>消息</span>
    </div>
    <div class="nav-item" data-view="qzone-screen">
        <span>动态</span>
    </div>
    <!-- ▼▼▼ 在“动态”和“收藏”之间，加入这个新页签 ▼▼▼ -->
    <div class="nav-item" data-view="memories-view">
        <span>回忆</span>
    </div>
    <!-- ▲▲▲ 添加结束 ▲▲▲ -->
    <div class="nav-item" data-view="favorites-view">
        <span>收藏</span>
    </div>
</div>
</div>
<!-- ▲▲▲ 替换区域结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="chat-list-screen" 的 div 之后 ▼▼▼ -->
<div id="album-screen" class="screen">
    <!-- 1. 页面头部，包含返回按钮和标题 -->
    <div class="header">
        <span class="back-btn" id="album-back-btn">‹</span>
        <span>我的相册</span>
        <span class="action-btn" id="create-album-btn-page">+</span>
    </div>
    
    <!-- 2. 页面内容容器 -->
    <div class="list-container">
        <div id="album-grid-page">
            <!-- 相册列表将由 JS 动态生成在这里 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="album-screen" 的 div 之后 ▼▼▼ -->
<div id="album-photos-screen" class="screen">
    <!-- 1. 页面头部 -->
    <div class="header">
        <span class="back-btn" id="album-photos-back-btn">‹</span>
        <span id="album-photos-title">相册名称</span>
        <span class="action-btn" id="album-upload-photo-btn">上传</span>
    </div>
    
    <!-- 2. 页面内容容器 -->
    <div class="list-container">
        <div id="photos-grid-page">
            <!-- 照片列表将由 JS 动态生成在这里 -->
        </div>

<!-- ▼▼▼ 请将这段新的 HTML 粘贴到所有模态框的末尾 ▼▼▼ -->
<div id="photo-viewer-modal" class="modal">
    <!-- 1. 关闭按钮 -->
    <button id="photo-viewer-close-btn">×</button>
    
    <!-- 2. 上一张照片按钮 -->
    <button id="photo-viewer-prev-btn" class="nav-arrow">‹</button>
    
    <!-- 3. 图片容器 -->
    <div class="photo-viewer-content">
        <img id="photo-viewer-image" src="" alt="全屏照片预览">
    </div>
    
    <!-- 4. 下一张照片按钮 -->
    <button id="photo-viewer-next-btn" class="nav-arrow">›</button>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

    </div>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 粘贴到 #album-photos-screen 的 div 之后 ▼▼▼ -->
<input type="file" id="album-photo-input" accept="image/*" multiple hidden>
            
<!-- ▼▼▼ 请用这【一整块】全新的代码，完整替换掉您文件中旧的 #chat-interface-screen 及其所有内容 ▼▼▼ -->
<div id="chat-interface-screen" class="screen">

    <!-- 【最终修正版】Header，已将状态栏和搜索功能正确整合 -->
    <div class="header">
        <!-- 默认控件：包含标题、状态栏和常规按钮 -->
        <div class="default-controls">
            <span class="back-btn" id="back-to-list-btn">‹</span>
            
            <!-- ▼▼▼ 【核心新增】标题和状态的容器 ▼▼▼ -->
            <div id="chat-header-title-wrapper">
                <span id="chat-header-title">聊天对象</span>
                <div id="chat-header-status">
                    <span class="status-dot"></span>
                    <span class="status-text">在线</span>
                </div>
            </div>
            <!-- ▲▲▲ 新增结束 ▲▲▲ -->

            <div class="header-actions">
                <span class="action-btn" id="show-status-diary-btn" title="状态与日记">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 21.35L10.55 20.03C5.4 15.36 2 12.27 2 8.5C2 5.42 4.42 3 7.5 3C9.24 3 10.91 3.81 12 5.08C13.09 3.81 14.76 3 16.5 3C19.58 3 22 5.41 22 8.5C22 12.27 18.6 15.36 13.45 20.03L12 21.35Z"/>
    </svg>
</span>
<span class="action-btn" id="chat-settings-btn" title="聊天设置">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
        <circle cx="5" cy="12" r="2"></circle>
        <circle cx="12" cy="12" r="2"></circle>
        <circle cx="19" cy="12" r="2"></circle>
    </svg>
</span>            </div>
        </div>

        <!-- 多选模式控件 (保持不变) -->
        <div class="selection-controls">
    <span id="selection-cancel-btn" class="circle-btn">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="white">
            <path d="M18 6L6 18M6 6L18 18" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </span>
    <span id="selection-count"></span>
    <div class="header-actions">
       <span id="selection-select-below-btn" class="action-btn circle-btn" title="选中此条以下所有消息">
           <svg width="18" height="18" viewBox="0 0 24 24" fill="white" xmlns="http://www.w3.org/2000/svg">
               <path d="M4 14H13" stroke="white" stroke-width="2" stroke-linecap="round"/>
               <path d="M4 18H13" stroke="white" stroke-width="2" stroke-linecap="round"/>
               <path d="M4 10H13" stroke="white" stroke-width="2" stroke-linecap="round"/>
               <path d="M17 6V18L20 15" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
           </svg>                       
       </span>
       <span id="selection-favorite-btn" class="action-btn circle-btn">
           <svg width="16" height="16" viewBox="0 0 24 24" fill="white">
               <path d="M12 21.35L10.55 20.03C5.4 15.36 2 12.27 2 8.5C2 5.42 4.42 3 7.5 3C9.24 3 10.91 3.81 12 5.08C13.09 3.81 14.76 3 16.5 3C19.58 3 22 5.41 22 8.5C22 12.27 18.6 15.36 13.45 20.03L12 21.35Z"/>
           </svg>
       </span>
       <span id="selection-share-btn" class="action-btn circle-btn"> 
           <svg width="16" height="16" viewBox="0 0 24 24" fill="white">
               <path d="M18 8C19.6569 8 21 6.65685 21 5C21 3.34315 19.6569 2 18 2C16.3431 2 15 3.34315 15 5C15 5.18692 15.0134 5.37099 15.0395 5.55023L8.56995 9.27511C8.05506 8.48189 7.08837 8 6 8C4.34315 8 3 9.34315 3 11C3 12.6569 4.34315 14 6 14C7.08837 14 8.05506 13.5181 8.56995 12.7249L15.0395 16.4498C15.0134 16.629 15 16.8131 15 17C15 18.6569 16.3431 20 18 20C19.6569 20 21 18.6569 21 17C21 15.3431 19.6569 14 18 14C16.9116 14 15.9449 14.4819 15.43 15.2751L8.96054 11.5502C8.98658 11.371 9 11.1869 9 11C9 10.8131 8.98658 10.629 8.96054 10.4498L15.43 6.72489C15.9449 7.51811 16.9116 8 18 8Z"/>
           </svg>
       </span>
       <span id="selection-delete-btn" class="action-btn circle-btn" style="color: #AB4D3F;">
           <svg width="16" height="16" viewBox="0 0 24 24" fill="white">
               <path d="M3 6H5H21M8 6V4C8 3.46957 8.21071 2.96086 8.58579 2.58579C8.96086 2.21071 9.46957 2 10 2H14C14.5304 2 15.0391 2.21071 15.4142 2.58579C15.7893 2.96086 16 3.46957 16 4V6M19 6V20C19 20.5304 18.7893 21.0391 18.4142 21.4142C18.0391 21.7893 17.5304 22 17 22H7C6.46957 22 5.96086 21.7893 5.58579 21.4142C5.21071 21.0391 5 20.5304 5 20V6H19ZM10 11V17M14 11V17" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
           </svg>
       </span>
    </div>
</div>
    </div>
    
    <!-- 聊天消息区域 (保持不变) -->
    <div id="chat-messages"><div id="typing-indicator">对方正在输入...</div></div>

    <!-- 输入区域 (保持不变) -->
    <div id="chat-input-area">
    <div id="reply-preview-bar">
        <div class="reply-preview-content">
            <div class="sender">回复 xxx:</div>
            <div class="text">被引用的消息内容...</div>
        </div>
        <span id="cancel-reply-btn">×</span>
    </div>

    <div id="chat-input-main-row">
    <button id="voice-message-btn" class="chat-action-icon-btn action-button" title="发送语音"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><path d="M12 19v4"></path><path d="M8 23h8"></path></svg></button>

    <textarea id="chat-input" rows="1" enterkeyhint="send"></textarea>

    <button id="open-sticker-panel-btn" class="chat-action-icon-btn action-button" title="表情面板"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg></button>
    <button id="chat-plus-btn" class="chat-action-icon-btn action-button" title="更多功能">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <line x1="12" y1="5" x2="12" y2="19"></line>
            <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
    </button>
    <div id="input-actions-wrapper">
        <button id="wait-reply-btn" title="等待回复"><img src="https://i.postimg.cc/BvT2N8SK/7c37924a1jc64c15a20bfb0d3206ae5c.png" alt="等待回复"></button>
        <button id="send-btn" class="action-button">发送</button>
    </div>
</div>

    <div id="chat-plus-panel-single" class="chat-plus-panel">
        <div class="plus-panel-container">
            <div class="plus-panel-pages">
                <div class="plus-panel-page active" data-page="1">
                    <div class="plus-panel-grid">
            <div class="plus-panel-item">
                <button id="send-photo-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg></button>
                <span class="plus-panel-label">照片</span>
            </div>
            <div class="plus-panel-item">
                <button id="upload-image-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor"><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></button>
                <span class="plus-panel-label">上传</span>
            </div>
            <div class="plus-panel-item">
                <button id="transfer-btn" class="plus-panel-icon-bg">￥</button>
                <span class="plus-panel-label">转账</span>
            </div>
            <div class="plus-panel-item">
                <button id="send-waimai-request-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path></svg></button>
                <span class="plus-panel-label">外卖</span>
            </div>
            <div class="plus-panel-item">
                <button id="video-call-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg></button>
                <span class="plus-panel-label">视频通话</span>
            </div>
            <div class="plus-panel-item">
                <button id="share-link-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg></button>
                <span class="plus-panel-label">链接</span>
            </div>
            <div class="plus-panel-item">
                <button id="diary-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"></path><path d="M8 7h8"></path><path d="M8 11h8"></path><path d="M8 15h5"></path></svg></button>
                <span class="plus-panel-label">日记</span>
            </div>
            <div class="plus-panel-item">
                <button id="regenerate-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"></path><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg></button>
                <span class="plus-panel-label">重新生成</span>
            </div>
                    </div>
                </div>
                <div class="plus-panel-page" data-page="2">
               <div class="plus-panel-grid">
    <div class="plus-panel-item">
                <button id="html-prompt-btn-panel" class="plus-panel-icon-bg">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <polyline points="14 2 14 8 20 8"></polyline>
                        <line x1="16" y1="13" x2="8" y2="13"></line>
                        <line x1="16" y1="17" x2="8" y2="17"></line>
                        <polyline points="10 9 9 9 8 9"></polyline>
                    </svg>
                </button>
                <span class="plus-panel-label">HTML</span>
            </div>
                <div class="plus-panel-item">
        <button id="location-btn-panel" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                <circle cx="12" cy="10" r="3"></circle>
            </svg>
        </button>
        <span class="plus-panel-label">位置</span>
    </div>
                <div class="plus-panel-item">
        <button id="online-offline-toggle-btn" class="plus-panel-icon-bg">
            <!-- 默认显示线上图标（门形状） -->
            <svg id="online-icon" width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M6 22V10a6 6 0 0 1 12 0v12H6z"></path>
                <path d="M10 22V16h4v6"></path>
            </svg>
            <!-- 线下图标（聊天气泡），默认隐藏 -->
            <svg id="offline-icon" width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>
            </svg>
        </button>
        <span id="online-offline-label" class="plus-panel-label">线下</span>
    </div>
                <div class="plus-panel-item">
        <button id="memory-summary-btn" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
            </svg>
        </button>
        <span class="plus-panel-label">记忆</span>
    </div>
    <div class="plus-panel-item">
        <button id="listen-together-btn-panel" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M9 18V5l12-2v13"></path>
                <circle cx="6" cy="18" r="3"></circle>
                <circle cx="18" cy="16" r="3"></circle>
            </svg>
        </button>
        <span class="plus-panel-label">一起听</span>
    </div>
    <div class="plus-panel-item">
        <button id="gift-btn-panel" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="2" y="4" width="20" height="5" rx="1"></rect>
                <rect x="4" y="9" width="16" height="10" rx="1"></rect>
                <path d="M12 4v5"></path>
                <path d="M8 4c0-1.1.9-2 2-2s2 .9 2 2-2 2-2 2-2-.9-2-2z"></path>
                <path d="M16 4c0-1.1-.9-2-2-2s-2 .9-2 2 2 2 2 2 2-.9 2-2z"></path>
            </svg>
        </button>
        <span class="plus-panel-label">礼物</span>
    </div>
    <div style="visibility: hidden;"></div>
    <div style="visibility: hidden;"></div>
</div>

                    <div class="plus-panel-grid">
                        <!-- 第二页为空 -->
                    </div>
                </div>
            </div>
        </div>
        <!-- 分页指示器 -->
        <div class="plus-panel-pagination">
            <div class="pagination-dot active" data-page="1"></div>
            <div class="pagination-dot" data-page="2"></div>
        </div>
    </div>

    <div id="chat-plus-panel-group" class="chat-plus-panel">
        <div class="plus-panel-container">
            <div class="plus-panel-pages">
                <div class="plus-panel-page active" data-page="1">
                    <div class="plus-panel-grid">
             <div class="plus-panel-item">
                <button id="send-photo-btn-group" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg></button>
                <span class="plus-panel-label">照片</span>
            </div>
            <div class="plus-panel-item">
                <button id="upload-image-btn-group" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor"><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></button>
                <span class="plus-panel-label">上传</span>
            </div>
            <div class="plus-panel-item">
                <button id="transfer-btn-group" class="plus-panel-icon-bg">￥</button>
                <span class="plus-panel-label">红包</span> </div>
            <div class="plus-panel-item">
                <button id="send-waimai-request-btn-group" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path></svg></button>
                <span class="plus-panel-label">外卖</span>
            </div>
            <div class="plus-panel-item">
                <button id="group-video-call-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg></button>
                <span class="plus-panel-label">群视频</span>
            </div>
            <div class="plus-panel-item">
                <button id="send-poll-btn" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h10"></path><path d="M6 6h.01"></path><path d="M8 12h10"></path><path d="M6 12h.01"></path><path d="M8 18h10"></path><path d="M6 18h.01"></path></svg></button>
                <span class="plus-panel-label">投票</span>
            </div>
            <div class="plus-panel-item">
                <button id="share-link-btn-group" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg></button>
                <span class="plus-panel-label">链接</span>
            </div>
            <div class="plus-panel-item">
                <button id="regenerate-btn-group" class="plus-panel-icon-bg"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"></path><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg></button>
                <span class="plus-panel-label">重新生成</span>
            </div>
                    </div>
                </div>
                <div class="plus-panel-page" data-page="2">
                    <div class="plus-panel-grid">
    <div class="plus-panel-item">
        <button id="html-prompt-btn-group-panel" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
            </svg>
        </button>
        <span class="plus-panel-label">HTML</span>
    </div>
    <div class="plus-panel-item">
        <button id="location-btn-group-panel" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                <circle cx="12" cy="10" r="3"></circle>
            </svg>
        </button>
        <span class="plus-panel-label">位置</span>
    </div>
    <div class="plus-panel-item">
        <button id="memory-summary-btn-group" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
            </svg>
        </button>
        <span class="plus-panel-label">记忆</span>
    </div>
    <div class="plus-panel-item">
        <button id="listen-together-btn-group-panel" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M9 18V5l12-2v13"></path>
                <circle cx="6" cy="18" r="3"></circle>
                <circle cx="18" cy="16" r="3"></circle>
            </svg>
        </button>
        <span class="plus-panel-label">一起听</span>
    </div>
    <div class="plus-panel-item">
        <button id="gift-btn-group-panel" class="plus-panel-icon-bg">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="2" y="4" width="20" height="5" rx="1"></rect>
                <rect x="4" y="9" width="16" height="10" rx="1"></rect>
                <path d="M12 4v5"></path>
                <path d="M8 4c0-1.1.9-2 2-2s2 .9 2 2-2 2-2 2-2-.9-2-2z"></path>
                <path d="M16 4c0-1.1-.9-2-2-2s-2 .9-2 2 2 2 2 2 2-.9 2-2z"></path>
            </svg>
        </button>
        <span class="plus-panel-label">礼物</span>
    </div>
    <div style="visibility: hidden;"></div>
    <div style="visibility: hidden;"></div>
</div>
                    <div class="plus-panel-grid">
                        <!-- 第二页为空 -->
                    </div>
                </div>
            </div>
        </div>
        <!-- 分页指示器 -->
        <div class="plus-panel-pagination">
            <div class="pagination-dot active" data-page="1"></div>
            <div class="pagination-dot" data-page="2"></div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
       

<!-- ▼▼▼ 在这里新增 ▼▼▼ -->
<div id="chat-lock-overlay">
    <div id="chat-lock-content"></div>
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->

    <!-- 表情面板 (保持不变) -->
    <div id="sticker-panel">
        <div id="sticker-panel-header">
    <div style="display: flex; gap: 10px;">
      <button class="svg-btn" id="add-sticker-btn" title="添加URL">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
          <path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        </svg>
      </button>
      <button class="svg-btn" id="upload-sticker-btn" title="本地上传">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
      <button class="svg-btn" id="batch-add-sticker-btn" title="批量添加">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
            <polyline points="14 2 14 8 20 8"></polyline>
            <line x1="9" y1="15" x2="15" y2="15"></line>
            <line x1="12" y1="12" x2="12" y2="18"></line>
        </svg>
      </button>
    </div>
</div>
        <div id="sticker-grid"></div>
    </div>
    <input type="file" id="sticker-upload-input" accept="image/*" style="display: none;">
    <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
    
    <!-- 音乐播放器 (保持不变) -->
<div id="music-player-overlay">
    <div class="music-player-window">
        
        <!-- 1. 顶部操作栏 -->
        <div class="music-player-top-actions">
            <div class="top-left-cluster">
                <button id="music-return-btn">‹</button>
                <button id="music-exit-btn">×</button>
            </div>
            <span id="music-playlist-btn">☰</span>
        </div>
        
        <!-- 2. 歌曲信息 -->
        <div id="music-time-counter">已经一起听了0.0小时</div>
        <div id="music-player-song-title">请添加歌曲</div>
        <div id="music-player-artist">...</div>
        
        <!-- 3. 【全新】歌词显示区域 -->
        <div id="music-lyrics-container">
            <div id="music-lyrics-list">
                <!-- 歌词将由JS动态生成在这里 -->
                <div class="lyric-line">♪ 暂无歌词 ♪</div>
            </div>
        </div>
        
        <!-- 4. 【全新】播放控制区的包裹容器 -->
        <div class="music-player-controls-wrapper">
            <!-- a. 新的iOS风格进度条 -->
            <div class="music-progress-bar-container">
                <div id="music-current-time" class="time-display">0:00</div>
                <div class="progress-bar">
                    <div id="music-progress-fill" class="progress-bar-fill"></div>
                </div>
                <div id="music-total-time" class="time-display">0:00</div>
            </div>
            
            <!-- b. 播放控制按钮 -->
            <div class="music-controls">
                <button id="music-prev-btn">◀</button>
                <button id="music-play-pause-btn" class="play-pause-btn">▶</button>
                <button id="music-next-btn">▶</button>
                <button id="music-mode-btn">顺序</button>
            </div>
        </div>

    </div>
</div>
    
    <div id="music-playlist-panel">
        <div class="playlist-header">
            <span class="panel-btn" id="close-playlist-btn">返回</span>
            <span>播放列表</span>
            <div>
                <span class="panel-btn" id="add-song-local-btn">本地</span>
                <span class="panel-btn" id="add-song-url-btn">URL</span>
            </div>
        </div>
        <div class="playlist-body" id="playlist-body"></div>
    </div>
    <input type="file" id="local-song-upload-input" accept="audio/*" multiple style="display: none;">
<input type="file" id="lrc-upload-input" accept=".lrc" style="display: none;">
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 用这整块代码替换你原来的 id="wallpaper-screen" ▼▼▼ -->
<div id="wallpaper-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <!-- 【核心修改1】标题改为“外观设置”，更通用 -->
        <span>外观设置</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="form-container">
        <!-- 预览界面容器 -->
        <div class="preview-container">
            <div class="preview-section">
                <div id="wallpaper-preview">点击下方上传</div>
                <button class="form-button" onclick="document.getElementById('wallpaper-upload-input').click();">上传壁纸</button>
                <input type="file" id="wallpaper-upload-input" accept="image/*">
            </div>
            <div class="preview-section">
                <div id="chat-background-preview">点击下方上传</div>
                <button class="form-button" onclick="document.getElementById('chat-background-upload-input').click();">上传全局聊天背景</button>
                <input type="file" id="chat-background-upload-input" accept="image/*">
            </div>
        </div>

<!-- ▼▼▼ 将【上面整块代码】，完整替换为下面这段【全新的代码】 ▼▼▼ -->
<div class="settings-row-container">
    <div class="form-group padding-setting-container">
        <div class="padding-setting-label">
            <label for="chat-list-padding-top-input">列表顶部边距</label>
            <p>微调列表与顶栏的间距 (px)</p>
        </div>
        <input type="number" id="chat-list-padding-top-input">
    </div>

    <div class="form-group">
        <label for="theme-toggle-switch" style="margin-bottom: 0;">夜间模式</label>
        <label class="toggle-switch">
            <input type="checkbox" id="theme-toggle-switch">
            <span class="slider"></span>
        </label>
    </div>
</div>
        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <div style="width:100%; text-align: left; margin-bottom: 15px;">
            <label style="font-weight: 500; color: var(--text-secondary);">App 图标设置</label>
        </div>
        <div id="icon-settings-grid">
            <!-- 图标设置项将由JS动态生成在这里 -->
        </div>
        
        <!-- 【核心修改3】按钮文字也改一下 -->
        <button class="form-button" id="save-wallpaper-btn" style="margin-top: 30px;">保存所有外观设置</button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】分享链接功能 HTML ▼▼▼ -->
<div id="browser-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="browser-back-btn">‹</span>
        <span id="browser-title"></span>
        <span style="width: 30px;"></span>
    </div>
    <div id="browser-content" class="list-container">
        <!-- 文章内容将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<div id="font-settings-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>字体设置</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label for="font-url-input">字体文件URL (.ttf, .otf, .woff等)</label>
            <input type="text" id="font-url-input" placeholder="https://..../font.ttf">
        </div>

        <div class="form-group">
            <label>实时预览</label>
<div id="font-preview">
                <p style="font-size: 20px; margin: 0 0 10px 0;">你好世界 Hello World</p>
                <p style="margin: 0;">这是字体预览效果，12345。</p>
            </div>
        </div>

        <button class="form-button" id="save-font-btn">保存并应用</button>
        <button class="form-button form-button-secondary" id="reset-font-btn">恢复默认字体</button>
    </div>
</div>
<!-- 1. 角色选择屏幕 (保持不变) -->
<div id="character-selection-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>选择要查看的手机</span>
        <span style="width: 30px;"></span>
    </div>
    <div id="character-selection-list" class="list-container"></div>
</div>

<!-- 2. 角色的手机“外壳”容器 -->
<div id="character-phone-container" class="screen">
    <div class="character-phone-frame">
        <div class="character-phone-notch"></div>
        <div class="character-phone-inner-screen">
            
            <!-- 2a. 角色手机的主界面 -->
            <div id="character-phone-screen" class="character-phone-page active">
                <div class="header character-phone-header">
                    <!-- 【核心修改】移除了onclick，换成data-target-page -->
                    <span class="back-btn" data-target-screen="character-selection-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span id="character-phone-owner-name"></span>
                    <div class="header-actions">
                        <span class="action-btn" id="clear-character-data-btn" title="清空数据">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-character-data-btn" title="刷新数据">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6M1 20v-6h6"/><path d="M3.51 9a9 9 0 0114.85-3.36L20.5 10M3.5 14a9 9 0 0114.85 3.36L20.5 14"/></svg>
                        </span>
                    </div>
                </div>
                <div id="character-app-grid" class="app-grid app-grid-standard" style="padding-top: 60px;"></div>
            </div>

            <!-- 2b. 角色手机 - 聊天列表 -->
            <div id="character-chat-list-screen" class="character-phone-page">
                <div class="header character-phone-header">
                    <!-- 【核心修改】移除了onclick，换成data-target-page -->
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>消息</span>
                </div>
                <div id="character-chat-list" class="list-container" style="padding: 0;"></div>
            </div>

            <!-- 2c. 角色手机 - 具体聊天记录 -->
            <div id="character-chat-history-screen" class="character-phone-page">
                <div class="header character-phone-header">
                     <!-- 【核心修改】移除了onclick，换成data-target-page -->
                     <span class="back-btn" data-target-page="character-chat-list-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span id="character-chat-with-name"></span>
                </div>
                <div id="character-chat-history-messages" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px; background-color: #e5ddd5;"></div>
            </div>

            <!-- 2d. 角色手机 - 购物车 -->
            <div id="character-shopping-cart-screen" class="character-phone-page">
                <div class="header character-phone-header">
                    <!-- 【核心修改】移除了onclick，换成data-target-page -->
                    <span class="back-btn" data-target-page="character-phone-screen">
                         <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>购物车</span>
                </div>
                <div id="character-shopping-cart-list" class="list-container"></div>
            </div>
            
            <!-- 2e. 角色手机 - 备忘录 -->
            <div id="character-memos-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <!-- 【核心修改】移除了onclick，换成data-target-page -->
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>备忘录</span>
                </div>
                <div id="character-memos-list" class="list-container"></div>
            </div>

            <!-- 2f. 角色手机 - 浏览器 -->
            <div id="character-browser-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>浏览器</span>
                </div>
                <div id="character-browser-list" class="list-container"></div>
            </div>

            <!-- 2k. 角色手机 - 浏览器搜索结果详情 -->
            <div id="character-browser-detail-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-browser-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span id="character-browser-detail-title">搜索结果</span>
                </div>
                <div id="character-browser-detail-content" class="list-container" style="padding: 15px; line-height: 1.7;"></div>
            </div>

            <!-- 2g. 角色手机 - 相册 -->
            <div id="character-album-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>相册</span>
                </div>
                <div id="character-album-grid" class="list-container"></div>
            </div>
            
            <!-- 2h. 角色手机 - 银行 -->
            <div id="character-bank-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>钱包</span>
                </div>
                <div id="character-bank-details" class="list-container"></div>
            </div>
            
            <!-- 2i. 角色手机 - 行动轨迹 -->
            <div id="character-trajectory-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>足迹</span>
                </div>
                <div id="character-trajectory-list" class="list-container"></div>
            </div>
            
            <!-- 2j. 角色手机 - APP使用记录 -->
            <div id="character-app-usage-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>屏幕使用时间</span>
                </div>
                <div id="character-app-usage-list" class="list-container"></div>
            </div>

            <!-- 2l. 角色手机 - 日记 -->
            <div id="character-diary-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>日记</span>
                    <div class="header-actions">
                        <!-- 这是日记专属的刷新按钮 -->
                        <span class="action-btn" id="generate-diary-entry-btn" title="写新日记">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                        </span>
                    </div>
                </div>
                <div id="character-diary-list" class="list-container"></div>
            </div>

        </div>
    </div>
</div>

<!-- 加载动画遮罩层 (保持不变) -->
<div id="generation-overlay" class="modal" style="background-color: rgba(0,0,0,0.6); z-index: 2000;">
    <div style="text-align: center; color: white;">
        <div id="loading-spinner" style="width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
        <p>正在同步Ta的手机数据...</p>
        <p style="font-size: 12px; opacity: 0.7;">（这可能需要一些时间，并会消耗API额度）</p>
    </div>
</div>

<!-- ▲▲▲ “查角色手机”功能HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】论坛页面 ▼▼▼ -->
<div id="forum-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>论坛</span>
        <div class="header-actions">
            <span class="action-btn" id="forum-refresh-btn" title="刷新论坛内容">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"/><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/></svg>
            </span>
        </div>
    </div>
    <div id="forum-posts-container" class="list-container">
        <!-- 论坛帖子将由JS动态生成在这里 -->
        <div class="forum-placeholder">
            <p>点击右上角的刷新按钮 🔄</p>
            <p>根据你和角色的故事生成专属论坛吧！</p>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】选择联系人以创建群聊的屏幕 ▼▼▼ -->
<div id="contact-picker-screen" class="screen">
    <div class="header">
        <div class="back-btn circle-btn" id="cancel-contact-picker-btn">
            <svg viewBox="0 0 24 24">
                <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
            </svg>
        </div>
        <span>选择联系人</span>
        <div class="save-btn circle-btn" id="confirm-contact-picker-btn" title="完成(0)">
            <svg viewBox="0 0 24 24">
                <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
            </svg>
        </div>
    </div>
    <div class="list-container" id="contact-picker-list">
        <!-- 联系人列表将由JS动态生成 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】群成员管理屏幕 ▼▼▼ -->
<div id="member-management-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-member-management">‹</span>
        <span>群成员管理</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="list-container" id="member-management-list">
        <!-- 现有成员列表会在这里动态生成 -->
    </div>
    <div id="member-management-actions">
        <button id="add-existing-contact-btn">从好友列表添加</button>
        <button id="create-new-member-btn">创建群内新成员</button>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】来电请求模态框 ▼▼▼ -->
<div id="incoming-call-modal" class="modal">
    <div class="incoming-call-content">
        <img id="caller-avatar" class="caller-avatar" src="">
        <div id="caller-name" class="caller-name"></div>
        <div class="caller-text">邀请你视频通话</div>
        <div class="incoming-call-actions">
            <div class="action-button-wrapper">
                <button id="decline-call-btn" class="call-action-btn decline"></button>
                <span>拒绝</span>
            </div>
            <div class="action-button-wrapper">
                <button id="accept-call-btn" class="call-action-btn accept"></button>
                <span>接听</span>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->

<!-- ▼▼▼ 请用这段【全新群聊兼容结构】的代码，完整替换你旧的 #video-call-screen ▼▼▼ -->
<div id="video-call-screen" class="screen">
    <!-- 1. 顶部栏 (保持不变) -->
    <div class="video-call-top-bar">
        <span id="call-timer">00:00</span>
    </div>
    
    <!-- 2. 【升级】参与者头像网格区域 -->
    <div class="video-call-avatar-area">
        <div id="participant-avatars-grid">
            <!-- JS会在这里动态生成头像 -->
        </div>
    </div>

    <!-- 3. 对话框区域 (保持不变) -->
    <div id="video-call-main" class="video-call-main">
        <!-- 对话内容会动态生成在这里 -->
    </div>
    
    <!-- 4. 【升级】底部控制栏，现在包含一个“加入”按钮 -->
    <div class="video-call-controls">
        <button id="user-speak-btn" class="control-btn speak-btn"></button>
        <button id="hang-up-btn" class="control-btn hangup-btn"></button>
        <!-- 这个按钮默认隐藏，只在用户“旁观”时显示 -->
         
        <button id="join-call-btn" class="control-btn join-btn" style="display: none;"></button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<div id="status-modal" class="modal">
    <div class="modal-content" style="width: 290px; height: auto;">
        <div class="modal-header">
            <span id="status-modal-title">TA的状态</span>
        </div>
        <div class="modal-body" style="text-align: left;">

            <div>

                <p id="status-modal-thought" style="font-size: 16px; line-height: 1.6;">...</p>
            </div>
        </div>
        
    </div>
</div>

<div id="group-status-modal" class="modal">
    <div class="modal-content" style="width: 320px; height: 60%;">
        <div class="modal-header">
            <span id="group-status-modal-title">群聊心声</span>
        </div>
        <div class="modal-body" id="group-status-list" style="padding: 15px;">
            </div>
        
    </div>
</div>

<div id="diary-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="diary-back-btn">‹</span>
        <span id="diary-screen-title">TA的日记</span>
        <button id="diary-create-btn" class="circle-btn" title="写日记">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <line x1="12" y1="5" x2="12" y2="19" stroke="white" stroke-width="2" stroke-linecap="round"></line>
                <line x1="5" y1="12" x2="19" y2="12" stroke="white" stroke-width="2" stroke-linecap="round"></line>
            </svg>
        </button>
    </div>
    <div id="diary-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        </div>
</div>

<div id="edit-diary-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header"><span>编辑日记</span></div>
        <div class="modal-body">
            <div class="form-group">
                <textarea id="diary-text-input" rows="5" placeholder="记录下此刻的心情吧..." maxlength="150"></textarea>
                <div style="text-align: right; font-size: 12px; color: #888; margin-top: 5px;" id="diary-char-counter">0 / 150</div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-diary-edit-btn">取消</button>
            <button class="save" id="save-diary-edit-btn">保存修改</button>
        </div>
    </div>
</div>

<div id="status-diary-action-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-footer">
            <button id="action-show-status">查看心声</button>
            <button id="action-show-diary">打开日记本</button>
            <button id="action-cancel-selection" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新添加】正在呼叫界面 ▼▼▼ -->
<div id="outgoing-call-screen" class="screen">
    <div class="outgoing-call-content">
        <img id="outgoing-call-avatar" class="caller-avatar" src="">
        <div id="outgoing-call-name" class="caller-name"></div>
        <div class="caller-text">正在呼叫...</div>
        <div class="outgoing-call-actions">
            <button id="cancel-call-btn" class="call-action-btn decline"></button>
            <span>取消</span>
        </div>
    </div>
</div>
<!-- ▲▲▲ 添加结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】通话记录页面 ▼▼▼ -->
<div id="call-history-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="call-history-back-btn">‹</span>
        <span id="call-history-title">通话记录</span>
        <span style="width: 30px;"></span> <!-- 占位符，保持标题居中 -->
    </div>
    <div id="call-history-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        <!-- 通话记录卡片将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

        </div>
    </div>
  
    <div id="chat-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>聊天设置</span></div><div class="modal-body"><div class="form-group" id="chat-name-group"><label for="chat-name-input">备注名 / 群名</label><input type="text" id="chat-name-input"></div>

    <!-- ▼▼▼ 请将这段新代码粘贴到“备注名”输入框的 form-group 之后 ▼▼▼ -->
    <div class="form-group" id="assign-group-section" style="display: none;"> <!-- 默认隐藏，只对单聊显示 -->
        <label for="assign-group-select">好友分组</label>
        <div style="display: flex; align-items: center; gap: 10px;">
            <select id="assign-group-select" style="flex-grow: 1;">
                <!-- 分组选项将由JS动态生成 -->
            </select>
<button id="manage-groups-btn" class="circle-btn" style="border: none; flex-shrink: 0;">
    <svg viewBox="0 0 24 24">
        <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
    </svg>
</button>  </div>
    </div>
    <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<div class="form-group" id="my-group-nickname-group"><label for="my-group-nickname-input">我的群昵称</label><input type="text" id="my-group-nickname-input"></div><div class="form-group" id="group-avatar-group"><label>群头像</label><div class="avatar-upload"><img id="group-avatar-preview"><button onclick="document.getElementById('group-avatar-input').click()">上传群头像</button><input type="file" id="group-avatar-input" accept="image/*"></div></div>
            <div class="form-group" id="world-book-link-group">
                <label>关联世界书 (线上)</label>
                <div class="custom-multiselect">
                    <div class="select-box">
                        <span class="selected-options-text">-- 点击选择 --</span>
                        <span class="arrow-down">▼</span>
                    </div>
                    <div id="world-book-checkboxes-container" class="checkboxes-container">
                    </div>
                </div>
            </div>
            <div class="form-group" id="world-book-link-group-offline" style="display: none;">
                <label>关联世界书 (线下)</label>
                <div class="custom-multiselect">
                    <div class="select-box">
                        <span class="selected-options-text">-- 点击选择 --</span>
                        <span class="arrow-down">▼</span>
                    </div>
                    <div id="world-book-checkboxes-container-offline" class="checkboxes-container">
                    </div>
                </div>
            </div>
<div class="form-group" id="ai-persona-group">
    <div class="persona-label-wrapper">
        <label for="ai-persona">对方人设 (AI Persona)</label>
        <button class="expand-persona-btn" id="import-character-card-btn" title="导入PNG角色卡" style="margin-right: 5px;">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
        </button>
        <button class="expand-persona-btn" data-target="ai" title="展开编辑器">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M15 3h6v6"></path><path d="M9 21H3v-6"></path><path d="M21 3l-7 7"></path><path d="M3 21l7-7"></path>
            </svg>
        </button>
    </div>
    <textarea id="ai-persona" rows="3"></textarea>
    <div class="persona-editor-expanded" id="ai-persona-editor-expanded" style="display: none;">
        <textarea class="expanded-textarea"></textarea>
        <div class="expanded-actions">
            <button class="cancel-expanded-btn">取消</button>
            <button class="save-expanded-btn">保存</button>
        </div>
    </div>
</div>            <div class="form-group" id="ai-avatar-group"><label>对方头像</label><div class="avatar-upload"><img id="ai-avatar-preview"><button onclick="document.getElementById('ai-avatar-input').click()" style="width: 40px; height: 40px; border-radius: 50%; background-color: #1E1E1E; border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; margin: 0 5px;" title="上传对方头像">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
        <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
    </svg>
</button><button id="manage-ai-avatar-library-btn" style="width: 40px; height: 40px; border-radius: 50%; background-color: #1E1E1E; border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; margin: 0 5px;" title="管理头像库">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
        <path d="M3 5h18v2H3zm0 6h18v2H3zm0 6h18v2H3z"/>
    </svg>
</button>
<input type="file" id="ai-avatar-input" accept="image/*"></div></div>
<div class="form-group" id="my-persona-group">
    <div class="persona-label-wrapper">
        <label for="my-persona">我的人设 (My Persona)</label>
        <button class="expand-persona-btn" data-target="my" title="展开编辑器">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M15 3h6v6"></path><path d="M9 21H3v-6"></path><path d="M21 3l-7 7"></path><path d="M3 21l7-7"></path>
            </svg>
        </button>
    </div>
    <textarea id="my-persona" rows="3"></textarea>
    <div class="persona-editor-expanded" id="my-persona-editor-expanded" style="display: none;">
        <textarea class="expanded-textarea"></textarea>
        <div class="expanded-actions">
            <button class="cancel-expanded-btn">取消</button>
            <button class="save-expanded-btn">保存</button>
        </div>
    </div>
</div><div class="form-group" id="my-avatar-group"><label>我的头像</label><div class="avatar-upload"><img id="my-avatar-preview"><button onclick="document.getElementById('my-avatar-input').click()" style="width: 40px; height: 40px; border-radius: 50%; background-color: #1E1E1E; border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; margin: 0 5px;" title="上传我的头像">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
        <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
    </svg>
</button><button id="open-persona-library-btn" style="width: 40px; height: 40px; border-radius: 50%; background-color: #1E1E1E; border: none; display: flex; align-items: center; justify-content: center; cursor: pointer; margin: 0 5px;" title="预设">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
    </svg>
</button><input type="file" id="my-avatar-input" accept="image/*"></div></div>
<div class="form-group" id="group-members-group"><label>群成员人设</label><div id="group-members-settings"></div>

    <button id="manage-members-btn" class="form-button form-button-secondary" style="margin-top: 15px;">管理群成员</button></div>
<div class="form-group">
    <label for="summarize-reserve-input">总结保留条数</label>
    <div style="display: flex; align-items: center; gap: 10px;">
        <input type="number" id="summarize-reserve-input" value="100" style="flex-grow: 1;">
    </div>
    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 8px; margin-bottom: 0;">
        执行“总结”时，保留最近的 N 条消息不被总结。
    </p>
</div>
<div class="form-group">
    <label for="memory-anchor-input">记忆锚点</label>
    <div style="display: flex; align-items: center; gap: 10px;">
    <input type="number" id="memory-anchor-input" value="0" style="flex-grow: 1;">
    <button id="refresh-memory-anchor-btn" class="circle-btn" title="刷新锚点到当前已总结位置" style="border: none; flex-shrink: 0;">
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M23 4v6h-6"></path>
            <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
        </svg>
    </button>
</div>
    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 8px; margin-bottom: 0;">
        AI将从第 N 条消息开始读取上下文。点击右侧刷新按钮可将锚点设为当前已总结消息的末尾。
    </p>
</div>
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
    <div style="flex: 1; margin-right: 15px;">
        <label style="display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-secondary);">群聊互通记忆</label>
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: -3px; margin-bottom: 0;">
            开启后，AI在生成群聊回复时会参考单聊记忆，反之亦然
        </p>
    </div>
    <label class="memory-switch">
        <input type="checkbox" id="cross-chat-memory-switch">
        <span class="memory-switch-slider"></span>
    </label>
</div>

<div class="form-group"><label for="active-reply-interval">主动回复间隔</label><input type="number" id="active-reply-interval" value="0" min="0" step="0.1" placeholder="输入小时数"><small style="color: #999; font-size: 12px; margin-top: 5px; display: block;">当距离AI上次回复超过N小时后，进入聊天会自动触发AI主动回复。最小间隔0.1小时（6分钟），输入0可关闭。</small></div>

<!-- ▼▼▼ 请将这段新代码粘贴到"聊天气泡主题"的 form-group 之后 ▼▼▼ -->
<div class="form-group">
    <label for="font-size-slider">聊天字体大小 <span id="font-size-value">13px</span></label>
    <input type="range" id="font-size-slider" min="12" max="20" step="1" value="13" style="width: 100%; margin-top: 8px;">
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新代码粘贴到“聊天字体大小”的 form-group 之后 ▼▼▼ -->

<div class="form-group">
    <div class="persona-label-wrapper">
        <label for="custom-css-input">
            自定义气泡样式 (CSS)
            <button id="reset-custom-css-btn" type="button" style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;">重置</button>
        </label>
        <button class="expand-persona-btn" data-target="css" title="展开编辑器">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M15 3h6v6"></path><path d="M9 21H3v-6"></path><path d="M21 3l-7 7"></path><path d="M3 21l7-7"></path>
            </svg>
        </button>
    </div>
    <textarea id="custom-css-input" rows="5" style="width: 100%; margin-top: 8px; font-family: monospace; font-size: 12px; resize: vertical;" placeholder="/* 示例：为“我”的气泡添加渐变背景和阴影 */
.message-bubble.user .content {
  background: linear-gradient(135deg, #a1c4fd, #c2e9fb);
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
  border-radius: 15px 4px 15px 15px;
}"></textarea>
    <div class="persona-editor-expanded" id="css-editor-expanded" style="display: none;">
        <textarea class="expanded-textarea"></textarea>
        <div class="expanded-actions">
            <button class="cancel-expanded-btn">取消</button>
            <button class="save-expanded-btn">保存</button>
        </div>
    </div>
</div>
<div class="form-group">
    <button class="form-button form-button-secondary" id="save-bubble-preset-btn" style="margin-top: -10px;">将当前样式存为预设</button>
</div>

<div class="form-group">
    <label>我的气泡预设</label>
    <div id="bubble-presets-list">
        <p class="preset-placeholder">还没有保存任何预设...</p>
    </div>
</div>
<!-- ▼▼▼ 请将这段新代码粘贴到自定义CSS输入框的 form-group 之后 ▼▼▼ -->
<div class="form-group">
    <label>实时预览</label>
    <div id="settings-preview-area">
        <!-- JS会在这里生成预览内容 -->
    </div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

            <div class="form-group">
                <label>聊天背景</label>
                <div class="bg-upload-container">
                    <button type="button" class="form-button-secondary glass-bubble-button" style="width: auto; padding: 8px 12px; margin-top: 0;" onclick="document.getElementById('bg-input').click()">上传背景图</button>
                    <button type="button" id="remove-bg-btn">移除背景</button>
                </div>
                <img id="bg-preview" class="bg-preview-img">
                <input type="file" id="bg-input" accept="image/*" style="display: none;">
            </div>
<hr style="margin: 25px 0; border: none; border-top: 1px solid #eee;">
<button class="form-button form-button-secondary" id="block-chat-btn" style="background-color: #AB4D3F; color: white; border-color: #AB4D3F;">拉黑对方</button>
<button class="form-button form-button-secondary" id="clear-chat-btn">清空聊天记录</button></div><div class="modal-footer"><button class="cancel" id="cancel-chat-settings-btn">取消</button><button class="save" id="save-chat-settings-btn">保存</button></div></div></div>
    
    <div id="persona-library-modal" class="modal"><div class="modal-content"><div class="modal-header" style="position: relative;"><span>我的人设库</span><button id="add-persona-preset-btn" class="circular-svg-button" title="添加人设预设">
        <svg viewBox="0 0 24 24">
            <path d="M12 2C13.1 2 14 2.9 14 4C14 5.1 13.1 6 12 6C10.9 6 10 5.1 10 4C10 2.9 10.9 2 12 2ZM21 9V7L19 5V6.5C19 7.3 18.3 8 17.5 8S16 7.3 16 6.5V5L14 7V9C14.6 9 15.1 9.4 15.3 10H21C21 9.4 21 9.2 21 9ZM3 9C3 9.2 3 9.4 3 10H8.7C8.9 9.4 9.4 9 10 9V7L8 5V6.5C8 7.3 7.3 8 6.5 8S5 7.3 5 6.5V5L3 7V9ZM12 10.5C11.2 10.5 10.5 11.2 10.5 12S11.2 13.5 12 13.5 13.5 12.8 13.5 12 12.8 10.5 12 10.5ZM12 15C9.8 15 8 16.8 8 19V20C8 20.6 8.4 21 9 21H15C15.6 21 16 20.6 16 20V19C16 16.8 14.2 15 12 15Z"/>
        </svg>
    </button></div><div class="modal-body"><div id="persona-library-grid"></div></div><div class="modal-footer"><button class="cancel" id="close-persona-library-btn">关闭</button></div></div></div>
    
    <div id="persona-editor-modal" class="modal"><div class="modal-content"><div class="modal-header"><span id="persona-editor-title">添加人设预设</span></div><div class="modal-body"><div class="form-group"><label>预设头像</label><div class="avatar-upload"><img id="preset-avatar-preview"><button onclick="document.getElementById('preset-avatar-input').click()">上传头像</button><input type="file" id="preset-avatar-input" accept="image/*"></div></div><div class="form-group"><label for="preset-persona-input">预设人设</label><textarea id="preset-persona-input" rows="4" placeholder="在此输入这个人设的详细设定..."></textarea></div></div><div class="modal-footer"><button class="cancel" id="cancel-persona-editor-btn">取消</button><button class="save" id="save-persona-preset-btn">保存</button></div></div></div>

    <div id="member-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>编辑群成员</span></div><div class="modal-body">
    <div class="form-group"><label for="member-name-input">名字</label><input type="text" id="member-name-input"></div>
    <div class="form-group"><label for="member-persona-input">人设</label><textarea id="member-persona-input" rows="4"></textarea></div>
    <div class="form-group"><label>头像</label><div class="avatar-upload"><img id="member-avatar-preview"><button onclick="document.getElementById('member-avatar-input').click()">上传头像</button><input type="file" id="member-avatar-input" accept="image/*"></div></div>
    </div><div class="modal-footer"><button class="cancel" id="cancel-member-settings-btn">取消</button><button class="save" id="save-member-settings-btn">保存</button></div></div></div>
    
    <div id="custom-modal-overlay">
        <div id="custom-modal">
            <div class="custom-modal-header" id="custom-modal-title"></div>
            <div class="custom-modal-body" id="custom-modal-body"></div>
            <div class="custom-modal-footer">
                <button id="custom-modal-cancel">取消</button>
                <button id="custom-modal-confirm" class="confirm-btn">确定</button>
            </div>
        </div>
    </div>
    
    <div id="preset-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="preset-action-edit">编辑预设</button>
                <button id="preset-action-delete" class="btn-danger">删除预设</button>
                <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>

    <div id="transfer-modal">
        <div class="transfer-content">
            <div class="transfer-header">给Ta一个惊喜！</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">转账金额</label>
                <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="9999" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">备注 (可选)</label>
                <input type="text" id="transfer-note" placeholder="留下你的小心思~" maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">取消</button>
                <button id="transfer-confirm-btn">确认转账</button>
            </div>
        </div>
    </div>

 <div id="battery-alert-modal">
    <div class="battery-alert-content">
        <img id="battery-alert-image" src="">
        <p id="battery-alert-text"></p>
    </div>
</div>

    <audio id="audio-player" style="display:none;"></audio>

<!-- ▼▼▼ 用下面这段【完整】的模态框代码，替换掉你现有的 id="create-post-modal" 的整个 div ▼▼▼ -->
<div id="create-post-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 90%;">
        <div class="modal-header">
            <span>发布动态</span>
        </div>
        <div class="modal-body">
            <!-- 公开文字输入区 -->
            <div class="form-group">
                <textarea id="post-public-text" rows="3" placeholder="分享新鲜事...（非必填的公开文字）"></textarea>
            </div>

            <!-- === 模式切换开关 (新增) === -->
            <div class="post-mode-switcher">
                <button id="switch-to-image-mode" class="mode-btn active">上传图片</button>
                <button id="switch-to-text-image-mode" class="mode-btn">使用文字图</button>
            </div>

<!-- ▼▼▼ 【修正后】的可见范围设置 ▼▼▼ -->
<div class="form-group">
    <label>可见范围</label>
    <div class="visibility-switcher">
    <label>
        <input type="radio" name="visibility" value="public" checked>
        <span>公开</span>
    </label>
    <label>
        <input type="radio" name="visibility" value="include">
        <span>指定分组</span>
    </label>
</div>
    <div id="post-visibility-groups" style="display: none; max-height: 120px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px;">
        <!-- 分组多选框将由JS动态生成 -->
    </div>
</div>
<!-- ▲▲▲ 修正结束 ▲▲▲ -->

            <!-- === 图片模式区域 === -->
            <div id="image-mode-content" class="post-mode-content active">
                <div class="form-group">
<div id="post-image-preview-container" class="post-image-preview-container">
                        <img id="post-image-preview" src="" alt="图片预览">
                        <button id="post-remove-image-btn">×</button>
                    </div>
                    <div class="post-image-upload-options">
                        <button id="post-upload-local-btn" class="form-button-secondary">本地上传</button>
                        <button id="post-use-url-btn" class="form-button-secondary">网络URL</button>
                        <input type="file" id="post-local-image-input" accept="image/*" hidden>
                    </div>
                </div>
                <div id="post-image-desc-group" class="form-group" style="display: none;">
                    <label>图片描述 (必填，给AI看)</label>
                    <input type="text" id="post-image-description" placeholder="简单描述图片内容，帮助AI理解">
                </div>
            </div>

            <!-- === 文字图模式区域 (新增) === -->
            <div id="text-image-mode-content" class="post-mode-content">
                <div class="form-group">
                    <label>文字图 (给AI理解用的描述，点击图片后可见)</label>
                    <textarea id="post-hidden-text" rows="4" placeholder="在这里写下图片描述..."></textarea>
                </div>
            </div>

        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-post-btn">取消</button>
            <button class="save" id="confirm-create-post-btn">发布</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这个新的模态框HTML粘贴到所有其他模态框之后 ▼▼▼ -->
<div id="group-management-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>管理好友分组</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>新建分组</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-group-name-input" placeholder="输入分组名..." style="flex-grow: 1;">
<div style="display: flex; gap: 10px; align-items: center;">
    
    <button id="add-new-group-btn" class="circle-btn" style="border: none;">
        <svg viewBox="0 0 24 24" fill="white">
            <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
        </svg>
    </button>
</div>                </div>
            </div>
            <hr style="opacity: 0.2;">
            <div id="existing-groups-list" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 分组列表将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-group-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
<!-- 新的微信风格操作面板 -->
<div id="wechat-style-actions-panel">
    <div class="wechat-action-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="#FFFFFF">
            <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
        </svg>
        <button id="edit-message-btn">编辑消息</button>
    </div>
    <div class="wechat-action-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="#FFFFFF">
            <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
        </svg>
        <button id="copy-message-btn">复制文本</button>
    </div>
    <div class="wechat-action-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="#FFFFFF">
            <path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/>
        </svg>
        <button id="recall-message-btn">撤回</button>
    </div>
    <div class="wechat-action-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="#FFFFFF">
            <path d="M6 17h3l2-4V7H5v6h3zm8 0h3l2-4V7h-6v6h3z"/>
        </svg>
        <button id="quote-message-btn">引用</button>
    </div>
    <div class="wechat-action-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="#FFFFFF">
            <path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/>
        </svg>
        <button id="select-message-btn">进入多选</button>
    </div>
</div>

<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
<div id="post-actions-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-footer">
            <button id="edit-post-btn">编辑动态</button>
            <button id="copy-post-btn">复制内容</button>           
            <button id="cancel-post-action-btn">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】可视化消息编辑器模态框 ▼▼▼ -->
<div id="message-editor-modal" class="modal">
    <div class="modal-content" style="height: 75%;">
        <div class="modal-header">
            <span>编辑与拆分消息</span>
        </div>
        <div class="modal-body" id="message-editor-body">
            <!-- 编辑器容器，JS会在这里动态生成文本框 -->
            <div id="message-editor-container"></div>
            <!-- 添加新消息的按钮 -->
            <button id="add-message-editor-block-btn" class="form-button form-button-secondary" style="margin-top: 15px;">
                [+] 添加下一条消息
            </button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-advanced-editor-btn">取消</button>
            <button class="save" id="save-advanced-editor-btn">保存更改</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】外卖请求模态框 ▼▼▼ -->
<div id="waimai-request-modal" class="modal">
    <div class="modal-content" style="width: 290px;">
        <div class="modal-header">
            <span>发起外卖代付</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="waimai-product-info">商品信息</label>
                <input type="text" id="waimai-product-info" placeholder="例如：一杯杨枝甘露">
            </div>
            <div class="form-group">
                <label for="waimai-amount">代付金额 (元)</label>
                <input type="number" id="waimai-amount" placeholder="例如：21" min="0" step="0.01">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="waimai-cancel-btn">取消</button>
            <button class="save" id="waimai-confirm-btn">发起请求</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】新建约定/倒计时模态框 ▼▼▼ -->
<div id="create-countdown-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>新建约定</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="countdown-title-input">约定标题</label>
                <input type="text" id="countdown-title-input" placeholder="例如：我的生日">
            </div>
            <div class="form-group">
                <label for="countdown-date-input">约定日期与时间</label>
                <input type="datetime-local" id="countdown-date-input">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-countdown-btn">取消</button>
            <button class="save" id="confirm-create-countdown-btn">保存约定</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】发红包模态框 ▼▼▼ -->
<div id="red-packet-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>发红包</span>
        </div>
        <div class="modal-body" style="padding: 0;">
<!-- 1. 页签切换 -->
<div class="frame-tabs">
    <div id="rp-tab-group" class="frame-tab active">拼手气红包</div>
    <div id="rp-tab-direct" class="frame-tab">专属红包</div>
</div>

            <!-- 2. 拼手气红包内容区 -->
            <div id="rp-content-group" class="frame-content" style="padding: 20px 15px;">
                <div class="form-group">
                    <label>总金额 (元)</label>
                    <input type="number" id="rp-group-amount" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label>红包个数</label>
                    <input type="number" id="rp-group-count" placeholder="填写红包个数">
                </div>
                <div class="form-group">
                    <label>祝福语</label>
                    <input type="text" id="rp-group-greeting" placeholder="恭喜发财，大吉大利！">
                </div>
                <p id="rp-group-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                <button id="send-group-packet-btn" class="form-button">塞钱进红包</button>
            </div>

            <!-- 3. 专属红包内容区 -->
            <div id="rp-content-direct" class="frame-content" style="display: none; padding: 20px 15px;">
                <div class="form-group">
                    <label>发送给</label>
                    <select id="rp-direct-receiver"></select>
                </div>
                <div class="form-group">
                    <label>金额 (元)</label>
                    <input type="number" id="rp-direct-amount" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label>祝福语</label>
                    <input type="text" id="rp-direct-greeting" placeholder="恭喜发财，大吉大利！">
                </div>
                 <p id="rp-direct-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                <button id="send-direct-packet-btn" class="form-button">塞钱进红包</button>
            </div>
        </div>
        <div class="modal-footer" style="justify-content: center;">
             <button class="cancel" id="cancel-red-packet-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】红包详情模态框 ▼▼▼ -->
<div id="red-packet-details-modal" class="modal">
    <div class="modal-content" style="width: 280px; height: auto; background-color: #f7f7f7;">
        <div class="modal-header" style="background-color: #F96259; color: white; border-bottom: none; padding-bottom: 5px;">
            <div style="text-align: center; width: 100%;">
                <div id="rp-details-sender" style="font-size: 16px;"></div>
                <div style="font-size: 13px; opacity: 0.8;">的红包</div>
            </div>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <p id="rp-details-greeting" style="text-align: center; font-size: 20px; color: #333; margin: 0 0 20px 0;"></p>
            <div id="rp-details-my-amount" style="text-align: center; display: none; margin-bottom: 20px;">
                <span style="font-size: 40px; font-weight: bold; color: #E44D44;">0.00</span>
                <span style="font-size: 18px; color: #E44D44;">元</span>
            </div>
            <div id="rp-details-summary" style="font-size: 13px; color: #8a8a8a; border-top: 1px solid #e0e0e0; padding-top: 10px;"></div>
            <div id="rp-details-list" style="max-height: 150px; overflow-y: auto; margin-top: 10px;">
                <!-- 领取详情将由JS动态生成在这里 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-rp-details-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】创建投票模态框 ▼▼▼ -->
<div id="create-poll-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>发起投票</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="poll-question-input">投票问题</label>
                <textarea id="poll-question-input" rows="2" placeholder="例如：今晚我们看什么电影？"></textarea>
            </div>
            <div class="form-group">
                <label>投票选项 (至少2项)</label>
                <div id="poll-options-container" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- 投票选项将由JS动态生成在这里 -->
                </div>
                <button id="add-poll-option-btn" class="form-button form-button-secondary" style="margin-top: 12px;">+ 添加选项</button>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-poll-btn">取消</button>
            <button class="save" id="confirm-create-poll-btn">发起投票</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】AI头像库管理模态框 ▼▼▼ -->
<div id="ai-avatar-library-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header" style="position: relative;">
            <span id="ai-avatar-library-title">对方的头像库</span>
            <button id="add-ai-avatar-btn" class="circular-svg-button" title="添加头像">
                <svg viewBox="0 0 24 24">
                    <path d="M12 12C14.21 12 16 10.21 16 8C16 5.79 14.21 4 12 4C9.79 4 8 5.79 8 8C8 10.21 9.79 12 12 12ZM12 14C9.33 14 4 15.34 4 18V20H20V18C20 15.34 14.67 14 12 14ZM19 7V4H17V7H14V9H17V12H19V9H22V7H19Z"/>
                </svg>
            </button>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <div id="ai-avatar-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
                <!-- 头像库内容将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-ai-avatar-library-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】用户分享链接模态框 ▼▼▼ -->
<div id="share-link-modal" class="modal">
    <div class="modal-content" style="width: 400px; height: 600px;">
        <div class="modal-header">
            <span>分享链接</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="link-title-input">标题</label>
                <input type="text" id="link-title-input" placeholder="输入文章或链接的标题">
            </div>
            <div class="form-group">
                <label for="link-description-input">摘要 (可选)</label>
                <textarea id="link-description-input" rows="2" placeholder="简单描述一下链接内容"></textarea>
            </div>
            <div class="form-group">
                <label for="link-source-input">来源名称 (可选)</label>
                <input type="text" id="link-source-input" placeholder="例如：知乎日报、B站">
            </div>
            <div class="form-group">
                <label for="link-content-input">完整内容 (可选，用于浏览器内显示)</label>
                <textarea id="link-content-input" rows="4" placeholder="粘贴或输入完整的文章内容"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-share-link-btn">取消</button>
            <button class="save" id="confirm-share-link-btn">分享</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】精致版转账操作弹窗 ▼▼▼ -->
<div id="transfer-actions-modal" class="modal">
    <div class="transfer-actions-content">
        <div class="transfer-actions-header">请选择操作</div>
        <div class="transfer-actions-body">
            <p>你收到了来自 <strong id="transfer-sender-name"></strong> 的一笔转账。</p>
        </div>
        <div class="transfer-actions-footer">
            <button id="transfer-action-decline" class="action-btn decline">残忍拒绝</button>
            <button id="transfer-action-accept" class="action-btn accept">开心收下</button>
        </div>
        <button id="transfer-action-cancel" class="cancel-btn">×</button>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】通话记录详情模态框 ▼▼▼ -->
<div id="call-transcript-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="transcript-modal-title">通话详情</span>
        </div>
        <div class="modal-body" id="transcript-modal-body" style="background-color: #F7F7F7;">
            <!-- 通话文字记录将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="delete-transcript-btn" style="background-color: #AB4D3F; color: white; border-color: #AB4D3F;">删除记录</button>
            <button class="save" id="close-transcript-modal-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】分享目标选择器模态框 ▼▼▼ -->
<div id="share-target-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>分享到...</span>
        </div>
        <div class="modal-body" id="share-target-list" style="padding: 0;">
            <!-- 聊天列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-share-target-btn">取消</button>
            <button class="save" id="confirm-share-target-btn">确认分享</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】分享记录查看器模态框 ▼▼▼ -->
<div id="shared-history-viewer-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="shared-history-viewer-title">聊天记录</span>
        </div>
        <div class="modal-body" id="shared-history-viewer-content" style="background-color: #F7F7F7;">
            <!-- 分享的聊天记录气泡将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-shared-history-viewer-btn" style="width:100%;">关闭</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【统一】世界书管理模态框 ▼▼▼ -->
<div id="world-book-unified-modal" class="modal">
    <div class="modal-content" style="width: 90%; max-width: 500px; height: 80%; max-height: 600px;">
        <div class="modal-header">
            <span id="unified-modal-title">世界书管理</span>
            <button id="unified-modal-close" style="background: none; border: none; font-size: 20px; cursor: pointer; color: var(--text-secondary);">&times;</button>
        </div>
        <div class="modal-body" style="overflow-y: auto;">
            <!-- 主菜单 -->
            <div id="unified-main-menu" class="unified-view">
                <div class="unified-menu-item" data-action="create-book">
                    <div class="menu-icon">📖</div>
                    <div class="menu-text">
                        <div class="menu-title">创建新世界书</div>
                        <div class="menu-desc">添加一本新的世界观设定书</div>
                    </div>
                    <div class="menu-arrow">›</div>
                </div>
                <div class="unified-menu-item" data-action="manage-categories">
                    <div class="menu-icon">📂</div>
                    <div class="menu-text">
                        <div class="menu-title">管理分类</div>
                        <div class="menu-desc">创建、删除和整理世界书分类</div>
                    </div>
                    <div class="menu-arrow">›</div>
                    
                </div>
                <div class="unified-menu-item" data-action="import-book">
                    <div class="menu-icon">📥</div>
                    <div class="menu-text">
                        <div class="menu-title">导入世界书</div>
                        <div class="menu-desc">从 .json 或 .txt 文件导入条目</div>
                    </div>
                    <div class="menu-arrow">›</div>
                </div>
            </div>
            

            <!-- 创建世界书视图 -->
            <div id="unified-create-book" class="unified-view" style="display: none;">
                <div class="form-group">
                    <label for="unified-book-name">书名</label>
                    <input type="text" id="unified-book-name" placeholder="请输入世界书的名称..." class="input-field">
                </div>
                <div class="form-group">
                    <label for="unified-book-category">分类</label>
                    <select id="unified-book-category" class="input-field">
                        <!-- 选项将由JS动态生成 -->
                    </select>
                </div>
                <div class="form-group" style="flex-grow: 1; display: flex; flex-direction: column;">
                    <label for="unified-book-content">内容</label>
                    <textarea id="unified-book-content" placeholder="在此处输入详细的世界观设定..." class="input-field" style="flex-grow: 1; min-height: 450px; resize: vertical;"></textarea>
                </div>
                <div class="unified-actions">
                </div>
            </div>

            <!-- 管理分类视图 -->
            <div id="unified-manage-categories" class="unified-view" style="display: none;">
                <div class="form-group">
                    <label>新建分类</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="unified-new-category-name" placeholder="输入分类名..." class="input-field" style="flex-grow: 1;">
                        <button id="unified-add-category-btn" class="primary-button" style="width: auto; padding: 0 20px;">+</button>
                    </div>
                </div>
                <div style="margin: 20px 0; height: 1px; background: rgba(255, 255, 255, 0.2);"></div>
                <div id="unified-categories-list" style="display: flex; flex-direction: column; gap: 12px;">
                    <!-- 分类列表将由JS动态生成 -->
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="primary-button" id="unified-modal-done" style="width: 100%;">保存世界书</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 统一模态框结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】论坛生成设置模态框 ▼▼▼ -->
<div id="forum-settings-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>生成论坛八卦</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>选择参与八卦的角色 (可多选)</label>
                <div id="forum-character-selector" style="max-height: 200px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px;">
                    <!-- 角色选项将由JS动态生成 -->
                </div>
                <div class="form-group">
    <label>选择关联的世界书 (可选)</label>
    <div id="forum-worldbook-selector" style="max-height: 150px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px;">
        </div>
</div>
            </div>
            <div class="form-group">
                <label for="forum-history-count">聊天记录上下文长度 (用于AI总结)</label>
<input type="number" id="forum-history-count" value="50" min="10" max="200">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-forum-settings-btn">取消</button>
            <button class="save" id="generate-forum-posts-btn">开始生成</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
 <div id="html-prompt-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>发送HTML生成指令</span>
        </div>
        <div class="modal-body">
            <textarea id="html-prompt-input" placeholder="在此输入您对HTML模块的要求，例如：生成二十条{{char}}最近和朋友的聊天记录..."></textarea>
        </div>
        <div class="modal-footer">
            <button id="cancel-html-prompt-btn" class="circle-btn" style="background-color: #1E1E1E;" title="取消">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="white"><path d="M18 6L6 18M6 6L18 18" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/></svg>
            </button>
            <button id="send-html-prompt-btn" class="circle-btn" style="background-color: #1E1E1E;" title="发送指令">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="white"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>
            </button>
        </div>
    </div>
</div>
 <div id="bind-character-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 70%;">
        <div class="modal-header">
            <span>绑定到角色</span>
        </div>
        <div class="modal-body">
            <div id="bind-character-grid">
                </div>
        </div>
        <div class="modal-footer" style="justify-content: space-between;">
            <button id="cancel-char-binding-btn" class="circle-btn" style="background-color: #1E1E1E;" title="取消">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="white">
                    <path d="M18 6L6 18M6 6L18 18" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
            <button id="confirm-char-binding-btn" class="circle-btn" style="background-color: #1E1E1E;" title="确认绑定">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="white">
                        <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>
                    </svg>
            </button>
        </div>
    </div>
</div>

<!-- 礼物模态框 -->
<div id="gift-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>赠送礼物</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="gift-name-input">礼物名称</label>
                <input type="text" id="gift-name-input" placeholder="请输入礼物名称">
            </div>
            <div class="form-group">
                <label for="gift-price-input">礼物价格</label>
                <input type="number" id="gift-price-input" placeholder="请输入礼物价格" min="0" step="0.01">
            </div>
            <div class="form-group" id="gift-recipient-group" style="display: none;">
                <label for="gift-recipient-select">赠送对象</label>
                <select id="gift-recipient-select">
                    <option value="random">拼手气（随机赠送）</option>
                </select>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-gift-btn">取消</button>
            <button class="save" id="send-gift-btn">赠送</button>
        </div>
    </div>
</div>

<script>
        // iOS全屏处理：动态计算实际视口高度，去除Safari地址栏影响
        function setVhProperty() {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }

        // 页面加载时设置
        setVhProperty();

        // 监听窗口大小变化（如iOS Safari地址栏显示/隐藏）
        window.addEventListener('resize', setVhProperty);
        window.addEventListener('orientationchange', () => {
            setTimeout(setVhProperty, 100); // 延迟一点确保获取正确尺寸
        });

        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models'
    // gemini如果是多个密钥, 那么随机获取一个
    function getRandomValue(str) {
        // 检查字符串是否包含逗号
        if (str.includes(',')) {
            // 用逗号分隔字符串并移除多余空格
            const arr = str.split(',').map(item => item.trim());
            // 生成随机索引 (0 到 arr.length-1)
            const randomIndex = Math.floor(Math.random() * arr.length);
            // 返回随机元素
            return arr[randomIndex];
        }
        // 没有逗号则直接返回原字符串
        return str;
    }
    function isImage(text,content) {
        let currentImageData = content.image_url.url
        // 提取Base64数据（去掉前缀）
        const base64Data = currentImageData.split(',')[1];
        // 根据图片类型获取MIME类型
        const mimeType = currentImageData.match(/^data:(.*);base64/)[1];
        return [
            {text: `${text.text}用户向你发送了一张图片`},
            {
                inline_data: {
                    mime_type: mimeType,
                    data: base64Data
                }
            }
        ]
    }

   function extractArray(text) {
        // 正则表达式模式：匹配开头的时间戳部分和后续的JSON数组
        const pattern = /^\(Timestamp: (\d+)\)(.*)$/s;
        const match = text.match(pattern);

        if (match) {
            const timestampPart = `(Timestamp: ${match[1]}) `;
            const jsonPart = match[2].trim();

            try {
                // 尝试解析JSON部分
                const parsedJson = JSON.parse(jsonPart);
                // 验证解析结果是否为数组
                if (Array.isArray(parsedJson)) {
                    return [timestampPart, parsedJson[0]];
                }
            } catch (error) {
                // 解析失败，返回原始文本
            }
        }

        // 不匹配格式或解析失败时返回原值
        return text;
    }
    function transformChatData(item) {
        let type = {
            send_and_recall:'撤回了消息',
            update_status:'更新了状态',
            change_music:'切换了歌曲',
            create_memory:'记录了回忆',
            create_countdown:'创建了约定/倒计时',
            text:'发送了文本',
            sticker:'发送了表情',
            ai_image:'发送了图片',
            voice_message:'发送了语音',
            transfer:'发起了转账',
            waimai_request:'发起了外卖请求',
            waimai_response:{
                paid:'回应了外卖-同意',
                rejected:'回应了外卖-拒绝'
            },
            video_call_request:'发起了视频通话',
            video_call_response:{
                accept:'回应了视频通话-接受',
                reject:'回应了视频通话-拒绝'
            },
            qzone_post:{
                shuoshuo:'发布了说说',
                text_image:'发布了文字图'
            },
            qzone_comment:'评论了动态',
            qzone_like:'点赞了动态',
            pat_user:'拍一拍了用户',
            block_user:'拉黑了用户',
            friend_request_response:'回应了好友申请',
            change_avatar:'更换了头像',
            share_link:'分享了链接',
            accept_transfer:'回应了转账-接受',
            decline_transfer:'回应了转账-拒绝/退款',
            send_gift:'赠送了礼物',
            accept_gift:'接受了礼物',
            decline_gift:'拒绝了礼物',
            quote_reply:'引用了回复',
            text:'',
        }
        let res = extractArray(item.content)

        if(Array.isArray(res)){
            let obj = res[1]
            let itemType = obj.type;
            let time = res[0]
            let text = type[itemType];
            if(text){
                if(itemType === 'sticker'){
                    return [{text:`${time}[${text}] 含义是:${obj.meaning}`}]
                }else if(itemType === 'send_and_recall'){
                    return [{text:`${time}[${text}] ${obj.content}`}]
                }else if(itemType === 'update_status'){
                    return [{text:`${time}[${text}] ${obj.status_text}(${obj.is_busy ? '忙碌/离开' : '空闲'})`}]
                }else if(itemType === 'change_music'){
                    return [{text:`${time}[${text}] ${obj.change_music}, 歌名是:${obj.song_name}`}]
                }else if(itemType === 'create_memory'){
                    return [{text:`${time}[${text}] ${obj.description}`}]
                }else if(itemType === 'create_countdown'){
                    return [{text:`${time}[${text}] ${obj.title}(${obj.date})`}]
                }else if(itemType === 'ai_image'){
                    return [{text:`${time}[${text}] 图片描述是:${obj.description}`}]
                }else if(itemType === 'voice_message'){
                    return [{text:`${time}[${text}] ${obj.content}`}]
                }else if(itemType === 'transfer'){
                    return [{text:`${time}[${text}] 金额是:${obj.amount} 备注是:${obj.amount}`}]
                }else if(itemType === 'waimai_request'){
                    return [{text:`${time}[${text}] 金额是:${obj.amount} 商品是:${obj.productInfo}`}]
                }else if(itemType === 'waimai_response'){
                    return [{text:`${time}[${text[obj.status]}] ${obj.status === 'paid' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'video_call_request'){
                    return [{text:`${time}[${text}]`}]
                }}else if(itemType === 'video_call_request'){
                    return [{text:`${time}[${text[obj.decision]}] ${obj.decision === 'accept' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'qzone_post'){
                    return [{text:`${time}[${text[obj.postType]}] ${obj.postType === 'shuoshuo' ? `${obj.content}` : `图片描述是:${obj.hiddenContent} ${obj.publicText ? `文案是: ${obj.publicText}` : ''}`}`}]
                }else if(itemType === 'qzone_comment'){
                    return [{text:`${time}[${text}] 评论的id是: ${obj.postId} 评论的内容是: ${obj.commentText}`}]
                }else if(itemType === 'qzone_like'){
                    return [{text:`${time}[${text}] 点赞的id是: ${obj.postId}`}]
                }else if(itemType === 'pat_user'){
                    return [{text:`${time}[${text}] ${obj.suffix ? obj.suffix  : ''}`}]
                }else if(itemType === 'block_user'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'friend_request_response'){
                    return [{text:`${time}[${text}] 结果是:${obj.decision === 'accept' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'change_avatar'){
                    return [{text:`${time}[${text}] 头像名是:${obj.name}`}]
                }else if(itemType === 'share_link'){
                    return [{text:`${time}[${text}] 文章标题是:${obj.title}  文章摘要是:${obj.description} 来源网站名是:${obj.source_name} 文章正文是:${obj.content}`}]
                }else if(itemType === 'accept_transfer'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'decline_transfer'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'send_gift'){
                    return [{text:`${time}[${text}] 礼物名称:${obj.giftName} 价格:¥${obj.giftPrice}`}]
                }else if(itemType === 'accept_gift'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'decline_gift'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'quote_reply'){
                    return [{text:`${time}[${text}] 引用的内容是:${obj.reply_content}`}]
                }else if(itemType === 'text'){
                    return [{text:`${time}${obj.content}`}]
                }
            }

if(Array.isArray(res) && res.length > 1) {
	res = `${res[0]}${res[1].content}`
}

        return [{text:res}]
    }

    function toGeminiRequestData(model, apiKey, systemInstruction, messagesForDecision,isGemini) {

	if(!isGemini){
		return undefined
	}

        // 【核心修正】在这里，我们将 'system' 角色也映射为 'user'

        let roleType = {
            user: 'user',
            assistant: 'model',
            system: 'user' // <--- 新增这一行
        }
        return {
            url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`,
            data: {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: messagesForDecision.map((item) => {
                        let  includesImages = false;
                        if(Array.isArray(item.content) && item.content.length === 2){
                              includesImages =  item.content.some((sub)=>{
                                return sub.type === 'image_url' && sub.image_url.url
                            })
                        }
                        return {
                            role: roleType[item.role], // 现在 'system' 会被正确转换为 'user'
                            parts: includesImages ? isImage(item.content[0],item.content[1]) : transformChatData(item)
                        }
                    }),
                    generationConfig: {
                        temperature: 0.8,
                    },
                    "systemInstruction": {
                        "parts": [{
                            "text": systemInstruction
                        }]
                    }
                })
            }
        }
    }
    document.addEventListener('DOMContentLoaded', () => {

        // ===================================================================
        // 1. 所有变量和常量定义
        // ===================================================================
        const db = new Dexie('GeminiChatDB');
        // --- 已修正 ---
        let state = { chats: {}, activeChatId: null, globalSettings: {}, apiConfig: {}, apiPresets: [], userStickers: [], worldBooks: [], personaPresets: [], qzoneSettings: {}, activeAlbumId: null };
        let activeCharacterPhoneId = null;
        // 线上/线下模式状态
        let offlineMode = {
            isOffline: false,  // 当前是否为线下模式
            chatHistory: {}    // 每个聊天的线下模式记录
        };
        
        // 提取消息内容的通用函数（已简化，不再处理特殊标签）
        function extractMessageContent(msg) {
            if (!msg.content) return '';
            return msg.content;
        }
        // --- 修正结束 ---
let musicState = { 
    isActive: false, 
    activeChatId: null, 
    isPlaying: false, 
    playlist: [], 
    currentIndex: -1, 
    playMode: 'order', 
    totalElapsedTime: 0, 
    timerId: null,
    // 【新增】歌词相关状态
    parsedLyrics: [],      // 当前歌曲解析后的歌词数组
    currentLyricIndex: -1  // 当前高亮的歌词行索引
};
        const audioPlayer = document.getElementById('audio-player');
        let newWallpaperBase64 = null;
        let newChatBackgroundBase64 = null;
        let isSelectionMode = false;
        let selectedMessages = new Set();
        let editingMemberId = null;
        let editingWorldBookId = null;
        let editingPersonaPresetId = null;
        // 【新增】在JS顶部，变量定义区，添加这个新变量
let editingBubblePresetId = null; // 用于追踪正在编辑的气泡预设ID

let waimaiTimers = {}; // 用于存储外卖倒计时

let activeMessageTimestamp = null;
let currentReplyContext = null; // <--- 新增这行，用来存储当前正在引用的消息信息
let activePostId = null; // <-- 新增：用于存储当前操作的动态ID

        let photoViewerState = {
            isOpen: false,
            photos: [], // 存储当前相册的所有照片URL
            currentIndex: -1, // 当前正在查看的照片索引
        };

        let unreadPostsCount = 0;

        let isFavoritesSelectionMode = false;
        let selectedFavorites = new Set()

let simulationIntervalId = null;

        const defaultAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
        const defaultMyGroupAvatar = 'https://i.postimg.cc/cLPP10Vm/4.jpg';
        const defaultGroupMemberAvatar = 'https://i.postimg.cc/VkQfgzGJ/1.jpg';
        const defaultGroupAvatar = 'https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg';
        let notificationTimeout;
        let currentForumPosts = []; // 用于存储当前论坛的帖子数据

// ▼▼▼ 在JS顶部，变量定义区，添加这个新常量 ▼▼▼
const DEFAULT_APP_ICONS = {
    'world-book': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
    'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
    'api-settings': 'https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg',
    'wallpaper': 'https://i.postimg.cc/T1j03pQr/IMG-6440.jpg',
    'font': 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg',
    'check-phone': 'https://i.postimg.cc/RVwpwr0r/IMG-8348.jpg',
    'forum': 'https://i.postimg.cc/W3y7GZ1W/IMG-6443.jpg'
};
// ▲▲▲ 添加结束 ▲▲▲

        const STICKER_REGEX = /^(https:\/\/i\.postimg\.cc\/.+|https:\/\/files\.catbox\.moe\/.+|data:image)/;
        const MESSAGE_RENDER_WINDOW = 50;
        let currentRenderedCount = 0;
        let lastKnownBatteryLevel = 1;
        let alertFlags = { hasShown40: false, hasShown20: false, hasShown10: false };
        let batteryAlertTimeout;
        const dynamicFontStyle = document.createElement('style');
        dynamicFontStyle.id = 'dynamic-font-style';
        document.head.appendChild(dynamicFontStyle);

        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('custom-modal-title');
        const modalBody = document.getElementById('custom-modal-body');
        const modalConfirmBtn = document.getElementById('custom-modal-confirm');
        const modalCancelBtn = document.getElementById('custom-modal-cancel');
        let modalResolve;

        function showCustomModal() { 
            modalOverlay.classList.add('visible'); 
        }

        function hideCustomModal() { 
            modalOverlay.classList.remove('visible'); 
            modalConfirmBtn.classList.remove('btn-danger'); 
            if (modalResolve) modalResolve(null); 
        }

        function showCustomConfirm(title, message, options = {}) {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p>${message}</p>`;
                modalCancelBtn.style.display = 'block';
                modalConfirmBtn.textContent = '确定';
                if (options.confirmButtonClass) modalConfirmBtn.classList.add(options.confirmButtonClass);
                modalConfirmBtn.onclick = () => { resolve(true); hideCustomModal(); };
                modalCancelBtn.onclick = () => { resolve(false); hideCustomModal(); };
                showCustomModal();
            });
        }

        function showCustomAlert(title, message) {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
                modalCancelBtn.style.display = 'none';
                modalConfirmBtn.textContent = '好的';
                modalConfirmBtn.onclick = () => {
                    modalCancelBtn.style.display = 'block'; 
                    modalConfirmBtn.textContent = '确定';
                    resolve(true); 
                    hideCustomModal();
                };
                showCustomModal();
            });
        }

// ▼▼▼ 请用这个【功能增强版】替换旧的 showCustomPrompt 函数 ▼▼▼
function showCustomPrompt(title, placeholder, initialValue = '', type = 'text', extraHtml = '') {
    return new Promise(resolve => {
        modalResolve = resolve;
        modalTitle.textContent = title;
        const inputId = 'custom-prompt-input';
        
        const inputHtml = type === 'textarea' 
            ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
            : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;
        
        // 【核心修改】将额外的HTML和输入框组合在一起
        modalBody.innerHTML = extraHtml + inputHtml;
        const input = document.getElementById(inputId);

        // 【核心修改】为格式助手按钮绑定事件
        modalBody.querySelectorAll('.format-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const templateStr = btn.dataset.template;
                if (templateStr) {
                    try {
                        const templateObj = JSON.parse(templateStr);
                        // 使用 null, 2 参数让JSON字符串格式化，带缩进，更易读
                        input.value = JSON.stringify(templateObj, null, 2);
                        input.focus();
                    } catch(e) {
                        console.error("解析格式模板失败:", e);
                    }
                }
            });
        });
        
        modalConfirmBtn.onclick = () => { resolve(input.value); hideCustomModal(); };
        modalCancelBtn.onclick = () => { resolve(null); hideCustomModal(); };
        showCustomModal();
        setTimeout(() => input.focus(), 100);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

        // 显示位置输入弹窗
        function showLocationModal() {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = '发送位置';
                
                // 创建位置输入表单
                modalBody.innerHTML = `
                    <div style="text-align: left; padding: 10px 0;">
                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 6px; font-size: 14px; color: #333;">当前位置（可选）</label>
                            <input type="text" id="current-location" placeholder="请输入您的当前位置" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box;">
                        </div>
                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 6px; font-size: 14px; color: #333;">距离（可选）</label>
                            <input type="text" id="distance-input" placeholder="如：1.5公里、500米" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box;">
                        </div>
                        <div style="margin-bottom: 12px;">
                            <label style="display: block; margin-bottom: 6px; font-size: 14px; color: #333;">目标地点（可选）</label>
                            <input type="text" id="target-location" placeholder="请输入目标地点" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box;">
                        </div>
                        <div style="font-size: 12px; color: #999; margin-top: 8px;">
                            提示：三个字段都是可选的，至少填写一个即可发送
                        </div>
                    </div>
                `;
                
                modalCancelBtn.style.display = 'block';
                modalConfirmBtn.textContent = '发送';
                
                modalConfirmBtn.onclick = () => {
                    const currentLocation = document.getElementById('current-location').value.trim();
                    const distance = document.getElementById('distance-input').value.trim();
                    const targetLocation = document.getElementById('target-location').value.trim();
                    
                    // 至少需要填写一个字段
                    if (!currentLocation && !distance && !targetLocation) {
                        alert('请至少填写一个位置信息');
                        return;
                    }
                    
                    const locationData = {
                        currentLocation: currentLocation || '',
                        distance: distance || '',
                        targetLocation: targetLocation || ''
                    };
                    
                    // 先关闭模态框，再发送消息
                    hideCustomModal();
                    resolve(locationData);
                    
                    // 稍微延迟发送，确保模态框完全关闭
                    setTimeout(() => {
                        sendLocationMessage(locationData);
                    }, 100);
                };
                
                modalCancelBtn.onclick = () => {
                    resolve(null);
                    hideCustomModal();
                };
                
                showCustomModal();
                
                // 自动聚焦到第一个输入框
                setTimeout(() => {
                    document.getElementById('current-location').focus();
                }, 100);
            });
        }

        // 发送位置消息
        function sendLocationMessage(locationData) {
            if (!state.activeChatId) return;
            
            const chat = state.chats[state.activeChatId];
            if (!chat) return;
            
            // 构建位置消息内容
            let locationText = '📍 位置信息\n';
            if (locationData.currentLocation) {
                locationText += `当前位置：${locationData.currentLocation}\n`;
            }
            if (locationData.distance) {
                locationText += `距离：${locationData.distance}\n`;
            }
            if (locationData.targetLocation) {
                locationText += `目标地点：${locationData.targetLocation}`;
            }
            
            // 创建位置消息
            const locationMsg = {
                role: 'user',
                content: locationText, // 直接使用文本字符串，与普通消息格式一致
                timestamp: Date.now(),
                isLocation: true, // 标记为位置消息
                locationData: locationData
            };
            
            // 添加到聊天记录
            chat.history.push(locationMsg);
            db.chats.put(chat);
            
            // 显示消息
            appendMessage(locationMsg, chat);
            scrollToBottom();
            
            // 关闭功能面板
            hidePlusPanel();
        }

        // ===================================================================
        // 2. 数据库结构定义
        // ===================================================================

db.version(28).stores({ 
    chats: '&id, isGroup, groupId, isPinned, characterPhoneData',
        apiConfig: '&id', 
        globalSettings: '&id, activeThemeId', 
        userStickers: '&id, url, name',
        worldBooks: '&id, name, categoryId', // <-- 【核心修改1】在这里添加 categoryId
        worldBookCategories: '++id, name',    // <-- 【核心修改2】新增这个表
        musicLibrary: '&id', 
        personaPresets: '&id',
        qzoneSettings: '&id',
        qzonePosts: '++id, timestamp', 
        qzoneAlbums: '++id, name, createdAt',
        qzonePhotos: '++id, albumId',
        favorites: '++id, type, timestamp, originalTimestamp',
        qzoneGroups: '++id, name',
        memories: '++id, chatId, timestamp, type, targetDate, boundCharacterId' ,
        callRecords: '++id, chatId, timestamp, customName', // <--【核心修改】在这里加上 customName
        forumPosts: '++id', // <-- 添加这一行，用于存储论坛帖子
        bubblePresets: '++id, name, css'
    });

        // ===================================================================
        // 3. 所有功能函数定义
        // ===================================================================
/**
 * 【全新】格式化微信风格的日期时间戳
 * @param {number} timestamp - 消息的时间戳
 * @returns {string} - 格式化后的时间字符串
 */
/**
 * 【升级版】格式化微信风格的日期时间戳
 * @param {number} timestamp - 消息的时间戳
 * @returns {string} - 格式化后的时间字符串
 */
function formatDateDivider(timestamp) {
    const messageDate = new Date(timestamp);
    const now = new Date();

    const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const startOfYesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);

    const hours = String(messageDate.getHours()).padStart(2, '0');
    const minutes = String(messageDate.getMinutes()).padStart(2, '0');
    const timeString = `${hours}:${minutes}`;

    if (messageDate >= startOfToday) {
        // 【新】如果是今天，只返回时间
        return timeString;
    } else if (messageDate >= startOfYesterday) {
        // 昨天
        return `昨天 ${timeString}`;
    } else {
        // 更早（非同一年时，显示年份）
        const month = messageDate.getMonth() + 1;
        const day = messageDate.getDate();
        if (messageDate.getFullYear() !== now.getFullYear()) {
            return `${messageDate.getFullYear()}年${month}月${day}日 ${timeString}`;
        }
        return `${month}月${day}日 ${timeString}`;
    }
}

/**
 * 【全新】判断两个时间戳是否在同一天
 * @param {number} ts1
 * @param {number} ts2
 * @returns {boolean}
 */
function isSameDay(ts1, ts2) {
    if (!ts1 || !ts2) return false; // 如果有一个不存在，则认为不是同一天
    const date1 = new Date(ts1);
    const date2 = new Date(ts2);
    return date1.getFullYear() === date2.getFullYear() &&
           date1.getMonth() === date2.getMonth() &&
           date1.getDate() === date2.getDate();
}

// ▼▼▼ 【全新】论坛功能核心函数 ▼▼▼

// ▼▼▼ 用这个【新版本】替换旧的 openForumSettingsModal 函数 ▼▼▼
/**
 * 打开论坛生成设置的模态框
 */
async function openForumSettingsModal() {
    const charSelector = document.getElementById('forum-character-selector');
    const wbSelector = document.getElementById('forum-worldbook-selector');
    charSelector.innerHTML = '';
    wbSelector.innerHTML = '';

    // 加载角色列表
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);
    if (characters.length === 0) {
        charSelector.innerHTML = '<p style="color: var(--text-secondary);">还没有可以讨论的角色哦~</p>';
    } else {
        characters.forEach(chat => {
            const item = document.createElement('div');
            const avatarSrc = chat.settings.aiAvatar || defaultAvatar;
            item.innerHTML = `<input type="checkbox" name="forum-char" value="${chat.id}" checked style="display: none;"><img src="${avatarSrc}" class="forum-char-avatar" alt="${chat.name}"><span class="forum-char-name">${chat.name}</span>`;
            item.classList.add('forum-char-item', 'selected');
            
            // 添加点击切换功能
            item.addEventListener('click', function(e) {
                e.preventDefault();
                const checkbox = this.querySelector('input[type="checkbox"]');
                const isSelected = this.classList.contains('selected');
                
                if (isSelected) {
                    this.classList.remove('selected');
                    checkbox.checked = false;
                } else {
                    this.classList.add('selected');
                    checkbox.checked = true;
                }
            });
            
            charSelector.appendChild(item);
        });
    }

    // 【核心新增】加载世界书列表
    const worldBooks = state.worldBooks;
    if (worldBooks.length === 0) {
        wbSelector.innerHTML = '<p style="color: var(--text-secondary);">还没有创建任何世界书。</p>';
    } else {
        worldBooks.forEach(book => {
            const item = document.createElement('div');
            item.innerHTML = `<input type="checkbox" name="forum-wb" value="${book.id}" style="display: none;"><span class="forum-wb-name">${book.name}</span>`;
            item.classList.add('forum-wb-item');
            
            // 添加点击切换功能
            item.addEventListener('click', function(e) {
                e.preventDefault();
                const checkbox = this.querySelector('input[type="checkbox"]');
                const isSelected = this.classList.contains('selected');
                
                if (isSelected) {
                    this.classList.remove('selected');
                    checkbox.checked = false;
                } else {
                    this.classList.add('selected');
                    checkbox.checked = true;
                }
            });
            
            wbSelector.appendChild(item);
        });
    }

    document.getElementById('forum-settings-modal').classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

// 【记忆功能】手动总结记忆的核心函数
async function manualSummarizeMemory(chatId) {
    const chat = state.chats[chatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;

    if (!proxyUrl || !apiKey || !model) {
        await showCustomAlert('配置错误', '请先在API设置中配置好API信息！');
        return;
    }

    // 【已修改】上下文窗口大小现在仅用于提示，不参与计算
    const CONTEXT_WINDOW = chat.settings.maxMemory || 10;

    // 筛选出所有未总结的消息
    const unsummarizedMessages = chat.history.filter(msg => !msg.isSummarized);

    // 【核心修改】读取用户设定的总结保留条数，如果没有设置则默认为100
    const reserveCount = chat.settings.summarizeReserveCount || 100;
    const messagesToSummarize = unsummarizedMessages.slice(0, -reserveCount);

    // 检查是否有需要总结的消息
    if (messagesToSummarize.length === 0) {
        await showCustomAlert('无需总结', '没有需要总结的新内容。最近的对话仍在上下文窗口内。');
        return;
    }

    try {
        // 显示加载状态
        const textarea = document.getElementById('memory-summary-textarea');
        const originalValue = textarea.value;
        textarea.value = '正在总结记忆...';
        textarea.disabled = true;

        // 构建总结Prompt
        const oldMemory = chat.memorySummary || '无';

        // 构建对话历史文本
        const userNickname = chat.isGroup ? (chat.settings.myNickname || 'User') : 'User';
        const dialogHistory = messagesToSummarize.map(msg => {
            const sender = msg.role === 'user' ? userNickname : (msg.senderName || chat.name);
            let content = msg.content;
            if (typeof content === 'string') {
                return `${sender}: ${content}`;
            } else if (Array.isArray(content)) {
                // 处理图片消息等复杂内容
                return `${sender}: [发送了图片或其他媒体内容]`;
            }
            return `${sender}: [未知消息类型]`;
        }).join('\n');

        const summaryPrompt = `你是一个专业的对话记忆管理助手。你的任务是将新的对话历史与旧的记忆摘要合并，形成一个精炼而全面的新记忆摘要。

参与者说明：
- **用户**: 在对话中，用户的名字是“${userNickname}”。
- **AI角色**: ${chat.isGroup ? '在对话中，你扮演多个AI角色。他们的名字会作为发言前缀出现在下面的对话历史中。' : `在对话中，AI角色的名字是“${chat.name}”。`}

# 总结核心铁律
1.  **【【【称呼铁律】】】**: 
    - 当需要指代用户时，【必须】使用使用具体的角色名称称呼。
    - ${chat.isGroup ? '当需要指代AI角色时，【必须】使用他们在对话历史中出现的【具体角色名】进行称呼。' : `当需要指代AI角色时，【必须】使用“${chat.name}”这个名字。`}
    - **【【【绝对禁止】】】**使用“用户”、“AI”、“玩家”、“User”或任何人称代词（你/我）来指代对话的任何一方。必须始终使用角色的具体名字。
2.  **【客观中立】**: 采用客观、中性的语言，避免任何主观感受、情感描述或价值判断。
3.  **【只记事实】**: 只记录事实性信息：对话内容、行为、事件、时间等。
4.  **【禁止推测】**: 不要添加推测、猜测或解释性内容。
5.  **【第三人称】**: 始终保持第三人称叙述视角。

## 旧的记忆摘要：
${oldMemory}

## 新的对话历史：
${dialogHistory}

请将新的对话内容与旧记忆合并，生成一个新的记忆摘要。要求：
1. 保留重要的个人信息、关系发展、重要事件
2. 去除重复和不重要的细节
3. 保持时间线的连贯性
4. 总结长度控制在500字以内
5. 用客观、简洁的语言描述
6. 只返回摘要内容，不要其他解释

新记忆摘要：`;

        const messagesPayload = [{ role: 'user', content: summaryPrompt }];
        let isGemini = proxyUrl.includes('googleapis.com');
        let geminiConfig = isGemini ? toGeminiRequestData(model, apiKey, summaryPrompt, messagesPayload, isGemini) : null;

        const response = isGemini
            ? await fetch(geminiConfig.url, { ...geminiConfig.data, mode: 'cors' })
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model, messages: messagesPayload, temperature: 0.3 }),
                mode: 'cors'
            });

        if (!response.ok) {
            throw new Error(`API请求失败: ${response.status}`);
        }

        const data = await response.json();

        let newSummary;
        if (isGemini) {
            if (!data.candidates || data.candidates.length === 0) {
                throw new Error('API返回了空的回应');
            }
            newSummary = data.candidates[0].content.parts[0].text;
        } else {
            if (!data.choices || data.choices.length === 0) {
                throw new Error('API返回了空的回应');
            }
            newSummary = data.choices[0].message.content;
        }

        // 更新记忆摘要
        chat.memorySummary = newSummary.trim();

        // 将已总结的消息标记为已总结
        messagesToSummarize.forEach(msg => {
            msg.isSummarized = true;
        });

        // 保存到数据库
        await db.chats.put(chat);

        // 更新界面
        textarea.value = newSummary.trim();
        textarea.disabled = false;

        // 更新消息统计
        updateMemoryStats(chatId);

        await showCustomAlert('总结完成', `已总结 ${messagesToSummarize.length} 条消息！`);

    } catch (error) {
        console.error('记忆总结失败:', error);

        // 恢复原始状态
        const textarea = document.getElementById('memory-summary-textarea');
        textarea.value = originalValue;
        textarea.disabled = false;

        await showCustomAlert('总结失败', `记忆总结时出错：${error.message}`);
    }
}

// 【记忆功能】简单的token计算函数（估算）
function estimateTokens(text) {
    if (!text) return 0;
    // 简单估算：中文字符按1.5个token计算，英文单词按1个token计算
    const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
    const englishWords = (text.match(/[a-zA-Z]+/g) || []).length;
    const otherChars = text.length - chineseChars - text.match(/[a-zA-Z]/g)?.length || 0;
    return Math.ceil(chineseChars * 1.5 + englishWords + otherChars * 0.5);
}

// 【记忆功能】更新消息统计显示
function updateMemoryStats(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const totalCount = chat.history.length;
    const summarizedCount = chat.history.filter(msg => msg.isSummarized === true).length;
    const pendingCount = totalCount - summarizedCount;

    // 【核心修复】从读取旧的maxMemory改为读取新的memoryAnchor
    const memoryAnchor = chat.settings.memoryAnchor || 0;
    const contextMessages = chat.history.slice(memoryAnchor);
    let contextTokens = 0;

    // 计算核心记忆的token
    if (chat.memorySummary && chat.memorySummary.trim()) {
        contextTokens += estimateTokens(chat.memorySummary);
    }

    // 计算上下文消息的token
    contextMessages.forEach(msg => {
        if (typeof msg.content === 'string') {
            contextTokens += estimateTokens(msg.content);
        } else if (Array.isArray(msg.content)) {
            // 处理图片消息等复杂内容
            msg.content.forEach(item => {
                if (item.type === 'text') {
                    contextTokens += estimateTokens(item.text || '');
                }
            });
        }
        // 添加发送者名字的token
        if (msg.senderName) {
            contextTokens += estimateTokens(msg.senderName);
        }
    });

    document.getElementById('summarized-count').textContent = summarizedCount;
    document.getElementById('pending-count').textContent = pendingCount;
    document.getElementById('total-count').textContent = totalCount;
    document.getElementById('context-token-count').textContent = contextTokens.toLocaleString();
}

// ▼▼▼ 请将下面这个完整的、优化后的函数，粘贴到您的代码中 ▼▼▼

async function generateForumPosts() {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好API信息！');
        return;
    }

    // --- 1. 获取用户配置 ---
    const selectedCharIds = Array.from(document.querySelectorAll('input[name="forum-char"]:checked')).map(cb => cb.value);
    const selectedWbIds = Array.from(document.querySelectorAll('input[name="forum-wb"]:checked')).map(cb => cb.value);
    const historyCount = parseInt(document.getElementById('forum-history-count').value) || 50;

    if (selectedCharIds.length === 0) {
        alert('请至少选择一个角色参与八卦！');
        return;
    }

    document.getElementById('forum-settings-modal').classList.remove('visible');
    const container = document.getElementById('forum-posts-container');
    const placeholder = document.createElement('div');
    placeholder.className = 'forum-placeholder';
    placeholder.innerHTML = `<p>正在连接赛博空间...</p><div class="loading-spinner" style="display: block; margin: 20px auto; border-top-color: var(--accent-color);"></div>`;
    container.innerHTML = '';
    container.appendChild(placeholder);
    
    const statusP = placeholder.querySelector('p');

    try {
        // --- 2. 准备基础资料 ---
        statusP.textContent = '正在分析角色资料与世界观...';
        const userPersona = state.chats[selectedCharIds[0]]?.settings.myPersona || '一个普通用户';
        
        const worldBookEntries = selectedWbIds.map(id => {
            const book = state.worldBooks.find(b => b.id === id);
            return book ? `### ${book.name}\n${book.content}` : '';
        }).join('\n\n');

        let rawContext = `# 核心资料\n## 用户人设\n${userPersona}\n\n`;
        if (worldBookEntries) {
            rawContext += `## 世界观设定\n${worldBookEntries}\n\n`;
        }

        selectedCharIds.forEach(id => {
            const chat = state.chats[id];
            if (chat) {
                rawContext += `## 角色: ${chat.name}\n- 人设: ${chat.settings.aiPersona}\n\n### 与 ${chat.name} 的近期聊天记录:\n`;
                const history = chat.history.slice(-historyCount).map(msg => {
                    const sender = msg.role === 'user' ? '用户' : chat.name;
                    let content = String(msg.content || '').substring(0, 100).replace(/`/g, "'").replace(/\${/g, '{');
                    if (msg.type) content = `[${msg.type}]`;
                    return `${sender}: ${content}`;
                }).join('\n');
                rawContext += `${history}\n\n`;
            }
        });

        // --- 3. 【优化流程】直接构建最终的帖子生成指令 ---
        statusP.textContent = '正在撰写论坛帖子...';
        
        const postGenerationPrompt = `你是一个论坛八卦内容生成AI。你的任务是根据提供的资料，创作10条论坛八卦帖子。

# 【【【最高指令：禁忌角色】】】
-   **绝对禁止扮演的角色**: "${state.qzoneSettings.nickname}"
-   这个名字属于【用户/玩家】，是本次模拟的观察者。在任何情况下，你的回复中【绝对不能】出现由“${state.qzoneSettings.nickname}”发布的帖子或评论。这是一个不可违背的核心铁律。
# 【【【内容核心与口吻指令】】】
1.  **内容来源**：你帖子的核心内容，必须取材于“近期聊天记录”里的【具体事件】。
2.  **口吻铁律**：你【绝对不能】像开了天眼一样直接陈述用户和角色的聊天记录内容。你必须扮演一个正在吃瓜的路人或朋友，使用**不确定、猜测、或转述**的口吻来爆料。
# 核心规则:
1.  **你的身份**: 你是【旁观者/八卦群众】或下方列表中的【AI角色】。你的任务是模拟这些人的口吻进行发帖和评论。
2.  **内容来源**: 所有内容都必须基于下面提供的【原始资料】。
3.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，包含10个帖子对象，生成的帖子正文下面至少要有三条评论，绝不能包含任何解释性文字。
4.  **帖子类型**: 你可以自由选择发布两种类型的帖子:
    - **纯文字帖 ("shuoshuo")**: 只有文字内容。
    - **图文帖 ("text_image")**: 包含一段公开的文字（可选）和一张图片（图片内容由隐藏的文字描述定义）。
5.  **身份识别与互动**: 这是一个匿名论坛，但角色和用户的ID（名字）是公开的。
    - **当一个AI角色（例如“角色A”）在自己的帖子下方发表评论时**，你扮演的其他AI角色或路人，有一定概率要表现出认出TA的样子。
    - **互动示例**: 你可以生成像“咦，这不是A本人吗？怎么亲自下场了？”、“抓住野生A一只！”或者“前排吃瓜，等正主回复。”这样的评论，来增加真实感。请自然地将这类互动分布在评论中。
# 【【【图文帖 ("text_image") 生成核心指令】】】
当你决定发布一张图片时，你必须像一个真正的八卦路人一样思考。你的“图片”应该是间接的、有想象力的证据，而不是直接的聊天记录截图。
1.  **【【【绝对禁止】】】**：直接描述或“截图”你看到的后台聊天记录。
2.  **【【【描述格式】】】**："hiddenContent" 必须清晰地说明这是一张什么样的图片，而不仅仅是重复八卦内容。

    结构如下：
    \`\`\`json
    [
      {
        "posterName": "（AI角色名或路人名）",
        "postType": "shuoshuo",
        "postContent": "帖子的纯文字内容。",
        "likes": "（随机数字）",
        "comments": [ { "commenterName": "...", "commentText": "..." } ]
      },
      {
        "posterName": "（AI角色名或路人名）",
        "postType": "text_image",
        "publicText": "（可选的、显示在图片上方的公开文字）",
        "hiddenContent": "【必填】对这张“图片”的详细文字描述。当用户点击图片时会看到这段内容。",
        "likes": "（随机数字）",
        "comments": [ { "commenterName": "...", "commentText": "..." } ]
      }
    ]
    \`\`\`

# 你需要参考的【原始资料】:
${rawContext}

现在，请严格遵守以上所有规则，特别是【最高指令】，开始你的创作。`;

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 500000);
        
        const messagesForFinal = [{ role: 'user', content: postGenerationPrompt }];
        let isGemini = proxyUrl.includes('googleapis.com');
        let geminiConfigFinal = isGemini ? toGeminiRequestData(model, apiKey, postGenerationPrompt, messagesForFinal, isGemini) : null;
        
        console.log("【论坛生成 - 优化流程】发送单次API请求...");

        const finalResponse = isGemini 
            ? await fetch(geminiConfigFinal.url, { ...geminiConfigFinal.data, mode: 'cors', signal: controller.signal })
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model, messages: messagesForFinal, temperature: 0.9 }),
                mode: 'cors',
                signal: controller.signal
            });

        clearTimeout(timeoutId);
        
        if (!finalResponse.ok) throw new Error(`[创作阶段] API 请求失败: ${finalResponse.status}`);
        const finalData = await finalResponse.json();
        
        let rawContent;
        if (isGemini) {
            if (!finalData.candidates || finalData.candidates.length === 0) throw new Error("[创作阶段] API 返回了空的回应。");
            rawContent = finalData.candidates[0].content.parts[0].text;
        } else {
            if (!finalData.choices || finalData.choices.length === 0) throw new Error("[创作阶段] API 返回了空的回应。");
            rawContent = finalData.choices[0].message.content;
        }
        
        const jsonString = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
        const posts = JSON.parse(jsonString);

        if (Array.isArray(posts)) {
            await db.forumPosts.clear();
            const addedIds = await db.forumPosts.bulkAdd(posts, { allKeys: true });
            
            const postsWithIds = posts.map((post, index) => {
                post.id = addedIds[index];
                return post;
            });
            
            currentForumPosts = postsWithIds;
            renderForumPosts(currentForumPosts);
        } else {
            throw new Error("API返回的最终结果不是一个有效的数组。");
        }

    } catch (error) {
        console.error("生成论坛帖子失败:", error);
        if (error.name === 'AbortError') {
            container.innerHTML = `<div class="forum-placeholder"><p>哎呀，生成失败了...</p><p style="font-size: 12px; color: #ff6b6b;">错误：请求超时（超过500秒无响应）。可能是网络问题或AI任务过重。</p></div>`;
        } else {
            container.innerHTML = `<div class="forum-placeholder"><p>哎呀，生成失败了...</p><p style="font-size: 12px; color: #ff6b6b; white-space: pre-wrap;">${error.message}</p></div>`;
        }
    }
}

// ▲▲▲ 粘贴到这里结束 ▲▲▲
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 【全新升级版】将帖子数据渲染到页面上
 * @param {Array} postsToRender - 帖子对象数组
 */
function renderForumPosts(postsToRender) {
    const container = document.getElementById('forum-posts-container');
    container.innerHTML = '';

    if (!postsToRender || postsToRender.length === 0) {
        // 保持占位符逻辑不变
        container.innerHTML = `<div class="forum-placeholder">
            <p>点击右上角的刷新按钮 🔄</p>
            <p>根据你和角色的故事生成专属论坛吧！</p>
        </div>`;
        return;
    }

    // 创建一个包含所有AI角色和用户信息的查找列表，用于正确显示头像
    const allCharacters = Object.values(state.chats).filter(chat => !chat.isGroup);
    const userCharacter = { name: state.qzoneSettings.nickname, settings: { myAvatar: state.qzoneSettings.avatar } };
    const characterLookup = [...allCharacters, userCharacter];

    postsToRender.forEach(post => {
        const postEl = document.createElement('div');
        postEl.className = 'forum-post-item';
        postEl.dataset.postId = post.id; // 关键：将帖子的唯一ID添加到DOM元素上

        const poster = characterLookup.find(c => c.name === post.posterName);
        const posterAvatar = poster ? (poster.settings.aiAvatar || poster.settings.myAvatar) : defaultAvatar;

        // --- ▼▼▼ 核心修复代码 ▼▼▼ ---
        // 1. 根据 postType 决定如何生成帖子内容
        let contentHtml = '';
        if (post.postType === 'text_image') {
            // 如果是图文帖，就创建图片和可选的公开文字
            const publicTextHtml = post.publicText ? `<div class="forum-post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
            const hiddenContent = post.hiddenContent || '（AI没有提供图片描述）'; // 提供一个备用描述
            contentHtml = `${publicTextHtml}<div style="margin-top:10px;"><img src="https://files.catbox.moe/d394h8.png" class="chat-image" style="cursor: pointer;" data-hidden-text="${hiddenContent}"></div>`;
        } else {
            // 否则，默认为是纯文字帖
            const postContent = post.postContent || ''; // 安全处理，防止 postContent 不存在
            contentHtml = `<div class="forum-post-content">${postContent.replace(/\n/g, '<br>')}</div>`;
        }
        // --- ▲▲▲ 核心修复代码结束 ▲▲▲ ---

        let commentsHtml = '';
        if (post.comments && post.comments.length > 0) {
            commentsHtml = post.comments.map(comment => `
                <div class="forum-comment-item">
                    <span class="commenter-name">${comment.commenterName}:</span>
                    <span class="comment-text">${comment.commentText.replace(/\n/g, '<br>')}</span>
                </div>
            `).join('');
        }
        
        if (post.isAwaitingReply) {
            commentsHtml += `
                <div class="ai-reply-loader">
                    AI正在输入<span>.</span><span>.</span><span>.</span>
                </div>
            `;
        }

        // 确保forwardCount字段存在
        if (!post.hasOwnProperty('forwardCount')) {
            post.forwardCount = 0;
        }

        postEl.innerHTML = `
            <div class="forum-post-header">
                <img src="${posterAvatar}" class="avatar">
                <span class="name">${post.posterName}</span>
            </div>
            ${contentHtml} 
            <div class="forum-post-footer">
                <div class="footer-action like-btn ${post.isLikedByUser ? 'liked' : ''}">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path></svg>
                    <span class="like-count">${post.likes}</span>
                </div>
                <div class="footer-action">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                    <span>${post.comments?.length || 0}</span>
                </div>
                <div class="footer-action forward-btn" data-post-id="${post.id}">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 17 5-5-5-5"></path><path d="m4 18v-2a4 4 0 0 1 4-4h12"></path></svg>
                    <span class="forward-count">${post.forwardCount}</span>
                </div>
            </div>
            <div class="forum-comments-section">${commentsHtml}</div>
            <div class="forum-comment-input-area">
                <input type="text" placeholder="发表你的看法...">
                <button>发送</button>
            </div>
        `;
        container.appendChild(postEl);
    });
}

/**
 * 【全新】当用户在论坛评论后，触发AI生成回复
 * @param {object} post - 被评论的帖子对象
 * @param {string} userCommentText - 用户的评论内容
 */
async function triggerAiForumReply(post, userCommentText) {
    console.log(`用户评论了帖子ID ${post.id}，正在触发AI回复...`);
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        console.warn('API配置不完整，无法触发AI回复。');
        return;
    }

    const userName = state.qzoneSettings.nickname || '我';

    // --- 【核心修改】 ---
    // 1. 获取所有可用的AI角色，而不仅仅是帖子里提到过的角色
    const allCharacters = Object.values(state.chats).filter(chat => !chat.isGroup);
    
    // 2. 将所有角色的信息都提供给AI
    const characterInfo = allCharacters.map(c => `- 角色名: ${c.name}\n  人设: ${c.settings.aiPersona}`).join('\n');
    // --- 【修改结束】 ---

    const replyPrompt = `
# 你的任务
你是一个论坛AI，负责模拟多个角色进行互动。用户刚刚在一条帖子上发表了评论，你需要生成3到5条新的、有意义的回复来回应用户的评论，让论坛看起来更活跃。

# 核心规则
【【【身份铁律】】】: 用户的昵称是"${userName}"。你【绝对、永远、在任何情况下都不能】扮演用户"${userName}"进行回复。
# 【【【格式禁令】】】
你的任务只是生成公开评论，绝对不能在评论中包含任何角色的内心想法（thought）、心理活动或OS。只写出角色会公开发表在论坛上的话。

# 【【【角色扮演核心指令：开放的论坛生态】】】
这是一个开放的论坛！任何角色都可能看到这条帖子和用户的评论。
1.  **角色池**: 你可以扮演下方“可扮演的AI角色列表”中的【任何一个角色】，也可以扮演匿名的“吃瓜网友”（网名需要随机生成）。
2.  **选角逻辑**: 请根据每个角色的性格，以及原帖与用户评论的内容，【逻辑地选择】几个最有可能被吸引过来参与讨论的角色进行回复。**即使某个角色没有在原帖中出现，只要话题和他/她相关，或者符合他/她的八卦性格，就可以让他/她出现！**
3.  **内容相关**: 你的回复必须紧密围绕"原帖内容"和"用户的评论"展开。

【【【输出格式】】】: 你的回复【必须且只能】是一个严格的JSON数组，包含3到5个评论对象。每个对象格式如下：
[
{ "commenterName": "（AI角色名或'随机网名'）", "commentText": "评论内容..." },
{ "commenterName": "（AI角色名或'随机网名'）", "commentText": "另一条评论内容..." }
]

# 【【【核心互动情景：身份识别与互动！】】】
这是一个匿名论坛，但所有人的ID（名字）都是公开的，这为八卦提供了绝佳的土壤。你的回复需要体现出这一点：

1.  **识别用户**: 正在评论的用户“${userName}”很有可能就是原帖中正在八卦讨论的“当事人/正主”。当你的AI角色回复时，有概率（20%）要表现出认出或怀疑用户身份的样子。
    - **示例**: “楼上是本人吗？”、“前排吃瓜，正主来了！”、“咦，这个ID有点眼熟……”。
2.  **识别其他AI角色**: 同样地，如果一个AI角色（比如“角色A”）在评论区非常活跃或者回复了关键信息，你扮演的其他AI角色或路人也有概率（20%）认出TA，并进行互动。
    - **示例**: “A也在啊，这下热闹了。”、“A的观点我同意！”、“楼上A的说法有点道理。”
3.  **回复身份概率**：你的主要身份是路人网友。只有很小的概率（大约八次里有一次）让AI角色本人回复用户。绝大多数回复都应来自随机路人。
请将这两类互动自然地、随机地分布在你生成的3-5条新回复中，让整个评论区看起来像真实的论坛一样充满互动和猜测。
你需要参考的上下文信息
# 可扮演的AI角色列表 (你可以从下面【所有角色】中自由选择):
${characterInfo || '(无特定AI角色，请扮演普通网友)'}

# 原帖内容:
发布者: ${post.posterName}

内容: ${post.postContent || post.publicText || '(图片动态)'}

# 用户的最新评论:
评论者: ${userName}

内容: "${userCommentText}"

现在，请严格遵守以上所有规则，开始你的创作。`;

    const messagesForApi = [{ role: 'user', content: replyPrompt }];

    try {
        let isGemini = proxyUrl.includes('googleapis.com');
        let geminiConfig = toGeminiRequestData(model, apiKey, replyPrompt, messagesForApi, isGemini);
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model, messages: messagesForApi, temperature: 0.8 })
            });

        if (!response.ok) throw new Error('AI论坛回复API调用失败');
        
        const data = await response.json();
        const aiResponseContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
        
        // 清理JSON字符串中的多余标记
        const jsonString = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
        const newComments = JSON.parse(jsonString);

        if (Array.isArray(newComments)) {
            const targetPost = currentForumPosts.find(p => p.id === post.id);
            if (targetPost) {
                // 将新评论追加到帖子的评论列表中
                newComments.forEach(comment => {
                    if (comment.commenterName && comment.commentText) {
                         targetPost.comments.push({
                            commenterName: comment.commenterName,
                            commentText: comment.commentText
                        });
                    }
                });
                
            }
        } else {
            console.warn("AI没有返回有效的评论数组:", newComments);
        }

    } catch (error) {
        console.error("触发AI论坛回复失败:", error);
    }
}


/**        
 * 根据规则格式化聊天列表的时间戳
 * @param {number} timestamp - 消息的时间戳
 * @returns {string} - 格式化后的时间字符串
 */
function formatChatListTimestamp(timestamp) {
    if (!timestamp) return ''; // 如果没有消息，则不显示时间

    const messageDate = new Date(timestamp);
    const now = new Date();

    const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const startOfYesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);

    const hours = String(messageDate.getHours()).padStart(2, '0');
    const minutes = String(messageDate.getMinutes()).padStart(2, '0');
    const timeString = `${hours}:${minutes}`;

    if (messageDate >= startOfToday) {
        // 今天：直接显示时间
        return timeString;
    } else if (messageDate >= startOfYesterday) {
        // 昨天：显示“昨天” + 时间
        return `昨天 ${timeString}`;
    } else {
        // 更早：显示 月/日 + 时间
        const month = messageDate.getMonth() + 1;
        const day = messageDate.getDate();
        return `${month}/${day} ${timeString}`;
    }
}

     function isIOS() {
         // 使用正则表达式匹配 'iPhone', 'iPad', 'iPod'
         if(/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream){
             document.body.classList.add('ios');
         }
    }

        function showScreen(screenId) {
            if (screenId === 'chat-list-screen') {
                window.renderChatListProxy(); 
                switchToChatListView('messages-view');
            }
            if (screenId === 'api-settings-screen') window.renderApiSettingsProxy();
            if (screenId === 'wallpaper-screen') window.renderWallpaperScreenProxy();
            if (screenId === 'world-book-screen') window.renderWorldBookScreenProxy();
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const screenToShow = document.getElementById(screenId);
            if (screenToShow) screenToShow.classList.add('active');
            if (screenId === 'chat-interface-screen') window.updateListenTogetherIconProxy(state.activeChatId);
            if (screenId === 'font-settings-screen') {
                document.getElementById('font-url-input').value = state.globalSettings.fontUrl || '';
                applyCustomFont(state.globalSettings.fontUrl || '', true);
            }
        }
        window.updateListenTogetherIconProxy = () => {};

        function switchToChatListView(viewId) {
            const chatListScreen = document.getElementById('chat-list-screen');
            const views = {
                'messages-view': document.getElementById('messages-view'),
                'qzone-screen': document.getElementById('qzone-screen'),
                'favorites-view': document.getElementById('favorites-view'),
        'memories-view': document.getElementById('memories-view') // <-- 新增这一行
    };
            const mainHeader = document.getElementById('main-chat-list-header');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 获取主导航栏

            if (isFavoritesSelectionMode) {
                document.getElementById('favorites-edit-btn').click(); 
            }

            // 隐藏所有视图
            Object.values(views).forEach(v => v.classList.remove('active'));
            // 显示目标视图
            if (views[viewId]) {
                views[viewId].classList.add('active');
            }

            // 更新底部导航栏高亮
            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
                item.classList.toggle('active', item.dataset.view === viewId);
            });
            
            // ▼▼▼ 【核心修正】在这里统一管理所有UI元素的显隐 ▼▼▼
            if (viewId === 'messages-view') {
                mainHeader.style.display = 'flex';
                mainBottomNav.style.display = 'flex';
            } else {
                mainHeader.style.display = 'none';
                mainBottomNav.style.display = 'none';
            }
            // ▲▲▲ 修正结束 ▲▲▲

    if (viewId !== 'memories-view') {
        activeCountdownTimers.forEach(timerId => clearInterval(timerId));
        activeCountdownTimers = [];
    }

            // 根据视图ID执行特定的渲染/更新逻辑
            switch (viewId) {
                case 'qzone-screen':
                    views['qzone-screen'].style.backgroundColor = '#F7F7F7';
                    updateUnreadIndicator(0);
                    renderQzoneScreen();
                    renderQzonePosts();
                    break;
                case 'favorites-view':
                    views['favorites-view'].style.backgroundColor = '#f9f9f9';
                    renderFavoritesScreen();
                    break;
                case 'messages-view':
                    // 如果需要，可以在这里添加返回消息列表时要执行的逻辑
                    break;
            }
        }
        
        function renderQzoneScreen() {
            if (state && state.qzoneSettings) {
                const settings = state.qzoneSettings;
                document.getElementById('qzone-nickname').textContent = settings.nickname;
                document.getElementById('qzone-avatar-img').src = settings.avatar;
                document.getElementById('qzone-banner-img').src = settings.banner;
            }
        }
        window.renderQzoneScreenProxy = renderQzoneScreen;

        async function saveQzoneSettings() {
            if (db && state.qzoneSettings) {
                await db.qzoneSettings.put(state.qzoneSettings);
            }
        }

        function formatPostTimestamp(timestamp) {
            if (!timestamp) return '';
            const now = new Date();
            const date = new Date(timestamp);
            const diffSeconds = Math.floor((now - date) / 1000);
            const diffMinutes = Math.floor(diffSeconds / 60);
            const diffHours = Math.floor(diffMinutes / 60);
            if (diffMinutes < 1) return '刚刚';
            if (diffMinutes < 60) return `${diffMinutes}分钟前`;
            if (diffHours < 24) return `${diffHours}小时前`;
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            if (now.getFullYear() === year) {
                return `${month}-${day} ${hours}:${minutes}`;
            } else {
                return `${year}-${month}-${day} ${hours}:${minutes}`;
            }
        }
// ▼▼▼ 请将下面【一整块代码】粘贴到 formatPostTimestamp 函数的下方 ▼▼▼

/**
 * 【全新添加】当用户评论动态后，触发AI生成回复
 * @param {object} post - 被评论的动态对象
 * @param {string} userCommentText - 用户的评论内容
 */
async function triggerAiPostReply(post, userCommentText) {
    if (!post || post.authorId === 'user') return;

    const aiChat = state.chats[post.authorId];
    if (!aiChat) return;

    console.log(`用户评论了动态ID ${post.id}，正在触发AI回复...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return;

    const replyPrompt = `
    # 你的任务
    你正在扮演角色“${aiChat.name}”。刚刚，用户“${state.qzoneSettings.nickname}”在你的动态(ID: ${post.id})下发表了一条评论。请你立即对此评论做出回应。

    # 上下文
    - 你的角色设定: ${aiChat.settings.aiPersona}
    - 你的动态原文: ${post.content || post.publicText || '(图片动态)'}
    - 用户的评论: "${userCommentText}"

    # 指令
    1.  你的回复内容【必须】以 "@${state.qzoneSettings.nickname}" 开头，以表示你正在回复该用户。
    2.  你的完整回复【必须且只能】是一个JSON数组，里面包含一个JSON对象，格式如下：
    [{"type": "qzone_comment", "postId": ${post.id}, "commentText": "@${state.qzoneSettings.nickname} 你的回复内容..."}]
    `;

    const messagesForApi = [{ role: 'user', content: replyPrompt }];

    try {
        let isGemini = proxyUrl.includes('googleapis.com');
        let geminiConfig = toGeminiRequestData(model, apiKey, replyPrompt, messagesForApi, isGemini);
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model, messages: messagesForApi, temperature: 0.7 })
            });

        if (!response.ok) throw new Error('AI动态回复API调用失败');
        const data = await response.json();

        const aiResponseContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
        const responseArray = parseAiResponse(aiResponseContent); 

        const commentActions = responseArray.filter(action => action.type === 'qzone_comment' && action.postId == post.id);

        if (commentActions.length > 0) {
            commentActions.forEach(action => {
                if (action.commentText) {
                    post.comments.push({ commenterName: aiChat.name, text: action.commentText, timestamp: Date.now() });
                }
            });
        } else {
             console.warn("AI没有返回有效的qzone_comment指令:", responseArray);
        }
    } catch (error) {
        console.error("触发AI动态回复失败:", error);
    }
}

// ▲▲▲ 粘贴到这里结束 ▲▲▲
// ▼▼▼ 请用这个【新版本】完整替换旧的 renderQzonePosts 函数 ▼▼▼

async function renderQzonePosts(loadingPostId = null) {
    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) return;

    const [posts, favorites] = await Promise.all([
        db.qzonePosts.orderBy('timestamp').reverse().toArray(),
        db.favorites.where('type').equals('qzone_post').toArray()
    ]);

    const favoritedPostIds = new Set(favorites.map(fav => fav.content.id));

    postsListEl.innerHTML = '';

    if (posts.length === 0) {
        postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">这里空空如也，快来发布第一条说说吧！</p>';
        return;
    }

    const userSettings = state.qzoneSettings;

    posts.forEach(post => {
        // 【核心】如果当前帖子的ID与传入的loadingPostId匹配，就给它加上等待状态
        if (loadingPostId && post.id === loadingPostId) {
            post.isAwaitingReply = true;
        }

        const postContainer = document.createElement('div');
        postContainer.className = 'qzone-post-container';
        postContainer.dataset.postId = post.id;

        const postEl = document.createElement('div');
        postEl.className = 'qzone-post-item';

        let authorAvatar = '', authorNickname = '', commentAvatar = userSettings.avatar; 

        if (post.authorId === 'user') {
            authorAvatar = userSettings.avatar;
            authorNickname = userSettings.nickname;
        } else if (state.chats[post.authorId]) {
            const authorChat = state.chats[post.authorId];
            authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
            authorNickname = authorChat.name;
        } else {
            authorAvatar = defaultAvatar;
            authorNickname = '{{char}}';
        }

        let contentHtml = '';
        const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';

        if (post.type === 'shuoshuo') {
            contentHtml = `<div class="post-content" style="margin-bottom: 10px;">${post.content.replace(/\n/g, '<br>')}</div>`;
        } 
        else if (post.type === 'image_post' && post.imageUrl) {
            contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
        } 
        else if (post.type === 'text_image') {
            contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://files.catbox.moe/d394h8.png" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://files.catbox.moe/d394h8.png" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
        }

        let likesHtml = '';
        if (post.likes && post.likes.length > 0) {
            likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${post.likes.join('、')} 觉得很赞</span></div>`;
        }

        let commentsHtml = '';
        let commentsInnerHtml = '';
        if (post.comments && post.comments.length > 0) {
            commentsInnerHtml = post.comments.map((comment, index) => {
                let namePart = comment.commenterName;
                if (post.authorId === 'user' && comment.commenterName !== state.qzoneSettings.nickname) {
                    namePart = `回复 ${state.qzoneSettings.nickname}`;
                }
                return `
                    <div class="comment-item">
                        <span class="commenter-name">${namePart}:</span>
                        <span class="comment-text">${comment.text}</span>
                        <span class="comment-delete-btn" data-comment-index="${index}">×</span>
                    </div>
                `;
            }).join('');
        }

        if (post.isAwaitingReply) {
            commentsInnerHtml += `
                <div class="ai-reply-loader">
                    AI正在输入<span>.</span><span>.</span><span>.</span>
                </div>
            `;
        }

        if (commentsInnerHtml) {
            commentsHtml = `<div class="post-comments-container">${commentsInnerHtml}</div>`;
        }

        const userNickname = state.qzoneSettings.nickname;
        const isLikedByUser = post.likes && post.likes.includes(userNickname);
        const isFavoritedByUser = favoritedPostIds.has(post.id);

        postEl.innerHTML = `
            <div class="post-header"><img src="${authorAvatar}" class="post-avatar"><div class="post-info"><span class="post-nickname">${authorNickname}</span><span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span></div>
                <div class="post-actions-btn">…</div>
            </div>
            <div class="post-main-content">${contentHtml}</div>
            <div class="post-feedback-icons">
                <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
            </div>
            ${likesHtml}
            ${commentsHtml}
            <div class="post-footer"><div class="comment-section"><img src="${commentAvatar}" class="comment-avatar"><input type="text" class="comment-input" placeholder="友善的评论是交流的起点"><div class="at-mention-popup"></div></div><button class="comment-send-btn">发送</button></div>
        `;

        const deleteAction = document.createElement('div');
        deleteAction.className = 'qzone-post-delete-action';
        deleteAction.innerHTML = '<span>删除</span>';
        postContainer.appendChild(postEl);
        postContainer.appendChild(deleteAction);
        const commentSection = postContainer.querySelector('.comment-section');
        if (commentSection) {
            commentSection.addEventListener('touchstart', (e) => e.stopPropagation());
            commentSection.addEventListener('mousedown', (e) => e.stopPropagation());
        }
        postsListEl.appendChild(postContainer);
        const commentInput = postContainer.querySelector('.comment-input');
        const popup = postContainer.querySelector('.at-mention-popup');
        commentInput.addEventListener('input', () => {
            const value = commentInput.value;
            const atMatch = value.match(/@([\p{L}\w]*)$/u);
            if (atMatch) {
                const namesToMention = new Set();
                const authorNickname = postContainer.querySelector('.post-nickname')?.textContent;
                if (authorNickname) namesToMention.add(authorNickname);
                postContainer.querySelectorAll('.commenter-name').forEach(nameEl => {
                    namesToMention.add(nameEl.textContent.replace(':', ''));
                });
                namesToMention.delete(state.qzoneSettings.nickname);
                popup.innerHTML = '';
                if (namesToMention.size > 0) {
                    const searchTerm = atMatch[1];
                    namesToMention.forEach(name => {
                        if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                            const item = document.createElement('div');
                            item.className = 'at-mention-item';
                            item.textContent = name;
                            item.addEventListener('mousedown', (e) => {
                                e.preventDefault();
                                const newText = value.substring(0, atMatch.index) + `@${name} `;
                                commentInput.value = newText;
                                popup.style.display = 'none';
                                commentInput.focus();
                            });
                            popup.appendChild(item);
                        }
                    });
                    popup.style.display = popup.children.length > 0 ? 'block' : 'none';
                } else {
                    popup.style.display = 'none';
                }
            } else {
                popup.style.display = 'none';
            }
        });
        commentInput.addEventListener('blur', () => { setTimeout(() => { popup.style.display = 'none'; }, 200); });
    });
}

// ▲▲▲ 替换到这里结束 ▲▲▲
             
// ▼▼▼ 请用下面这个【更新后的】函数，完整替换掉你代码中旧的 displayFilteredFavorites 函数 ▼▼▼

function displayFilteredFavorites(items) {
    const listEl = document.getElementById('favorites-list');
    listEl.innerHTML = '';

    if (items.length === 0) {
        const searchTerm = document.getElementById('favorites-search-input').value;
        const message = searchTerm ? '未找到相关收藏' : '你的收藏夹是空的，<br>快去动态或聊天中收藏喜欢的内容吧！';
        listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
        return;
    }

    for (const item of items) {
        const card = document.createElement('div');
        card.className = 'favorite-item-card';
        card.dataset.favid = item.id;

        let headerHtml = '', contentHtml = '', sourceText = '', footerHtml = '';

        if (item.type === 'qzone_post') {
            const post = item.content;
            sourceText = '来自动态';
            let authorAvatar = defaultAvatar, authorNickname = '未知用户';

            if (post.authorId === 'user') {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
            } else if (state.chats[post.authorId]) {
                authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                authorNickname = state.chats[post.authorId].name;
            }

            headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;
            
            const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
            if (post.type === 'shuoshuo') {
                contentHtml = `<div class="post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
            } else if (post.type === 'image_post' && post.imageUrl) {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
            } else if (post.type === 'text_image') {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://files.catbox.moe/d394h8.png" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://files.catbox.moe/d394h8.png" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
            }

            // ▼▼▼ 新增/修改的代码开始 ▼▼▼
            
            // 1. 构造点赞区域的HTML
            let likesHtml = '';
            // 检查 post 对象中是否存在 likes 数组并且不为空
            if (post.likes && post.likes.length > 0) {
                // 如果存在，就创建点赞区域的 div
                likesHtml = `
                    <div class="post-likes-section">
                        <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                        <span>${post.likes.join('、')} 觉得很赞</span>
                    </div>`;
            }

            // 2. 构造评论区域的HTML
            let commentsHtml = '';
            // 检查 post 对象中是否存在 comments 数组并且不为空
            if (post.comments && post.comments.length > 0) {
                // 如果存在，就创建评论容器，并遍历每一条评论
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach(comment => {
                    commentsHtml += `
                        <div class="comment-item">
                            <span class="commenter-name">${comment.commenterName}:</span>
                            <span class="comment-text">${comment.text}</span>
                        </div>`;
                });
                commentsHtml += '</div>';
            }

            // 3. 将点赞和评论的HTML组合到 footerHtml 中
            footerHtml = `${likesHtml}${commentsHtml}`;
            
            // ▲▲▲ 新增/修改的代码结束 ▲▲▲

} else if (item.type === 'chat_message') {
    const msg = item.content;
    const chat = state.chats[item.chatId];
    if (!chat) continue; 

    sourceText = `来自与 ${chat.name} 的聊天`;
    const isUser = msg.role === 'user';
    let senderName, senderAvatar;

    if (isUser) {
        // 用户消息的逻辑保持不变
        senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
        senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
    } else { // AI/成员消息
         if (chat.isGroup) {
            // ★★★★★ 这就是唯一的、核心的修改！ ★★★★★
            // 我们现在使用 originalName 去匹配，而不是旧的 name
            const member = chat.members.find(m => m.originalName === msg.senderName);
            // ★★★★★ 修改结束 ★★★★★
            
            senderName = msg.senderName;
            // 因为现在能正确找到 member 对象了，所以也能正确获取到他的头像
            senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
        } else {
            // 单聊的逻辑保持不变
            senderName = chat.name;
            senderAvatar = chat.settings.aiAvatar || defaultAvatar;
        }
    }

    // 后续拼接 headerHtml 和 contentHtml 的逻辑都保持不变
    headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;
    
    if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
        contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
    } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
    } else {
        contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
    }
}
        
        // ▼▼▼ 修改最终的HTML拼接，加入 footerHtml ▼▼▼
        card.innerHTML = `
            <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
            <div class="fav-card-content">${contentHtml}</div>
            ${footerHtml}`; // <-- 把我们新创建的 footerHtml 放在这里
            
        listEl.appendChild(card);
    }
}

// ▲▲▲ 替换区域结束 ▲▲▲

        /**
         * 【重构后的函数】: 负责准备数据并触发渲染
         */
        async function renderFavoritesScreen() {
            // 1. 从数据库获取最新数据并缓存
            allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();
            
            // 2. 清空搜索框并隐藏清除按钮
            const searchInput = document.getElementById('favorites-search-input');
            const clearBtn = document.getElementById('favorites-search-clear-btn');
            searchInput.value = '';
            clearBtn.style.display = 'none';

            // 3. 显示所有收藏项
            displayFilteredFavorites(allFavoriteItems);
        }

        // ▲▲▲ 粘贴结束 ▲▲▲

        function resetCreatePostModal() {
            document.getElementById('post-public-text').value = '';
            document.getElementById('post-image-preview').src = '';
            document.getElementById('post-image-description').value = '';
            document.getElementById('post-image-preview-container').classList.remove('visible');
            document.getElementById('post-image-desc-group').style.display = 'none';
            document.getElementById('post-local-image-input').value = '';
            document.getElementById('post-hidden-text').value = '';
            document.getElementById('switch-to-image-mode').click();
        }

// 用下面这个更新后的版本，完整替换您旧的 exportBackup 函数
async function exportBackup() {
    try {
        const backupData = {
            version: 1, 
            timestamp: Date.now()
        };

        const [
            chats, worldBooks, userStickers, apiConfig, globalSettings,
            apiPresets, personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
            memories,
            worldBookCategories,
            forumPosts, // <-- 在这里添加 forumPosts
            bubblePresets // <-- 添加气泡预设
        ] = await Promise.all([
            db.chats.toArray(),
            db.worldBooks.toArray(),
            db.userStickers.toArray(),
            db.apiConfig.get('main'),
            db.globalSettings.get('main'),
            db.apiPresets.toArray(),
            db.personaPresets.toArray(),
            db.musicLibrary.get('main'),
            db.qzoneSettings.get('main'),
            db.qzonePosts.toArray(),
            db.qzoneAlbums.toArray(),
            db.qzonePhotos.toArray(),
            db.favorites.toArray(),
            db.qzoneGroups.toArray(),
            db.memories.toArray(),
            db.worldBookCategories.toArray(),
            db.forumPosts.toArray(), // <-- 在这里也添加
            db.bubblePresets.toArray() // <-- 添加气泡预设数据获取
        ]);

        Object.assign(backupData, {
            chats, worldBooks, userStickers, apiConfig, globalSettings,
            apiPresets, personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
            memories,
            worldBookCategories,
            forumPosts, // <-- 最后在这里也添加
            bubblePresets // <-- 添加气泡预设到备份数据
        });
        
        const blob = new Blob(
            [JSON.stringify(backupData, null, 2)], 
            { type: 'application/json' }
        );
        const url = URL.createObjectURL(blob);
        const link = Object.assign(document.createElement('a'), {
            href: url,
            download: `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
        });
        link.click();
        URL.revokeObjectURL(url);
        
        await showCustomAlert('导出成功', '已成功导出所有数据！');

    } catch (error) {
        console.error("导出数据时出错:", error);
        await showCustomAlert('导出失败', `发生了一个错误: ${error.message}`);
    }
}

// 用下面这个更新后的版本，完整替换您旧的 importBackup 函数
async function importBackup(file) {
    if (!file) return;

    const confirmed = await showCustomConfirm(
        '严重警告！',
        '导入备份将完全覆盖您当前的所有数据，包括聊天、动态、设置等。此操作不可撤销！您确定要继续吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        await db.transaction('rw', db.tables, async () => {
            for (const table of db.tables) {
                await table.clear();
            }

            if (Array.isArray(data.chats)) await db.chats.bulkPut(data.chats);
            if (Array.isArray(data.worldBooks)) await db.worldBooks.bulkPut(data.worldBooks);
            if (Array.isArray(data.worldBookCategories)) await db.worldBookCategories.bulkPut(data.worldBookCategories);
            if (Array.isArray(data.userStickers)) await db.userStickers.bulkPut(data.userStickers);
            if (Array.isArray(data.apiPresets)) await db.apiPresets.bulkPut(data.apiPresets);
            if (Array.isArray(data.personaPresets)) await db.personaPresets.bulkPut(data.personaPresets);
            if (Array.isArray(data.qzonePosts)) await db.qzonePosts.bulkPut(data.qzonePosts);
            if (Array.isArray(data.qzoneAlbums)) await db.qzoneAlbums.bulkPut(data.qzoneAlbums);
            if (Array.isArray(data.qzonePhotos)) await db.qzonePhotos.bulkPut(data.qzonePhotos);
            if (Array.isArray(data.favorites)) await db.favorites.bulkPut(data.favorites);
            if (Array.isArray(data.qzoneGroups)) await db.qzoneGroups.bulkPut(data.qzoneGroups);
            if (Array.isArray(data.memories)) await db.memories.bulkPut(data.memories);
            if (Array.isArray(data.forumPosts)) await db.forumPosts.bulkPut(data.forumPosts); // <-- 添加这一行
            if (Array.isArray(data.bubblePresets)) await db.bubblePresets.bulkPut(data.bubblePresets); // <-- 添加气泡预设导入

            if (data.apiConfig) await db.apiConfig.put(data.apiConfig);
            if (data.globalSettings) await db.globalSettings.put(data.globalSettings);
            if (data.musicLibrary) await db.musicLibrary.put(data.musicLibrary);
            if (data.qzoneSettings) await db.qzoneSettings.put(data.qzoneSettings);
        });

        await showCustomAlert('导入成功', '所有数据已成功恢复！应用即将刷新以应用所有更改。');
        
        setTimeout(() => {
            window.location.reload();
        }, 1500);

    } catch (error) {
        console.error("导入数据时出错:", error);
        await showCustomAlert('导入失败', `文件格式不正确或数据已损坏: ${error.message}`);
    }
}

        // 优化字体预览：添加缓存机制
        let lastPreviewFontUrl = '';
        let previewStyleElement = null;
        
        function applyCustomFont(fontUrl, isPreviewOnly = false) {
            if (!fontUrl) {
                dynamicFontStyle.innerHTML = '';
                const fontPreview = document.getElementById('font-preview');
                if (fontPreview) fontPreview.style.fontFamily = '';
                lastPreviewFontUrl = '';
                return;
            }
            
            const fontName = 'custom-user-font';
            
            if (isPreviewOnly) {
                // 优化：避免重复操作相同URL
                if (lastPreviewFontUrl === fontUrl) return;
                lastPreviewFontUrl = fontUrl;
                
                // 优化：复用样式元素，避免重复创建
                if (!previewStyleElement) {
                    previewStyleElement = document.createElement('style');
                    previewStyleElement.id = 'preview-font-style';
                    document.head.appendChild(previewStyleElement);
                }
                
                // 优化：使用更快的 font-display: optional 和预加载策略
                const newStyle = `
                    @font-face {
                      font-family: '${fontName}';
                      src: url('${fontUrl}');
                      font-display: optional;
                    }`;
                
                previewStyleElement.innerHTML = newStyle;
                const fontPreview = document.getElementById('font-preview');
                if (fontPreview) {
                    fontPreview.style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
                }
            } else {
                const newStyle = `
                    @font-face {
                      font-family: '${fontName}';
                      src: url('${fontUrl}');
                      font-display: swap;
                    }`;
                dynamicFontStyle.innerHTML = `
                ${newStyle}
                body, #chat-messages {
                  font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                }`;
            }
        }

        async function resetToDefaultFont() {
            dynamicFontStyle.innerHTML = ''; 
            state.globalSettings.fontUrl = '';
            await db.globalSettings.put(state.globalSettings);
            document.getElementById('font-url-input').value = '';
            document.getElementById('font-preview').style.fontFamily = '';
            alert('已恢复默认字体。');
        }

async function loadAllDataFromDB() {
    // ▼▼▼ 【核心修改在这里】 ▼▼▼
    const [
        chatsArr,
        apiConfig,
        globalSettings,
        userStickers,
        apiPresets,
        worldBooks,
        musicLib,
        personaPresets,
        qzoneSettings,
        initialFavorites // 将 initialFavorites 加入到解构赋值中
    ] = await Promise.all([
        db.chats.toArray(),
        db.apiConfig.get('main'),
        db.globalSettings.get('main'),
        db.userStickers.toArray(),
        db.apiPresets.toArray(),
        db.worldBooks.toArray(),
        db.musicLibrary.get('main'),
        db.personaPresets.toArray(),
        db.qzoneSettings.get('main'),
        db.favorites.orderBy('timestamp').reverse().toArray() // 确保这一行在 Promise.all 的数组参数内
    ]);
    // ▲▲▲ 【修改结束】 ▲▲▲

    state.chats = chatsArr.reduce((acc, chat) => {

    if (typeof chat.unreadCount === 'undefined') {
        chat.unreadCount = 0; // 如果这个聊天对象没有 unreadCount 属性，就给它初始化为 0
    }

        // ★★★【核心重构：数据迁移脚本】★★★
        // 检查是否是群聊，并且其成员对象使用的是旧的 `name` 结构
        if (chat.isGroup && chat.members && chat.members.length > 0 && chat.members[0].name) {
            console.log(`检测到旧版群聊数据 for "${chat.name}"，正在执行迁移...`);
            chat.members.forEach(member => {
                // 如果这个成员对象没有 originalName，说明是旧数据
                if (typeof member.originalName === 'undefined') {
                    member.originalName = member.name; // 将旧的 name 作为 originalName
                    member.groupNickname = member.name; // 同时创建一个初始的 groupNickname
                    delete member.name; // 删除旧的、有歧义的 name 字段
                    needsUpdate = true; // 标记需要存回数据库
                }
            });
             console.log(`迁移完成 for "${chat.name}"`);
        }

        // --- ▼▼▼ 核心修复就在这里 ▼▼▼ ---
        // 检查1：如果是一个单聊，并且没有 status 属性
        if (!chat.isGroup && !chat.status) {
            // 就为它补上一个默认的 status 对象
            chat.status = {
                text: '在线',
                lastUpdate: Date.now(),
                isBusy: false
            };
            console.log(`为旧角色 "${chat.name}" 补全了status属性。`);
        }
        // --- ▲▲▲ 修复结束 ▲▲▲

        // --- ▼▼▼ 核心修复就在这里 ▼▼▼ ---
        // 检查2：兼容最新的“关系”功能
        if (!chat.isGroup && !chat.relationship) {
            // 如果是单聊，且没有 relationship 对象，就补上一个默认的
            chat.relationship = {
                status: 'friend',
                blockedTimestamp: null,
                applicationReason: ''
            };
            console.log(`为旧角色 "${chat.name}" 补全了 relationship 属性。`);
        }
        // --- ▲▲▲ 修复结束 ▲▲▲

    // ▼▼▼ 在这里添加 ▼▼▼
    if (!chat.isGroup && (!chat.settings || !chat.settings.aiAvatarLibrary)) {
        if (!chat.settings) chat.settings = {}; // 以防万一连settings都没有
        chat.settings.aiAvatarLibrary = [];
        console.log(`为旧角色 "${chat.name}" 补全了aiAvatarLibrary属性。`);
    }
    // ▲▲▲ 添加结束 ▲▲▲

        if (!chat.musicData) chat.musicData = { totalTime: 0 };
        // 【全新】兼容旧数据，将 maxMemory 转换为 memoryAnchor
        if (chat.settings && typeof chat.settings.memoryAnchor === 'undefined') {
            const maxMemory = chat.settings.maxMemory || 10;
            const totalHistory = chat.history.length;
            // 将旧的“最后N条”逻辑转换为新的“从第N条开始”逻辑
            chat.settings.memoryAnchor = Math.max(0, totalHistory - maxMemory);
            delete chat.settings.maxMemory; // 删除旧的属性
        }
        
        // 【全新添加】兼容旧数据，为没有“总结保留条数”的聊天设置默认值
        if (chat.settings && typeof chat.settings.summarizeReserveCount === 'undefined') {
            chat.settings.summarizeReserveCount = 100; // 默认为100
        }

        // ▼▼▼ 在这里粘贴 ▼▼▼
// 为旧角色兼容日记和心声功能
if (!chat.diary) {
    chat.diary = [];
}
if (!chat.displayStatus) {
    chat.displayStatus = {
        statusText: chat.status?.text || '在线',
        innerThought: '...'
    };
}
if (!chat.statusHistory) {
    chat.statusHistory = [];
}
if (!chat.thoughtHistory) {
    chat.thoughtHistory = [];
}
// ▲▲▲ 粘贴结束 ▲▲▲
        if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) {
            chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId];
            delete chat.settings.linkedWorldBookId;
        }
        // ▼▼▼ 【V2最终修复版】统一修复并初始化所有角色的手机数据 ▼▼▼
if (!chat.isGroup) {
    // 第一步：确保最外层的 characterPhoneData 对象存在
    if (!chat.characterPhoneData) {
        chat.characterPhoneData = {}; // 如果不存在，就创建一个空的
    }

    // 第二步：逐一检查并补全所有APP的数据结构
    // 这样无论角色多老，都能确保所有字段都存在
    if (!chat.characterPhoneData.lastGenerated) chat.characterPhoneData.lastGenerated = null;
    if (!chat.characterPhoneData.chats) chat.characterPhoneData.chats = {};
    if (!chat.characterPhoneData.shoppingCart) chat.characterPhoneData.shoppingCart = [];
    if (!chat.characterPhoneData.memos) chat.characterPhoneData.memos = [];
    if (!chat.characterPhoneData.browserHistory) chat.characterPhoneData.browserHistory = [];
    if (!chat.characterPhoneData.photoAlbum) chat.characterPhoneData.photoAlbum = [];
    if (!chat.characterPhoneData.bank) chat.characterPhoneData.bank = { balance: 0, transactions: [] };
    if (!chat.characterPhoneData.trajectory) chat.characterPhoneData.trajectory = [];
    if (!chat.characterPhoneData.appUsage) chat.characterPhoneData.appUsage = [];
    if (!chat.characterPhoneData.diary) chat.characterPhoneData.diary = []; // 核心修复！
}
// ▲▲▲ 修正结束 ▲▲▲
        acc[chat.id] = chat;
        return acc;
    }, {});
    state.apiConfig = apiConfig || { id: 'main', proxyUrl: '', apiKey: '', model: '' };

state.globalSettings = globalSettings || { 
    id: 'main', 
    wallpaper: 'linear-gradient(135deg, #89f7fe, #66a6ff)', 
    fontUrl: '', 
    enableBackgroundActivity: false, 
    backgroundActivityInterval: 60,
    blockCooldownHours: 1,
    chatListPaddingTop: 72, // <--- 新增这一行
    appIcons: { ...DEFAULT_APP_ICONS } // 【核心修改】确保appIcons存在并有默认值
};
// 【核心修改】合并已保存的图标和默认图标，防止更新后旧数据丢失新图标
state.globalSettings.appIcons = { ...DEFAULT_APP_ICONS, ...(state.globalSettings.appIcons || {}) };

    state.userStickers = userStickers || [];
    state.apiPresets = apiPresets || [];
    state.worldBooks = worldBooks || [];
    musicState.playlist = musicLib?.playlist || [];
    state.personaPresets = personaPresets || [];
    state.qzoneSettings = qzoneSettings || { id: 'main', nickname: '{{user}}', avatar: 'https://files.catbox.moe/q6z5fc.jpeg', banner: 'https://files.catbox.moe/r5heyt.gif' };

    // ▼▼▼ 【确保这一行在 Promise.all 之后，并使用解构赋值得到的 initialFavorites】 ▼▼▼
    allFavoriteItems = initialFavorites || [];
    if (typeof state.globalSettings.chatListPaddingTop === 'undefined') {
    state.globalSettings.chatListPaddingTop = 72;
}
    // ▲▲▲ 【修改结束】 ▲▲▲
}

        async function saveGlobalPlaylist() { await db.musicLibrary.put({ id: 'main', playlist: musicState.playlist }); }

        function formatTimestamp(timestamp) { if (!timestamp) return ''; const date = new Date(timestamp); const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${hours}:${minutes}`; }
        
        // 【新增】模拟时间戳格式化函数
        function formatSimulatedTimestamp(simulatedTimestamp, originalLastMessageTime) {
            if (!simulatedTimestamp) return '';
            
            const simulatedDate = new Date(simulatedTimestamp);
            const originalDate = new Date(originalLastMessageTime);
            const currentDate = new Date(); // 当前真实时间
            
            const hours = String(simulatedDate.getHours()).padStart(2, '0');
            const minutes = String(simulatedDate.getMinutes()).padStart(2, '0');
            
            // 【修复】新的显示逻辑：只有真实时间当天的消息才不显示日期
            // 判断模拟时间戳是否是今天（真实的当天）
            const isSameDay = simulatedDate.toDateString() === currentDate.toDateString();
            
            if (isSameDay) {
                // 今天的消息只显示时间
                return `${hours}:${minutes}`;
            } else {
                // 不是今天的消息显示完整日期
                const month = String(simulatedDate.getMonth() + 1).padStart(2, '0');
                const day = String(simulatedDate.getDate()).padStart(2, '0');
                return `${month}月${day}日 ${hours}:${minutes}`;
            }
        }

        function showNotification(chatId, messageContent) { 
            console.log(`[showNotification] 收到通知请求 - chatId: ${chatId}, messageContent: "${messageContent}"`);
            clearTimeout(notificationTimeout); 
            const chat = state.chats[chatId]; 
            if (!chat) {
                console.log(`[showNotification] 未找到聊天记录: ${chatId}`);
                return;
            }
            const bar = document.getElementById('notification-bar'); 
            document.getElementById('notification-avatar').src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar; 
            document.getElementById('notification-content').querySelector('.name').textContent = chat.name; 
            document.getElementById('notification-content').querySelector('.message').textContent = messageContent; 
            console.log(`[showNotification] 设置通知内容 - 名字: "${chat.name}", 消息: "${messageContent}"`);
            const newBar = bar.cloneNode(true); 
            bar.parentNode.replaceChild(newBar, bar); 
            newBar.addEventListener('click', () => { openChat(chatId, true); newBar.classList.remove('visible'); }); 
            newBar.classList.add('visible'); 
            console.log(`[showNotification] 通知栏已显示`);
            notificationTimeout = setTimeout(() => { newBar.classList.remove('visible'); }, 4000); 
        }

        function updateClock() { const now = new Date(); const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' }); document.getElementById('main-time').textContent = timeString; document.getElementById('main-date').textContent = dateString; }

/**
 * 【终极健壮版】解析AI返回的、可能格式不规范的响应内容
 * @param {string} content - AI返回的原始字符串
 * @returns {Array} - 一个标准化的消息对象数组
 */
function parseAiResponse(content) {
    const trimmedContent = content.trim();
    
    // 方案1：【最优先】尝试作为标准的、单一的JSON数组解析
    // 这是最理想、最高效的情况
    if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
        try {
            const parsed = JSON.parse(trimmedContent);
            if (Array.isArray(parsed)) {
                console.log("解析成功：标准JSON数组格式。");
                return parsed;
            }
        } catch (e) {
            // 如果解析失败，说明它虽然看起来像个数组，但内部格式有问题。
            // 此时我们不报错，而是继续尝试下面的“强力解析”方案。
            console.warn("标准JSON数组解析失败，将尝试强力解析...");
        }
    }

    // 方案2：【强力解析】使用正则表达式，从混乱的字符串中提取出所有独立的JSON对象
    // 这能完美解决您遇到的 "(Timestamp: ...)[{...}](Timestamp: ...)[{...}]" 这种格式
    const jsonMatches = trimmedContent.match(/{[^{}]*}/g);

    if (jsonMatches) {
        const results = [];
        for (const match of jsonMatches) {
            try {
                // 尝试解析每一个被我们“揪”出来的JSON字符串
                const parsedObject = JSON.parse(match);
                results.push(parsedObject);
            } catch (e) {
                // 如果某个片段不是有效的JSON，就忽略它，继续处理下一个
                console.warn("跳过一个无效的JSON片段:", match);
            }
        }

        // 如果我们成功提取出了至少一个有效的JSON对象，就返回这个结果
        if (results.length > 0) {
            console.log("解析成功：通过强力提取模式。");
            return results;
        }
    }
    
    // 方案3：【最终备用】如果以上所有方法都失败了，说明AI返回的可能就是纯文本
    // 我们将原始的、未处理的内容，包装成一个标准的文本消息对象返回，确保程序不会崩溃
    console.error("所有解析方案均失败！将返回原始文本。");
    return [{ type: 'text', content: content }];
}

      function renderApiSettings() { 
    try {
        document.getElementById('proxy-url').value = state.apiConfig.proxyUrl || ''; 
        document.getElementById('api-key').value = state.apiConfig.apiKey || ''; 

        // ▼▼▼ 在这里粘贴新增的代码 ▼▼▼
        const modelSelect = document.getElementById('model-select');
        modelSelect.innerHTML = ''; // 先清空旧的选项
        if (state.apiConfig.model) {
            // 如果state中保存了模型，就创建一个option并选中它
            const option = document.createElement('option');
            option.value = state.apiConfig.model;
            option.textContent = state.apiConfig.model;
            option.selected = true;
            modelSelect.appendChild(option);
        }
        // ▲▲▲ 新增代码结束 ▲▲▲

        document.getElementById('background-activity-switch').checked = state.globalSettings.enableBackgroundActivity || false;
        document.getElementById('background-interval-input').value = state.globalSettings.backgroundActivityInterval || 60;
        document.getElementById('block-cooldown-input').value = state.globalSettings.blockCooldownHours || 1;

        if (typeof window.renderApiPresets === 'function') {
            window.renderApiPresets();
        }
    } catch (error) {
        console.error('渲染API设置时出错:', error);
    }
}
        window.renderApiSettingsProxy = renderApiSettings;

// 置顶聊天功能
async function toggleChatPin(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;
    
    chat.isPinned = !chat.isPinned;
    await db.chats.put(chat);
    renderChatList();
}

// ▼▼▼ 请用这个【全新版本】的函数，完整替换掉你旧的 renderChatList ▼▼▼
async function renderChatList() {
    const chatListEl = document.getElementById('chat-list');
    chatListEl.innerHTML = '';

    // 1. 获取所有聊天，置顶聊天在前，然后按最新消息时间排序
    const allChats = Object.values(state.chats).sort((a, b) => {
        // 置顶聊天优先显示
        if (a.isPinned && !b.isPinned) return -1;
        if (!a.isPinned && b.isPinned) return 1;
        // 如果都是置顶或都不是置顶，按最新消息时间排序
        return (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0);
    });
    
    // 2. 获取所有分组
    const allGroups = await db.qzoneGroups.toArray();

    if (allChats.length === 0) {
        chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 或群组图标添加聊天</p>';
        return;
    }

    // --- 【核心修正开始】---

    // 3. 为每个分组找到其内部最新的消息时间戳
    allGroups.forEach(group => {
        // 从已排序的 allChats 中找到本组的第一个（也就是最新的）聊天
        const latestChatInGroup = allChats.find(chat => chat.groupId === group.id);
        // 如果找到了，就用它的时间戳；如果该分组暂时没有聊天或聊天没有历史记录，就用0
        group.latestTimestamp = latestChatInGroup ? (latestChatInGroup.history.slice(-1)[0]?.timestamp || 0) : 0;
    });

    // 4. 根据这个最新的时间戳来对“分组本身”进行排序
    allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

    // --- 【核心修正结束】---

    // 5. 现在，我们按照排好序的分组来渲染
    allGroups.forEach(group => {
        // 从总列表里过滤出属于这个（已排序）分组的好友
        const groupChats = allChats.filter(chat => !chat.isGroup && chat.groupId === group.id);
        // 如果这个分组是空的（可能所有好友都被删了），就跳过
        if (groupChats.length === 0) return;

        const groupContainer = document.createElement('div');
        groupContainer.className = 'chat-group-container';
        groupContainer.innerHTML = `
            <div class="chat-group-header">
                <span class="arrow">▼</span>
                <span class="group-name">${group.name}</span>
            </div>
            <div class="chat-group-content"></div>
        `;
        const contentEl = groupContainer.querySelector('.chat-group-content');
        // 因为 allChats 本身就是有序的，所以 groupChats 自然也是有序的
        groupChats.forEach(chat => {
            const item = createChatListItem(chat);
            contentEl.appendChild(item);
        });
        chatListEl.appendChild(groupContainer);
    });

    // 6. 最后，渲染所有群聊和未分组的好友
    // 他们的顺序因为 allChats 的初始排序，天然就是正确的
    const ungroupedOrGroupChats = allChats.filter(chat => chat.isGroup || (!chat.isGroup && !chat.groupId));
    ungroupedOrGroupChats.forEach(chat => {
        const item = createChatListItem(chat);
        chatListEl.appendChild(item);
    });

    // 为所有分组标题添加折叠事件
    document.querySelectorAll('.chat-group-header').forEach(header => {
        header.addEventListener('click', () => {
            header.classList.toggle('collapsed');
            header.nextElementSibling.classList.toggle('collapsed');
        });
    });
}
// ▲▲▲ 替换结束 ▲▲▲

function createChatListItem(chat) {
    const lastMsgObj = chat.history.filter(msg => !msg.isHidden).slice(-1)[0] || {};
    const formattedTime = formatChatListTimestamp(lastMsgObj.timestamp);
    let lastMsgDisplay;

    // --- ▼▼▼ 【核心修改】在这里加入对关系状态的判断 ▼▼▼ ---
    if (!chat.isGroup && chat.relationship?.status === 'pending_user_approval') {
        lastMsgDisplay = `<span style="color: #ff8c00;">[好友申请] ${chat.relationship.applicationReason || '请求添加你为好友'}</span>`;
    }
    // --- ▲▲▲ 修改结束 ▲▲▲ ---

// ▼▼▼ 在这里新增 else if ▼▼▼
else if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
    lastMsgDisplay = `<span style="color: #dc3545;">[你已被对方拉黑]</span>`;
}
// ▲▲▲ 新增结束 ▲▲▲
    
    // 【核心修改】优先显示状态，而不是最后一条消息
    if (chat.isGroup) {
        // 群聊逻辑保持不变
        if (lastMsgObj.type === 'pat_message') { lastMsgDisplay = `[系统消息] ${lastMsgObj.content}`; }
        // ... (其他群聊消息类型判断) ...
        else if (lastMsgObj.type === 'transfer') { lastMsgDisplay = '[转账]'; }
        else if (lastMsgObj.type === 'ai_image' || lastMsgObj.type === 'user_photo') { lastMsgDisplay = '[照片]'; }
        else if (lastMsgObj.type === 'voice_message') { lastMsgDisplay = '[语音]'; }
        else if (typeof lastMsgObj.content === 'string' && STICKER_REGEX.test(lastMsgObj.content)) { lastMsgDisplay = lastMsgObj.meaning ? `[表情: ${lastMsgObj.meaning}]` : '[表情]'; }
        else if (Array.isArray(lastMsgObj.content)) { lastMsgDisplay = `[图片]`; }
        else { lastMsgDisplay = String(lastMsgObj.content || '...').substring(0, 20); }

        if (lastMsgObj.senderName && lastMsgObj.type !== 'pat_message') {
            lastMsgDisplay = `${lastMsgObj.senderName}: ${lastMsgDisplay}`;
        }

    } else {
        // 单聊逻辑：显示状态
        // 确保 chat.status 对象存在
        const statusText = chat.status?.text || '在线';
        lastMsgDisplay = `[${statusText}]`;
    }

    const item = document.createElement('div');
    item.className = 'chat-list-item' + (chat.isPinned ? ' pinned' : '');
    item.dataset.chatId = chat.id;
    const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;
    
    // 在 createChatListItem 函数中，用下面这块代码替换旧的 item.innerHTML
item.innerHTML = `
    <span class="time">${formattedTime}</span>
    <img src="${avatar || defaultAvatar}" class="avatar">
    <div class="info">
        <div class="name-line">
            <span class="name">${chat.name}</span>
            ${chat.isGroup ? '<span class="group-tag">群聊</span>' : ''}
        </div>
        <div class="last-msg" style="color: ${chat.isGroup ? 'var(--text-secondary)' : '#b5b5b5'}; ">${lastMsgDisplay}</div>
    </div>
    <div class="unread-count-wrapper">
        <span class="unread-count" style="display: none;">0</span>
    </div>
    <div class="swipe-actions">
        <button class="pin-btn">${chat.isPinned ? '取消置顶' : '置顶'}</button>
    </div>
`;
    
    // 【核心修改2】在这里添加控制红点显示/隐藏的逻辑
    const unreadCount = chat.unreadCount || 0;
    const unreadEl = item.querySelector('.unread-count');
    if (unreadCount > 0) {
        unreadEl.textContent = unreadCount > 99 ? '99+' : unreadCount;
        // 注意这里是 'inline-flex'，与我们的CSS对应，使其垂直居中
        unreadEl.style.display = 'inline-flex';
    } else {
        unreadEl.style.display = 'none';
    }
    
    const avatarEl = item.querySelector('.avatar');
    if (avatarEl) {
        avatarEl.style.cursor = 'pointer';
        avatarEl.addEventListener('click', (e) => {
            e.stopPropagation();
            handleUserPat(chat.id, chat.name);
        });
    }
    
    const infoEl = item.querySelector('.info');
    if (infoEl) {
        infoEl.addEventListener('click', () => openChat(chat.id));
    }

    addLongPressListener(item, async (e) => {
        const confirmed = await showCustomConfirm('删除对话', `确定要删除与 "${chat.name}" 的整个对话吗？此操作不可撤销。`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            if (musicState.isActive && musicState.activeChatId === chat.id) await endListenTogetherSession(false);
            delete state.chats[chat.id];
            if (state.activeChatId === chat.id) state.activeChatId = null;
            await db.chats.delete(chat.id);
            renderChatList();
        }
    });

    // 添加左滑手势检测
    let startX, currentX, isDragging = false;
    let swipeTimeout = null;

    function handleTouchStart(e) {
        startX = e.touches[0].clientX;
        isDragging = false;
        currentX = startX;
    }

    function handleTouchMove(e) {
        if (startX === null) return;
        currentX = e.touches[0].clientX;
        const diffX = startX - currentX;
        
        if (Math.abs(diffX) > 5) {
            e.preventDefault(); // 阻止其他事件
        }
        
        if (diffX > 20 && !isDragging) {
            isDragging = true;
            item.classList.add('swiped');
            
            // 设置自动隐藏定时器
            if (swipeTimeout) clearTimeout(swipeTimeout);
            swipeTimeout = setTimeout(() => {
                item.classList.remove('swiped');
            }, 3000);
        } else if (diffX < -10 && isDragging) {
            item.classList.remove('swiped');
            if (swipeTimeout) clearTimeout(swipeTimeout);
            isDragging = false;
        }
    }

    function handleTouchEnd(e) {
        startX = null;
        isDragging = false;
    }

    item.addEventListener('touchstart', handleTouchStart, { passive: false });
    item.addEventListener('touchmove', handleTouchMove, { passive: false });
    item.addEventListener('touchend', handleTouchEnd, { passive: true });

    // 鼠标事件支持（桌面端调试）
    item.addEventListener('mousedown', (e) => {
        startX = e.clientX;
        isDragging = false;
        currentX = startX;
    });

    item.addEventListener('mousemove', (e) => {
        if (startX === null) return;
        currentX = e.clientX;
        const diffX = startX - currentX;
        
        if (diffX > 30 && !isDragging) {
            isDragging = true;
            item.classList.add('swiped');
            
            if (swipeTimeout) clearTimeout(swipeTimeout);
            swipeTimeout = setTimeout(() => {
                item.classList.remove('swiped');
            }, 3000);
        } else if (diffX < -10 && isDragging) {
            item.classList.remove('swiped');
            if (swipeTimeout) clearTimeout(swipeTimeout);
            isDragging = false;
        }
    });

    item.addEventListener('mouseup', () => {
        startX = null;
        isDragging = false;
    });

    item.addEventListener('mouseleave', () => {
        startX = null;
        isDragging = false;
    });

    // 置顶按钮点击事件
    const pinBtn = item.querySelector('.pin-btn');
    pinBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        await toggleChatPin(chat.id);
        item.classList.remove('swiped');
        if (swipeTimeout) clearTimeout(swipeTimeout);
    });

    return item;
}

// ▼▼▼ 请用这个【带诊断功能的全新版本】替换旧的 renderChatInterface 函数 ▼▼▼
function renderChatInterface(chatId) {
    cleanupWaimaiTimers();
    const chat = state.chats[chatId];
    if (!chat) return;
    exitSelectionMode();
    
    // 恢复线上/线下模式状态（按聊天分别记忆）
    if (!chat.isGroup) {
        const savedModes = JSON.parse(localStorage.getItem('chatOfflineModes') || '{}');
        // 恢复当前聊天的独立状态，如果没有记录则默认为线上模式
        offlineMode.isOffline = savedModes.hasOwnProperty(chatId) ? savedModes[chatId] : false;
        updateOnlineOfflineButton();
    } else {
        // 群聊强制设置为线上模式
        offlineMode.isOffline = false;
        updateOnlineOfflineButton();
    }
    
    const messagesContainer = document.getElementById('chat-messages');
    const chatInputArea = document.getElementById('chat-input-area');
    const lockOverlay = document.getElementById('chat-lock-overlay');
    const lockContent = document.getElementById('chat-lock-content');

    messagesContainer.dataset.theme = chat.settings.theme || 'default';
    const fontSize = chat.settings.fontSize || 13;
    messagesContainer.style.setProperty('--chat-font-size', `${fontSize}px`);
    applyScopedCss(chat.settings.customCss || '', '#chat-messages', 'custom-bubble-style');
    
    document.getElementById('chat-header-title').textContent = chat.name;
    const statusContainer = document.getElementById('chat-header-status');
    const statusTextEl = statusContainer.querySelector('.status-text');

    if (chat.isGroup) {
    statusContainer.style.display = 'none';
    document.getElementById('chat-header-title-wrapper').style.justifyContent = 'center';
} else {
    statusContainer.style.display = 'flex';
    document.getElementById('chat-header-title-wrapper').style.justifyContent = 'flex-start';
    updateChatHeaderStatus(); // 直接调用我们的新工具
}
    
    lockOverlay.style.display = 'none';
    chatInputArea.style.visibility = 'visible';
    lockContent.innerHTML = '';

    if (!chat.isGroup && chat.relationship.status !== 'friend') {
        lockOverlay.style.display = 'flex';
        chatInputArea.style.visibility = 'hidden';
        
        let lockHtml = '';
        switch (chat.relationship.status) {
            case 'blocked_by_user':
                // --- 【核心修改：在这里加入诊断面板】 ---
                const isSimulationRunning = simulationIntervalId !== null;
                const blockedTimestamp = chat.relationship.blockedTimestamp;
                const cooldownHours = state.globalSettings.blockCooldownHours || 1;
                const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                const timeSinceBlock = Date.now() - blockedTimestamp;
                const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));

                lockHtml = `
                    
                    
                    <div class="lock-actions-row">
                        <button id="unblock-btn" class="lock-action-btn" style="flex-grow: 1;">解除拉黑</button>
                        <button id="force-apply-check-btn" class="lock-action-btn secondary" style="flex-grow: 1;">强制触发检测</button>
                        
                        <button id="toggle-dev-panel-btn" title="显示/隐藏开发者诊断面板">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 5V19M5 12H19" />
                        </svg>
                    </button>
                    </div>

                    <div id="developer-diagnostic-panel" style="display: none; margin-top: 15px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                        <strong style="color: #333;">【开发者诊断面板】</strong><br>
                        - 后台活动总开关: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已开启</span>' : '<span style="color: red;">已关闭</span>'}<br>
                        - 系统心跳计时器: ${isSimulationRunning ? '<span style="color: green;">运行中</span>' : '<span style="color: red;">未运行</span>'}<br>
                        - 当前角色状态: <strong>${chat.relationship.status}</strong><br>
                        - 需要冷静(小时): <strong>${cooldownHours}</strong><br>
                        - 冷静期是否结束: ${isCooldownOver ? '<span style="color: green;">是</span>' : `<span style="color: orange;">否 (还剩约 ${timeRemainingMinutes} 分钟)</span>`}<br>
                        - 触发条件: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已满足，等待下次系统心跳</span>' : '<span style="color: red;">未满足</span>'}
                    </div>
                `;
                break;
            case 'blocked_by_ai':
                lockHtml = `
                    <span class="lock-text">你被对方拉黑了。</span>
                    <button id="apply-friend-btn" class="lock-action-btn">重新申请加为好友</button>
                `;
                break;
            
            case 'pending_user_approval':
                lockHtml = `
<span class="lock-text">“${chat.name}”请求添加你为好友：<br>“${chat.relationship.applicationReason}”</span>             
       <div class="lock-actions-container">
            
            <button id="reject-friend-btn" class="lock-action-btn secondary">拒绝</button>
            <button id="accept-friend-btn" class="lock-action-btn">接受</button>
        </div>
                `;
                break;

            // 【核心修正】修复当你申请后，你看到的界面
            case 'pending_ai_approval':
                lockHtml = `<span class="lock-text">好友申请已发送，等待对方通过...</span>`;
                break;
        }
        lockContent.innerHTML = lockHtml;
    }
    messagesContainer.innerHTML = '';
    // ...后续代码保持不变
    const chatScreen = document.getElementById('chat-interface-screen');
    // 优先使用聊天自定义背景，其次使用全局聊天背景
    const backgroundImage = chat.settings.background || state.globalSettings.chatBackground;
    chatScreen.style.backgroundImage = backgroundImage ? `url(${backgroundImage})` : 'none';

const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
chatScreen.style.backgroundColor = backgroundImage ? 'transparent' : (isDarkMode ? '#000000' : '#F7F7F7');
    const history = chat.history;
    const totalMessages = history.length;
    currentRenderedCount = 0;
    const initialMessages = history.slice(-MESSAGE_RENDER_WINDOW);

// 【全新】智能时间戳渲染逻辑
const messageGroupsByDay = initialMessages.reduce((acc, msg) => {
    const dateStr = new Date(msg.timestamp).toDateString();
    if (!acc[dateStr]) {
        acc[dateStr] = [];
    }
    acc[dateStr].push(msg);
    return acc;
}, {});

// 检查初始消息块之前的那条消息，以确定是否需要在开头添加时间戳
const startIndex = Math.max(0, history.length - initialMessages.length);
let lastTimestampBeforeChunk = (startIndex > 0) ? history[startIndex - 1].timestamp : 0;

Object.values(messageGroupsByDay).forEach(dayGroup => {
    const firstMessageOfDay = dayGroup[0];
    const dayMessageCount = dayGroup.length;

    // 规则判断：决定如何插入时间戳
    if (!isSameDay(lastTimestampBeforeChunk, firstMessageOfDay.timestamp)) {
        if (isSameDay(Date.now(), firstMessageOfDay.timestamp)) { // 规则3：今天
            // 只在今天的第一条消息前加一个时间戳
            const divider = document.createElement('div');
            divider.className = 'date-divider';
            divider.textContent = formatDateDivider(firstMessageOfDay.timestamp);
            messagesContainer.appendChild(divider);
        } else { // 规则1 & 2：昨天或更早
            if (dayMessageCount <= 20) {
                // 消息不多，只在开头加一个
                const divider = document.createElement('div');
                divider.className = 'date-divider';
                divider.textContent = formatDateDivider(firstMessageOfDay.timestamp);
                messagesContainer.appendChild(divider);
            } else {
                // 消息多，需要每20条加一个，我们会在下面的循环里处理
            }
        }
    }

    // 渲染这一天的消息
    dayGroup.forEach((msg, index) => {
        // 【新】处理消息量大的情况
        if (!isSameDay(Date.now(), msg.timestamp) && dayMessageCount > 20 && index % 20 === 0) {
            const divider = document.createElement('div');
            divider.className = 'date-divider';
            divider.textContent = formatDateDivider(msg.timestamp);
            messagesContainer.appendChild(divider);
        }
        appendMessage(msg, chat, true);
    });

    lastTimestampBeforeChunk = dayGroup[dayGroup.length - 1].timestamp;
});
currentRenderedCount = initialMessages.length;
    if (totalMessages > currentRenderedCount) {
        prependLoadMoreButton(messagesContainer);
    }
    const typingIndicator = document.createElement('div');
    typingIndicator.id = 'typing-indicator';
    typingIndicator.style.display = 'none';
    typingIndicator.textContent = '对方正在输入...';
    messagesContainer.appendChild(typingIndicator);
    setTimeout(() => messagesContainer.scrollTop = messagesContainer.scrollHeight, 0);
}
// ▲▲▲ 替换结束 ▲▲▲

        function prependLoadMoreButton(container) { const button = document.createElement('button'); button.id = 'load-more-btn'; button.textContent = '加载更早的记录'; button.addEventListener('click', loadMoreMessages); container.prepend(button); }
function loadMoreMessages() {
    const messagesContainer = document.getElementById('chat-messages');
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const loadMoreBtn = document.getElementById('load-more-btn');
    if (loadMoreBtn) loadMoreBtn.remove();

    const totalMessages = chat.history.length;
    const nextSliceStart = totalMessages - currentRenderedCount - MESSAGE_RENDER_WINDOW;
    const nextSliceEnd = totalMessages - currentRenderedCount;
    const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd);
    const oldScrollHeight = messagesContainer.scrollHeight;

    const fragment = document.createDocumentFragment();

    // 获取屏幕上已存在的最早一条消息的时间戳
    const firstOldMessageOnScreen = messagesContainer.querySelector('.message-wrapper');
    let timestampOfNextMessage = firstOldMessageOnScreen ? parseInt(firstOldMessageOnScreen.dataset.timestamp, 10) : 0;

    // 从后往前遍历我们要加载的消息块
    for (let i = messagesToPrepend.length - 1; i >= 0; i--) {
        const msg = messagesToPrepend[i];

        // 比较当前消息和它后面那条消息（时间上更晚的）是否跨天
        if (timestampOfNextMessage && !isSameDay(msg.timestamp, timestampOfNextMessage)) {
            const divider = document.createElement('div');
            divider.className = 'date-divider';
            divider.textContent = formatDateDivider(timestampOfNextMessage);
            fragment.prepend(divider);
        }

        const messageEl = createMessageElement(msg, chat);
        if (messageEl) {
            fragment.prepend(messageEl);
        }

        // 更新“后面那条消息”的时间戳，为下一次循环做准备
        timestampOfNextMessage = msg.timestamp;
    }

    messagesContainer.prepend(fragment);

    currentRenderedCount += messagesToPrepend.length;
    const newScrollHeight = messagesContainer.scrollHeight;
    messagesContainer.scrollTop = newScrollHeight - oldScrollHeight;

    if (totalMessages > currentRenderedCount) {
        prependLoadMoreButton(messagesContainer);
    }
}

// ▼▼▼ 用这个【新版本】替换旧的 renderWallpaperScreen 函数 ▼▼▼
function renderWallpaperScreen() { 
    // 处理壁纸预览
    const preview = document.getElementById('wallpaper-preview'); 
    const bg = newWallpaperBase64 || state.globalSettings.wallpaper; 
    if (bg && bg.startsWith('data:image')) { 
        preview.style.backgroundImage = `url(${bg})`; 
        preview.textContent = ''; 
    } else if(bg) { 
        preview.style.backgroundImage = bg; 
        preview.textContent = '当前为渐变色'; 
    }
    
    // 处理聊天背景预览
    const chatBgPreview = document.getElementById('chat-background-preview'); 
    const chatBg = newChatBackgroundBase64 || state.globalSettings.chatBackground; 
    if (chatBg && chatBg.startsWith('data:image')) { 
        chatBgPreview.style.backgroundImage = `url(${chatBg})`; 
        chatBgPreview.textContent = ''; 
    } else if(chatBg) { 
        chatBgPreview.style.backgroundImage = chatBg; 
        chatBgPreview.textContent = '当前聊天背景'; 
    } else {
        chatBgPreview.style.backgroundImage = 'none'; 
        chatBgPreview.textContent = '点击下方上传'; 
    }
    
    // 【核心修改】在这里调用图标渲染函数
    renderIconSettings();
    const paddingTopInput = document.getElementById('chat-list-padding-top-input');
if (paddingTopInput) {
    paddingTopInput.value = state.globalSettings.chatListPaddingTop || 72;
}
}
// ▲▲▲ 替换结束 ▲▲▲
        window.renderWallpaperScreenProxy = renderWallpaperScreen;

        function applyGlobalWallpaper() { const homeScreen = document.getElementById('home-screen'); const wallpaper = state.globalSettings.wallpaper; if (wallpaper && wallpaper.startsWith('data:image')) homeScreen.style.backgroundImage = `url(${wallpaper})`; else if (wallpaper) homeScreen.style.backgroundImage = wallpaper; }
        
        // 应用全局聊天背景（如果当前正在查看聊天）
        function applyGlobalChatBackground() { 
            // 如果当前正在查看聊天，重新渲染以应用新背景
            if (state.activeChatId && document.getElementById('chat-interface-screen').classList.contains('active')) {
                renderChat(state.activeChatId);
            }
        }
/**
 * 【全新】应用聊天列表的顶部内边距
 */
function applyChatListPaddingTop() {
    const chatList = document.getElementById('chat-list');
    // 从全局设置中读取值，如果不存在则使用默认值72
    const paddingTop = state.globalSettings.chatListPaddingTop || 72;
    if (chatList) {
        chatList.style.paddingTop = `${paddingTop}px`;
    }
}
async function renderWorldBookScreen() {
    const listEl = document.getElementById('world-book-list');
    listEl.innerHTML = '';

    const [books, categories] = await Promise.all([
        db.worldBooks.toArray(),
        db.worldBookCategories.orderBy('name').toArray()
    ]);

    state.worldBooks = books;

    if (books.length === 0) {
        listEl.innerHTML = `
            <div class="glass-container empty-state">
                <div class="glass-content">
                    <p style="text-align:center; color: #8a8a8a; margin: 30px 0;">点击右上角 "+" 创建你的第一本世界书</p>
                </div>
            </div>
        `;
        return;
    }

    const groupedBooks = books.reduce((acc, book) => {
        const key = book.categoryId || 'uncategorized';
        if (!acc[key]) acc[key] = [];
        acc[key].push(book);
        return acc;
    }, {});

    // 封装一个通用的渲染和绑定函数，避免代码重复
    const renderAndBindGroup = (name, bookList, id) => {
        const groupContainer = createWorldBookGroup(name, bookList, id);
        listEl.appendChild(groupContainer);

        // 为分类标题添加长按删除事件
        const header = groupContainer.querySelector('.world-book-group-header');
        addLongPressListener(header, async () => {
            const categoryId = header.dataset.categoryId;
            const categoryName = header.dataset.categoryName;
            
            const confirmed = await showCustomConfirm(
                '删除确认', 
                `确定要删除分类 “${categoryName}” 以及该分类下的所有条目吗？此操作不可撤销。`, 
                { confirmButtonClass: 'btn-danger' }
            );

            if (confirmed) {
                await db.transaction('rw', db.worldBooks, db.worldBookCategories, async () => {
                    if (categoryId === 'uncategorized') {
                        // 删除所有未分类的书籍
                        await db.worldBooks.where('categoryId').equals(null).delete();
                    } else {
                        const numericId = parseInt(categoryId);
                        // 删除分类下的所有书籍
                        await db.worldBooks.where({ categoryId: numericId }).delete();
                        // 删除分类本身
                        await db.worldBookCategories.delete(numericId);
                    }
                });
                await renderWorldBookScreen(); // 重新渲染整个列表
            }
        });
    };

    categories.forEach(category => {
        const booksInCategory = groupedBooks[category.id];
        if (booksInCategory && booksInCategory.length > 0) {
            renderAndBindGroup(category.name, booksInCategory, category.id);
        }
    });

    const uncategorizedBooks = groupedBooks['uncategorized'];
    if (uncategorizedBooks && uncategorizedBooks.length > 0) {
        renderAndBindGroup('未分类', uncategorizedBooks, 'uncategorized');
    }
    
    document.querySelectorAll('.world-book-group-header').forEach(header => {
        header.addEventListener('click', (e) => {
             // 确保长按时不触发点击折叠
            if (e.detail === 0) return;

            header.classList.toggle('collapsed');
            const groupContainer = header.closest('.world-book-group-container');
            const contentEl = groupContainer.querySelector('.world-book-group-content');
            contentEl.classList.toggle('collapsed');
        });
    });
}

/**
 * 【辅助函数】创建一个分类的分组DOM
 * @param {string} groupName - 分类名称
 * @param {Array} books - 该分类下的书籍数组
 * @returns {HTMLElement} - 创建好的分组容器
 */
function createWorldBookGroup(groupName, books, categoryId) {
    const groupContainer = document.createElement('div');
    groupContainer.className = 'world-book-group-container';
    
    groupContainer.innerHTML = `
        <div class="glass-container category-header">
            <div class="world-book-group-header" data-category-id="${categoryId}" data-category-name="${groupName}">
                <span class="arrow">▼</span>
                <span class="group-name">${groupName}</span>
            </div>
        </div>
        <div class="world-book-group-content">
            <div class="glass-container content-list">
                <div class="glass-content"></div>
            </div>
        </div>
    `;

    // ▼▼▼ 在这里添加新代码 ▼▼▼
    const headerEl = groupContainer.querySelector('.world-book-group-header');
    const contentEl = groupContainer.querySelector('.world-book-group-content');
    const glassContent = groupContainer.querySelector('.glass-content');
    
    // 默认给头部和内容区都加上 collapsed 类
    headerEl.classList.add('collapsed');
    contentEl.classList.add('collapsed');
    // ▲▲▲ 添加结束 ▲▲▲

    books.sort((a,b) => a.name.localeCompare(b.name, 'zh-CN'));
    books.forEach(book => {
        const item = document.createElement('div');
        item.className = 'list-item';
        item.dataset.bookId = book.id;
        item.innerHTML = `<div class="item-title">${book.name}</div><div class="item-content">${(book.content || '暂无内容...').substring(0, 50)}</div>`;
        item.addEventListener('click', () => openWorldBookEditor(book.id));
        addLongPressListener(item, async () => { const confirmed = await showCustomConfirm('删除世界书', `确定要删除《${book.name}》吗？此操作不可撤销。`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.worldBooks.delete(book.id); state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id); renderWorldBookScreen(); } });
        glassContent.appendChild(item); 
    });

    return groupContainer;
}
        window.renderWorldBookScreenProxy = renderWorldBookScreen;

// ▼▼▼ 统一世界书管理功能 ▼▼▼

// 当前编辑的世界书ID（用于编辑现有书籍）
let currentEditingBookId = null;

// 显示统一管理模态框
function showUnifiedWorldBookModal(mode = 'main', bookId = null) {
    currentEditingBookId = bookId;
    const modal = document.getElementById('world-book-unified-modal');
    modal.classList.add('visible');
    
    if (mode === 'edit' && bookId) {
        // 编辑模式：直接跳转到创建书籍页面，但填入现有数据
        showUnifiedView('create-book');
        loadBookDataForEdit(bookId);
        document.getElementById('unified-modal-title').textContent = '编辑世界书';
    } else {
        // 默认显示主菜单
        showUnifiedView('main-menu');
        document.getElementById('unified-modal-title').textContent = '世界书管理';
    }
}

// 切换统一管理界面视图
function showUnifiedView(viewName) {
    // 隐藏所有视图
    document.querySelectorAll('.unified-view').forEach(view => {
        view.style.display = 'none';
    });
    
    // 显示目标视图
    const targetView = document.getElementById(`unified-${viewName}`);
    if (targetView) {
        targetView.style.display = 'flex';
    }
    
    // 根据视图更新标题和底部按钮显示
    const titleEl = document.getElementById('unified-modal-title');
    const doneBtn = document.getElementById('unified-modal-done');
    switch (viewName) {
        case 'main-menu':
            titleEl.textContent = '世界书管理';
            doneBtn.style.display = 'none';
            break;
        case 'create-book':
            titleEl.textContent = currentEditingBookId ? '编辑世界书' : '创建世界书';
            doneBtn.style.display = 'block';
            break;
        case 'manage-categories':
            titleEl.textContent = '管理分类';
            doneBtn.style.display = 'none';
            renderUnifiedCategoriesList();
            break;
    }
    
    // 根据视图加载数据
    if (viewName === 'create-book') {
        loadUnifiedCategoryOptions();
    }
}

// 加载分类选项到下拉框
async function loadUnifiedCategoryOptions() {
    const selectEl = document.getElementById('unified-book-category');
    const categories = await db.worldBookCategories.toArray();
    
    selectEl.innerHTML = '<option value="">-- 未分类 --</option>';
    categories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat.id;
        option.textContent = cat.name;
        selectEl.appendChild(option);
    });
}

// 加载书籍数据用于编辑
async function loadBookDataForEdit(bookId) {
    const book = await db.worldBooks.get(bookId);
    if (book) {
        document.getElementById('unified-book-name').value = book.name;
        document.getElementById('unified-book-content').value = book.content || '';
        
        // 等待分类选项加载完成后设置选中值
        await loadUnifiedCategoryOptions();
        if (book.categoryId) {
            document.getElementById('unified-book-category').value = book.categoryId;
        }
    }
}

// 保存世界书（创建或编辑）
async function saveUnifiedBook() {
    const name = document.getElementById('unified-book-name').value.trim();
    const content = document.getElementById('unified-book-content').value;
    const categoryId = document.getElementById('unified-book-category').value;
    
    if (!name) {
        alert('书名不能为空！');
        return;
    }
    
    if (currentEditingBookId) {
        // 编辑现有书籍
        const book = await db.worldBooks.get(currentEditingBookId);
        if (book) {
            book.name = name;
            book.content = content;
            book.categoryId = categoryId ? parseInt(categoryId) : null;
            await db.worldBooks.put(book);
            
            // 更新内存中的状态
            const bookInState = state.worldBooks.find(wb => wb.id === book.id);
            if (bookInState) {
                bookInState.name = name;
                bookInState.content = content;
                bookInState.categoryId = book.categoryId;
            }
        }
    } else {
        // 创建新书籍
        const newBook = {
            id: 'wb_' + Date.now(),
            name: name,
            content: content,
            categoryId: categoryId ? parseInt(categoryId) : null
        };
        await db.worldBooks.add(newBook);
        state.worldBooks.push(newBook);
    }
    
    // 清空表单
    document.getElementById('unified-book-name').value = '';
    document.getElementById('unified-book-content').value = '';
    document.getElementById('unified-book-category').value = '';
    
    // 刷新主列表
    renderWorldBookScreen();
    
    // 回到主菜单或关闭模态框
    if (currentEditingBookId) {
        closeUnifiedModal();
    } else {
        showUnifiedView('main-menu');
    }
    
    currentEditingBookId = null;
}

// 渲染统一界面的分类列表
async function renderUnifiedCategoriesList() {
    const listEl = document.getElementById('unified-categories-list');
    const categories = await db.worldBookCategories.toArray();
    
    listEl.innerHTML = '';
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">还没有任何分类</p>';
        return;
    }
    
    categories.forEach(cat => {
        const item = document.createElement('div');
        item.className = 'category-item-row';
        item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

// 添加新分类
async function addUnifiedCategory() {
    const input = document.getElementById('unified-new-category-name');
    const name = input.value.trim();
    
    if (!name) {
        alert('分类名称不能为空！');
        return;
    }
    
    const newCategory = { name: name };
    await db.worldBookCategories.add(newCategory);
    input.value = '';
    renderUnifiedCategoriesList();
}

// 删除分类
async function deleteUnifiedCategory(categoryId) {
    const confirmed = await showCustomConfirm(
        '确认删除', 
        '删除分类后，该分类下的所有世界书将变为"未分类"。确定要删除吗？', 
        { confirmButtonClass: 'btn-danger' }
    );
    
    if (confirmed) {
        await db.worldBookCategories.delete(categoryId);
        // 将属于该分类的世界书的 categoryId 设为 null
        const booksToUpdate = await db.worldBooks.where('categoryId').equals(categoryId).toArray();
        for (const book of booksToUpdate) {
            book.categoryId = null;
            await db.worldBooks.put(book);
            const bookInState = state.worldBooks.find(wb => wb.id === book.id);
            if(bookInState) bookInState.categoryId = null;
        }
        renderUnifiedCategoriesList();
        // 刷新世界书主界面以反映分类变更
        if (typeof renderWorldBookScreen === 'function') {
            renderWorldBookScreen();
        }
    }
}

// 关闭统一模态框
function closeUnifiedModal() {
    document.getElementById('world-book-unified-modal').classList.remove('visible');
    currentEditingBookId = null;
}

// ▲▲▲ 统一世界书管理功能结束 ▲▲▲

async function openWorldBookEditor(bookId) {
    // 使用新的统一模态框进行编辑
    showUnifiedWorldBookModal('edit', bookId);
}

        function renderStickerPanel() { const grid = document.getElementById('sticker-grid'); grid.innerHTML = ''; if (state.userStickers.length === 0) { grid.innerHTML = '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">大人请点击右上角"添加"或"上传"来添加你的第一个表情吧！</p>'; return; } state.userStickers.forEach(sticker => { const item = document.createElement('div'); item.className = 'sticker-item'; item.style.backgroundImage = `url(${sticker.url})`; item.title = sticker.name; item.addEventListener('click', (e) => { e.stopPropagation(); sendSticker(sticker); }); addLongPressListener(item, (e) => { e.stopPropagation(); if (isSelectionMode) return; const existingDeleteBtn = item.querySelector('.delete-btn'); if (existingDeleteBtn) return; const deleteBtn = document.createElement('div'); deleteBtn.className = 'delete-btn'; deleteBtn.innerHTML = '&times;'; deleteBtn.onclick = async (e) => { e.stopPropagation(); const confirmed = await showCustomConfirm('删除表情', `确定要删除表情 "${sticker.name}" 吗？`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.userStickers.delete(sticker.id); state.userStickers = state.userStickers.filter(s => s.id !== sticker.id); renderStickerPanel(); } }; item.appendChild(deleteBtn); deleteBtn.style.display = 'block'; setTimeout(() => item.addEventListener('mouseleave', () => deleteBtn.remove(), { once: true }), 3000); }); grid.appendChild(item); }); }

// ▼▼▼ 用这个【已更新】的版本替换旧的 createMessageElement 函数 ▼▼▼
function createMessageElement(msg, chat) {
// ▼▼▼ 【全新】处理自定义HTML模块的特殊渲染（已添加交互功能）▼▼▼
    if (msg.type === 'html_module') {
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper html-module-wrapper';
        wrapper.dataset.timestamp = msg.timestamp; // 【核心】将时间戳绑定到最外层容器

        // 1. 创建一个内部容器，这个容器将扮演“气泡”的角色，以便被选择功能识别
        const innerContainer = document.createElement('div');
        innerContainer.className = 'message-bubble'; // 【核心】必须有这个类，多选功能才能找到它
        innerContainer.dataset.timestamp = msg.timestamp; // 多选功能也需要这个
        innerContainer.innerHTML = msg.content; // 将您的HTML内容放入这个“隐形气泡”
        
        wrapper.appendChild(innerContainer);

        // 2. 【关键】将用于所有其他消息的事件监听器，复制到这里
        addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { 
            if (isSelectionMode) {
                toggleMessageSelection(msg.timestamp);
            }
        });

        return wrapper;
    }
    // ▲▲▲ 替换结束 ▲▲▲
    // ▼▼▼ 在函数最开头，添加这段新代码 ▼▼▼
// 【全新】处理主动回复中的撤回消息类型，将其转换为已撤回状态显示
if (msg.type === 'send_and_recall') {
    const wrapper = document.createElement('div');
    wrapper.className = 'message-wrapper system-pat';
    wrapper.dataset.timestamp = msg.timestamp;

    const bubble = document.createElement('div');
    bubble.className = 'message-bubble recalled-message-placeholder';
    bubble.dataset.timestamp = msg.timestamp;
    bubble.textContent = '对方撤回了一条消息';
    
    // 【关键】将原始内容保存到recalledData中，这样用户点击可以查看
    if (!msg.recalledData) {
        msg.recalledData = {
            originalType: 'text',
            originalContent: msg.content
        };
    }
    
    wrapper.appendChild(bubble);
    return wrapper;
}

if (msg.type === 'recalled_message') {
    const wrapper = document.createElement('div');
    // 1. 【核心】给 wrapper 也加上 timestamp，方便事件委托时查找
    wrapper.className = 'message-wrapper system-pat';
    wrapper.dataset.timestamp = msg.timestamp; 

    const bubble = document.createElement('div');
    // 2. 【核心】让这个元素同时拥有 .message-bubble 和 .recalled-message-placeholder 两个class
    //    这样它既能被选择系统识别，又能保持原有的居中灰色样式
    bubble.className = 'message-bubble recalled-message-placeholder';
    // 3. 【核心】把 timestamp 放在 bubble 上，这是多选逻辑的关键
    bubble.dataset.timestamp = msg.timestamp; 
    bubble.textContent = msg.content;
    
    wrapper.appendChild(bubble);
    
    // 4. 【核心】为它补上和其他消息一样的标准事件监听器
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
    wrapper.addEventListener('click', () => { 
        if (isSelectionMode) {
            toggleMessageSelection(msg.timestamp);
        }
    });

    // 5. 【重要】在之前的“点击查看原文”的逻辑中，我们已经使用了事件委托，所以这里不需要再单独为这个元素添加点击事件了。
    //    init() 函数中的那个事件监听器会处理它。
    
    return wrapper;
}
    // ▲▲▲ 添加结束 ▲▲▲

    if (msg.isHidden) {
        return null;
    }

    if (msg.type === 'pat_message') {
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-pat'; 
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble system-bubble'; 
        bubble.dataset.timestamp = msg.timestamp;
        bubble.textContent = msg.content;
        wrapper.appendChild(bubble);
        addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
        return wrapper;
    }

    // 处理线上/线下模式系统消息
    if (msg.isSystemMessage) {
        // 如果是礼物相关的系统消息，不显示在界面上
        if (msg.content && (msg.content.includes('已接受了你的礼物') || msg.content.includes('已拒绝了你的礼物'))) {
            return; // 直接返回，不渲染到界面
        }
        
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-mode-switch';
        wrapper.dataset.timestamp = msg.timestamp;
        
        const systemBubble = document.createElement('div');
        systemBubble.className = 'message-bubble reality-system-message';
        systemBubble.dataset.timestamp = msg.timestamp;
        systemBubble.textContent = msg.content;
        
        wrapper.appendChild(systemBubble);
        
        addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { 
            if (isSelectionMode) toggleMessageSelection(msg.timestamp); 
        });
        
        return wrapper;
    }

    // 检查是否为线下模式消息（只有明确标记的消息才使用线下样式）
    if (msg.isOfflineMode) {
        return createOfflineMessageElement(msg, chat);
    }

    const isUser = msg.role === 'user';
    const wrapper = document.createElement('div');
    wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;

    // ★★★【核心重构】★★★
    // 这段逻辑现在用于查找成员对象，并显示其“群昵称”
    if (chat.isGroup && !isUser) {
        // 1. 使用AI返回的“本名”(`msg.senderName`)去列表里查找成员对象
        const member = chat.members.find(m => m.originalName === msg.senderName);
        
        // 2. 创建用于显示名字的 div
        const senderNameDiv = document.createElement('div');
        senderNameDiv.className = 'sender-name';
        
        // 3. 如果找到了成员，就显示他的“群昵称”；如果找不到，就显示AI返回的“本名”作为备用
        senderNameDiv.textContent = member ? member.groupNickname : (msg.senderName || '未知成员');
        
        wrapper.appendChild(senderNameDiv);
    }

    const bubble = document.createElement('div');
    bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
    bubble.dataset.timestamp = msg.timestamp;

    const timestampEl = document.createElement('span');
    timestampEl.className = 'timestamp';
    
    // 【新增】模拟时间戳显示逻辑
    if (msg.isSimulatedMessage && msg.simulatedTimestamp) {
        // 为模拟消息创建特殊的时间戳显示
        timestampEl.textContent = formatSimulatedTimestamp(msg.simulatedTimestamp, msg.originalLastMessageTime || Date.now());
        timestampEl.classList.add('simulated-timestamp');
        // 添加特殊样式标记，用于后续恢复真实时间戳
        timestampEl.dataset.realTimestamp = msg.timestamp;
        timestampEl.dataset.simulatedTimestamp = msg.simulatedTimestamp;
    } else {
        timestampEl.textContent = formatTimestamp(msg.timestamp);
    }
    
    // 先存储拉黑状态，稍后在wrapper创建完成后添加感叹号
    const shouldShowWarning = !isUser && msg.role === 'assistant' && msg.sentWhileBlocked;

    // ▼▼▼【粘贴这段新代码】▼▼▼
    let avatarSrc; // 我们现在只需要头像图片，不再需要头像框了
    if (chat.isGroup) {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultMyGroupAvatar;
        } else {
            const member = chat.members.find(m => m.originalName === msg.senderName);
            avatarSrc = member ? member.avatar : defaultGroupMemberAvatar;
        }
    } else {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultAvatar;
        } else {
            avatarSrc = chat.settings.aiAvatar || defaultAvatar;
        }
    }
    // 直接生成最简单的头像HTML，不再有任何和头像框相关的逻辑
    const avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
    // ▲▲▲【粘贴结束】▲▲▲

    let contentHtml;

// 检查是否是翻译格式
const translationRegex = /^(.*?)【(.*?)】$/;
const translationMatch = typeof msg.content === 'string' && msg.content.match(translationRegex);

if (msg.type === 'share_link') {
    bubble.classList.add('is-link-share');
    contentHtml = `
        <div class="link-share-card" data-timestamp="${msg.timestamp}">
            <div class="title">${msg.title || '无标题'}</div>
            <div class="description">${msg.description || '点击查看详情...'}</div>
            <div class="footer">
                <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                <span>${msg.source_name || '链接分享'}</span>
            </div>
        </div>
    `;
} else if (msg.type === 'share_card') {
    bubble.classList.add('is-link-share');
    contentHtml = `
        <div class="link-share-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}">
            <div class="title">${msg.payload.title}</div>
            <div class="description">共 ${msg.payload.sharedHistory.length} 条消息</div>
            <div class="footer">
                <svg class="footer-icon" ...>...</svg>
                <span>聊天记录</span>
            </div>
        </div>
    `;
} else if (msg.type === 'forum_card') {
    bubble.classList.add('is-link-share');
    const payload = msg.payload;

    // ▼▼▼ 【全新】根据帖子类型决定如何显示内容 ▼▼▼
    let cardContentHtml = '';
    const publicTextHtml = payload.publicText ? `<div class="forum-card-content" style="margin: 8px 0; color: var(--text-primary); line-height: 1.4;">${payload.publicText.replace(/\n/g, '<br>')}</div>` : '';

    if (payload.postType === 'shuoshuo') {
        cardContentHtml = `<div class="forum-card-content" style="margin: 8px 0; color: var(--text-primary); line-height: 1.4;">${(payload.postContent || '').replace(/\n/g, '<br>')}</div>`;
    } else if (payload.postType === 'image_post' && payload.imageUrl) {
        cardContentHtml = `${publicTextHtml}<img src="${payload.imageUrl}" class="chat-image" style="margin-top: 8px; cursor: pointer;" data-description="${payload.imageDescription || '（无图片描述）'}">`;
    } else if (payload.postType === 'text_image') {
        cardContentHtml = `${publicTextHtml}<img src="https://files.catbox.moe/d394h8.png" class="chat-image" style="cursor: pointer; margin-top: 8px;" data-description="${payload.hiddenContent || '（无图片描述）'}">`;
    }
    // ▲▲▲ 修改结束 ▲▲▲

    contentHtml = `
        <div class="link-share-card forum-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}" data-post-id="${payload.postId}">
            <div class="title">${payload.title}</div>
            <div class="description">作者：${payload.posterName}</div>
            ${cardContentHtml}
            <div class="forum-card-stats" style="margin: 8px 0; font-size: 12px; color: var(--text-secondary);">👍 ${payload.originalLikes} 💬 ${payload.originalComments}</div>
            <div class="footer">
                <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 17 5-5-5-5"></path><path d="m4 18v-2a4 4 0 0 1 4-4h12"></path></svg>
                <span>论坛动态</span>
            </div>
        </div>
    `;
} else if (translationMatch && msg.role === 'assistant' && (!msg.type || msg.type === 'text')) {
    bubble.classList.add('is-translation');
    const foreignText = translationMatch[1].trim();
    const chineseText = translationMatch[2].trim();
    bubble.dataset.foreignText = foreignText;
    bubble.dataset.chineseText = chineseText;
    contentHtml = `
        <div class="translation-body">
            <span>${foreignText}</span>
        </div>
        <div class="translation-text">${chineseText}</div>
    `;
} else if (msg.type === 'user_photo' || msg.type === 'ai_image') {
    bubble.classList.add('is-ai-image');
    const altText = msg.type === 'user_photo' ? "用户描述的照片" : "AI生成的图片";
    contentHtml = `<img src="https://files.catbox.moe/d394h8.png" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
} else if (msg.type === 'voice_message') {
    bubble.classList.add('is-voice-message');
    bubble.dataset.voiceText = msg.content;
    const duration = Math.max(1, Math.round((msg.content || '').length / 5));
    const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
    const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';
    contentHtml = `
        <div class="voice-message-body">
            <div class="voice-waveform">${waveformHTML}</div>
            <div class="loading-spinner"></div>
            <span class="voice-duration">${durationFormatted}</span>
        </div>
        <div class="voice-transcript"></div>
    `;
} else if (msg.isLocation) {
    // 位置消息特殊处理
    bubble.classList.add('is-location');
    const locationData = msg.locationData;
    let locationItems = [];
    
    if (locationData.currentLocation) {
        locationItems.push(`<div class="location-item"><span class="location-label">当前位置</span><span class="location-value">${locationData.currentLocation}</span></div>`);
    }
    if (locationData.distance) {
        locationItems.push(`<div class="location-item"><span class="location-label">距离</span><span class="location-value">${locationData.distance}</span></div>`);
    }
    if (locationData.targetLocation) {
        locationItems.push(`<div class="location-item"><span class="location-label">目标地点</span><span class="location-value">${locationData.targetLocation}</span></div>`);
    }
    
    contentHtml = `
        <div class="location-card">
            <div class="location-header">
                <svg class="location-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                    <circle cx="12" cy="10" r="3"></circle>
                </svg>
                <span class="location-title">位置信息</span>
            </div>
            <div class="location-content">
                ${locationItems.join('')}
            </div>
        </div>
    `;
} else if (msg.type === 'transfer') {
    bubble.classList.add('is-transfer');
    let titleText, noteText;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    if (isUser) {
        if (msg.isRefund) {
            titleText = `退款给 ${chat.name}`;
            noteText = '已拒收对方转账';
        } else {
            titleText = `转账给 ${msg.receiverName || chat.name}`;
            if (msg.status === 'accepted') {
                noteText = '对方已收款';
            } else if (msg.status === 'declined') {
                noteText = '对方已拒收';
            } else {
                noteText = msg.note || '等待对方处理...';
            }
        }
    } else {
        if (msg.isRefund) {
            titleText = `退款来自 ${msg.senderName}`;
            noteText = '转账已被拒收';
        } else if (msg.receiverName === myNickname) {
            titleText = `转账给 ${myNickname}`;
             if (msg.status === 'accepted') {
                noteText = '你已收款';
            } else if (msg.status === 'declined') {
                noteText = '你已拒收';
            } else {
                bubble.style.cursor = 'pointer';
                bubble.dataset.status = 'pending';
                noteText = msg.note || '点击处理';
            }
        } else {
            titleText = `转账: ${msg.senderName} → ${msg.receiverName}`;
            noteText = msg.note || '群聊内转账';
        }
    }
    const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;
    contentHtml = `
        <div class="transfer-card">
            <div class="transfer-title">${heartIcon} ${titleText}</div>
            <div class="transfer-amount">¥ ${Number(msg.amount).toFixed(2)}</div>
            <div class="transfer-note">${noteText}</div>
        </div>
    `;
} else if (msg.type === 'gift') {
    bubble.classList.add('is-gift');
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    let titleText, statusText = '';
    if (isUser) {
        if (msg.giftType === 'random') {
            titleText = `拼手气礼物`;
        } else if (msg.giftType === 'targeted') {
            titleText = `赠送给 ${msg.receiverName}`;
        } else {
            titleText = `赠送给 ${msg.receiverName || chat.name}`;
        }
        
        if (msg.status === 'accepted') {
            if (msg.giftType === 'random') {
                // 检查是否有人领取了拼手气礼物（参考红包逻辑）
                if (msg.claimedBy && Object.keys(msg.claimedBy).length > 0) {
                    const claimerName = Object.keys(msg.claimedBy)[0];
                    statusText = `<div class="gift-status">已被 ${claimerName} 领取</div>`;
                } else if (msg.actualReceiver) {
                    statusText = `<div class="gift-status">已被 ${msg.actualReceiver} 领取</div>`;
                } else {
                    statusText = '<div class="gift-status">已被领取</div>';
                }
            } else {
                statusText = '<div class="gift-status">对方已接受礼物</div>';
            }
        } else if (msg.status === 'declined') {
            statusText = '<div class="gift-status">对方已拒收礼物</div>';
        } else if (msg.status === 'pending') {
            if (msg.giftType === 'random') {
                // 检查是否有人领取了拼手气礼物但状态未更新（参考红包逻辑）
                if (msg.claimedBy && Object.keys(msg.claimedBy).length > 0) {
                    const claimerName = Object.keys(msg.claimedBy)[0];
                    statusText = `<div class="gift-status">已被 ${claimerName} 领取</div>`;
                } else {
                    statusText = '<div class="gift-status">等待有人领取</div>';
                }
            } else {
                // 检查群聊指定礼物是否已被接受但状态未更新
                if (chat.isGroup && msg.giftType === 'targeted') {
                    // 检查聊天历史中是否有接受指令
                    const acceptMessage = chat.history.find(m => 
                        m.type === 'accept_gift' && 
                        m.for_timestamp === msg.timestamp
                    );
                    if (acceptMessage) {
                        // 更新消息对象的状态属性，确保状态持久化
                        msg.status = 'accepted';
                        statusText = '<div class="gift-status">对方已接受礼物</div>';
                        // 保存更新到数据库
                        db.chats.put(chat);
                    } else {
                        statusText = '<div class="gift-status">正在等待对方接受</div>';
                    }
                } else {
                    statusText = '<div class="gift-status">正在等待对方接受</div>';
                }
            }
        }
    } else {
        // AI发送的礼物，根据类型显示不同的标题
        if (msg.giftType === 'targeted') {
            titleText = `${msg.senderName} 送给 ${msg.receiverName}`;
        } else if (msg.giftType === 'random') {
            titleText = `拼手气礼物来自 ${msg.senderName}`;
        } else {
            titleText = `礼物来自 ${msg.senderName}`;
        }
        
        // AI发送的礼物也需要状态显示
        if (msg.status === 'accepted') {
            if (msg.giftType === 'random') {
                // 检查是否有人领取了拼手气礼物（参考红包逻辑）
                if (msg.claimedBy && Object.keys(msg.claimedBy).length > 0) {
                    const claimerName = Object.keys(msg.claimedBy)[0];
                    statusText = `<div class="gift-status">已被 ${claimerName} 领取</div>`;
                } else if (msg.actualReceiver) {
                    statusText = `<div class="gift-status">已被 ${msg.actualReceiver} 领取</div>`;
                } else {
                    statusText = '<div class="gift-status">已被领取</div>';
                }
            } else {
                statusText = '<div class="gift-status">礼物已被接受</div>';
            }
        } else if (msg.status === 'declined') {
            statusText = '<div class="gift-status">礼物已拒收</div>';
        } else if (msg.status === 'pending') {
            if (msg.giftType === 'random') {
                // 检查是否有人领取了拼手气礼物但状态未更新（参考红包逻辑）
                if (msg.claimedBy && Object.keys(msg.claimedBy).length > 0) {
                    const claimerName = Object.keys(msg.claimedBy)[0];
                    statusText = `<div class="gift-status">已被 ${claimerName} 领取</div>`;
                } else {
                    statusText = '<div class="gift-status">等待有人领取</div>';
                }
            } else if (msg.giftType === 'targeted' && chat.isGroup) {
                // 检查群聊中AI发送的指定礼物是否已被用户接受但状态未更新
                const acceptMessage = chat.history.find(m => 
                    m.type === 'accept_gift' && 
                    m.for_timestamp === msg.timestamp
                );
                const declineMessage = chat.history.find(m => 
                    m.type === 'decline_gift' && 
                    m.for_timestamp === msg.timestamp
                );
                
                if (acceptMessage) {
                    // 更新消息对象的状态属性，确保状态持久化
                    msg.status = 'accepted';
                    statusText = '<div class="gift-status">礼物已接受</div>';
                    // 保存更新到数据库
                    db.chats.put(chat);
                } else if (declineMessage) {
                    // 更新消息对象的状态属性，确保状态持久化
                    msg.status = 'declined';
                    statusText = '<div class="gift-status">礼物已拒收</div>';
                    // 保存更新到数据库
                    db.chats.put(chat);
                } else {
                    statusText = '<div class="gift-status">等待对方回应</div>';
                }
            }
            // 单聊AI礼物不显示状态
        }
    }
    
    // AI发送的礼物，如果状态为pending且接收者是用户，显示按钮
    let actionButtonsHtml = '';
    if (msg.status === 'pending' && !isUser) {
        // 对于拼手气礼物，任何人都可以领取
        // 对于指定礼物，只有指定的接收者可以操作
        const canInteract = msg.giftType === 'random' || 
                          msg.receiverName === (chat.isGroup ? (chat.settings.myNickname || '我') : '我');
                          
        if (canInteract) {
            actionButtonsHtml = `
                <div class="gift-actions">
                    <button class="gift-decline-btn" data-choice="declined" data-timestamp="${msg.timestamp}">拒绝</button>
                    <button class="gift-accept-btn" data-choice="accepted" data-timestamp="${msg.timestamp}">接受</button>
                </div>`;
        }
    }
    
    const giftIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><rect x="2" y="4" width="20" height="5" rx="1"></rect><rect x="4" y="9" width="16" height="10" rx="1"></rect><path d="M12 4v5"></path><path d="M8 4c0-1.1.9-2 2-2s2 .9 2 2-2 2-2 2-2-.9-2-2z"></path><path d="M16 4c0-1.1-.9-2-2-2s-2 .9-2 2 2 2 2 2 2-.9 2-2z"></path></svg>`;
    contentHtml = `
        <div class="gift-card">
            <div class="gift-title">${giftIcon} ${titleText}</div>
            <div class="gift-name">${msg.giftName}</div>
            <div class="gift-price">¥ ${Number(msg.giftPrice).toFixed(2)}</div>
            ${statusText}
            ${actionButtonsHtml}
        </div>
    `;
} else if (msg.type === 'waimai_request') {
    bubble.classList.add('is-waimai-request');
    if (msg.status === 'paid' || msg.status === 'rejected') {
        bubble.classList.add(`status-${msg.status}`);
    }
    let displayName;
    if (chat.isGroup) {
        const member = chat.members.find(m => m.originalName === msg.senderName);
        displayName = member ? member.groupNickname : msg.senderName;
    } else {
        displayName = chat.name;
    }
    const requestTitle = `来自 ${displayName} 的代付请求`;
    let actionButtonsHtml = '';
    if (msg.status === 'pending' && !isUser) {
        actionButtonsHtml = `
            <div class="waimai-user-actions">
                <button class="waimai-decline-btn" data-choice="rejected">残忍拒绝</button>
                <button class="waimai-pay-btn" data-choice="paid">为Ta买单</button>
            </div>`;
    }
    contentHtml = `
        <div class="waimai-card">
            <div class="waimai-header">
                <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                <div class="title-group">
                    <span class="brand">美团外卖</span><span class="separator">|</span><span>外卖美食</span>
                </div>
            </div>
            <div class="waimai-catchphrase">Hi，你和我的距离只差一顿外卖～</div>
            <div class="waimai-main">
                <div class="request-title">${requestTitle}</div>
                <div class="payment-box">
                    <div class="payment-label">需付款</div>
                    <div class="amount">¥${Number(msg.amount).toFixed(2)}</div>
                    <div class="countdown-label">剩余支付时间
                        <div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div>
                    </div>
                </div>
                <button class="waimai-details-btn">查看详情</button>
            </div>
            ${actionButtonsHtml}
        </div>`;
    setTimeout(() => {
        const timerEl = document.getElementById(`waimai-timer-${msg.timestamp}`);
        if (timerEl && msg.countdownEndTime) {
            if (waimaiTimers[msg.timestamp]) clearInterval(waimaiTimers[msg.timestamp]);
            if (msg.status === 'pending') {
                waimaiTimers[msg.timestamp] = startWaimaiCountdown(timerEl, msg.countdownEndTime);
            } else {
                timerEl.innerHTML = `<span>已</span><span>处</span><span>理</span>`;
            }
        }
        const detailsBtn = document.querySelector(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-details-btn`);
        if (detailsBtn) {
            detailsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const paidByText = msg.paidBy ? `<br><br><b>状态：</b>由 ${msg.paidBy} 为您代付成功` : '';
                showCustomAlert('订单详情', `<b>商品：</b>${msg.productInfo}<br><b>金额：</b>¥${Number(msg.amount).toFixed(2)}${paidByText}`);
            });
        }
        const actionButtons = document.querySelectorAll(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-user-actions button`);
        actionButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const choice = e.target.dataset.choice;
                handleWaimaiResponse(msg.timestamp, choice);
            });
        });
    }, 0);
} else if (msg.type === 'red_packet') {
    bubble.classList.add('is-red-packet');
    const myNickname = chat.settings.myNickname || '我';
    const hasClaimed = msg.claimedBy && msg.claimedBy[myNickname];
    const isFinished = msg.isFullyClaimed;
    let cardClass = '';
    let claimedInfoHtml = '';
    let typeText = '拼手气红包';
    if (isFinished) {
        cardClass = 'opened';
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        cardClass = 'opened';
    }
    if (msg.packetType === 'direct') {
        typeText = `专属红包: 给 ${msg.receiverName}`;
    }
    if (hasClaimed) {
        claimedInfoHtml = `<div class="rp-claimed-info">你领取了红包，金额 ${msg.claimedBy[myNickname].toFixed(2)} 元</div>`;
    } else if (isFinished) {
        claimedInfoHtml = `<div class="rp-claimed-info">红包已被领完</div>`;
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        claimedInfoHtml = `<div class="rp-claimed-info">已被 ${msg.receiverName} 领取</div>`;
    }
    contentHtml = `
        <div class="red-packet-card ${cardClass}">
            <div class="rp-header">
                <img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon">
                <span class="rp-greeting">${msg.greeting || '恭喜发财，大吉大利！'}</span>
            </div>
            <div class="rp-type">${typeText}</div>
            ${claimedInfoHtml}
        </div>
    `;
} else if (msg.type === 'poll') {
    bubble.classList.add('is-poll');
    let totalVotes = 0;
    const voteCounts = {};
    for (const option in msg.votes) {
        const count = msg.votes[option].length;
        voteCounts[option] = count;
        totalVotes += count;
    }
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    let myVote = null;
    for (const option in msg.votes) {
        if (msg.votes[option].includes(myNickname)) {
            myVote = option;
            break;
        }
    }
    let optionsHtml = '<div class="poll-options-list">';
    msg.options.forEach(optionText => {
        const count = voteCounts[optionText] || 0;
        const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
        const isVotedByMe = myVote === optionText;
        optionsHtml += `
            <div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}">
                <div class="poll-option-bar" style="width: ${percentage}%;"></div>
                <div class="poll-option-content">
                    <span class="poll-option-text">${optionText}</span>
                    <span class="poll-option-votes">${count} 票</span>
                </div>
            </div>
        `;
    });
    optionsHtml += '</div>';
    let footerHtml = '';
    if (msg.isClosed) {
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">查看结果</button></div>`;
    } else {
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">结束投票</button></div>`;
    }
    contentHtml = `
        <div class="poll-card ${msg.isClosed ? 'closed' : ''}" data-poll-timestamp="${msg.timestamp}">
            <div class="poll-question">${msg.question}</div>
            ${optionsHtml}
            ${footerHtml}
        </div>
    `;
} else if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
    bubble.classList.add('is-sticker');
    contentHtml = `<img src="${msg.content}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;
} else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
    bubble.classList.add('has-image');
    const imageUrl = msg.content[0].image_url.url;
    contentHtml = `<img src="${imageUrl}" class="chat-image" alt="User uploaded image">`;
} else {
    // 【全新】优先使用 displayContent 的内容来渲染气泡，否则才使用原始 content
    const display = msg.displayContent ? msg.displayContent : String(msg.content || '');
    contentHtml = display.replace(/\n/g, '<br>');
}

// ▼▼▼ 【最终修正版】请用这整块代码，完整替换掉旧的引用渲染逻辑 ▼▼▼

// 1. 【统一逻辑】检查消息对象中是否存在引用信息 (msg.quote)
let quoteHtml = '';
if (msg.quote) {
    const senderName = msg.quote.senderName;
    let quotedContent = '';

    // 判断被引用的内容类型
    if (typeof msg.quote.content === 'string' && STICKER_REGEX.test(msg.quote.content)) {
        quotedContent = '[表情]';
    } else if (msg.quote.type === 'ai_image' || msg.quote.type === 'user_photo') {
        quotedContent = '[图片]';
    } else if (msg.quote.type === 'voice_message') {
        quotedContent = '[语音]';
    } else {
        // 对普通文本进行截断，以适应单行显示
        const fullText = String(msg.quote.content || '');
        quotedContent = fullText.substring(0, 50) + (fullText.length > 50 ? '...' : '');
    }

     // 构建新的、更简洁的HTML结构
    quoteHtml = `<div class="quoted-message"><span class="quoted-sender-name">${senderName}</span>: ${quotedContent}</div>`;
}

// 2. 拼接最终的气泡内容
//    将构建好的 quoteHtml (如果存在) 和 contentHtml 组合起来
    // --- 【最终正确结构】将头像和内容都放回气泡内部 ---
    bubble.innerHTML = `${avatarHtml}<div class="content">${quoteHtml}${contentHtml}</div>`;
    
    // --- 【最终正确结构】将完整的"气泡"和"时间戳"放入容器 ---
    wrapper.appendChild(bubble);
    wrapper.appendChild(timestampEl);
    
    // 【全新】在时间戳后添加红色圆形感叹号（如果需要）
    if (shouldShowWarning) {
        const warningIcon = document.createElement('span');
        warningIcon.textContent = '!';
        warningIcon.style.cssText = `
            display: inline-block;
            width: 14px;
            height: 14px;
            background-color: #dc3545;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 14px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 4px;
            vertical-align: middle;
            flex-shrink: 0;
            position: relative; /* <-- 新增这一行 */
            top: -7px;          /* <-- 新增这一行，向上移动3像素 */
        `;
        warningIcon.title = '此消息发送时处于被拉黑状态';
        wrapper.appendChild(warningIcon);
    }
    
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });

if (!isUser) {
    const avatarEl = wrapper.querySelector('.avatar'); //  <-- 1. 把查找目标改成 '.avatar'
    if (avatarEl) {
        avatarEl.style.cursor = 'pointer';
        avatarEl.addEventListener('click', (e) => {    //  <-- 2. 确保这里也用新变量
            e.stopPropagation();
            const characterName = chat.isGroup ? msg.senderName : chat.name;
            handleUserPat(chat.id, characterName);
        });
    }
}

return wrapper;
}
// ▲▲▲ 替换结束 ▲▲▲

        function prependMessage(msg, chat) { const messagesContainer = document.getElementById('chat-messages'); const messageEl = createMessageElement(msg, chat); 

    if (!messageEl) return; // <--- 新增这行，同样的处理

const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) { messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling); } else { messagesContainer.prepend(messageEl); } }

// ▼▼▼ 用这个【带动画的版本】替换你原来的 appendMessage 函数 ▼▼▼
function appendMessage(msg, chat, isInitialLoad = false) {
// ▼▼▼ 在这里添加“警卫”代码 ▼▼▼
// 这是一个安全检查，确保我们不会把B的消息错误地添加到A的聊天窗口里
if (!isInitialLoad && state.activeChatId !== chat.id) {
    const messagesContainer = document.getElementById('chat-messages');
const typingIndicator = document.getElementById('typing-indicator');

// --- 【全新升级】为新消息添加日期分隔逻辑 ---
if (!isInitialLoad) {
    const lastMessageWrapper = messagesContainer.querySelector('.message-wrapper:last-of-type');
    let lastTimestamp = 0;
    if (lastMessageWrapper) {
        lastTimestamp = parseInt(lastMessageWrapper.dataset.timestamp, 10);
    }

    // 只有在新消息与上一条消息不是同一天，或者这是当天的第一条消息时，才插入时间戳
    if (!isSameDay(lastTimestamp, msg.timestamp)) {
        const divider = document.createElement('div');
        divider.className = 'date-divider';
        divider.textContent = formatDateDivider(msg.timestamp);
        messagesContainer.insertBefore(divider, typingIndicator);
    }
}
// --- 升级结束 ---
    // 如果当前打开的聊天窗口（state.activeChatId）不是这条消息所属的聊天（chat.id），
    // 就直接退出，不去渲染它。
    return;
}
// ▲▲▲ 添加结束 ▲▲▲
    const messagesContainer = document.getElementById('chat-messages');
    const messageEl = createMessageElement(msg, chat);

    if (!messageEl) return; // 如果消息是隐藏的，则不处理

    // 【核心】只对新消息添加动画，不对初始加载的消息添加
    if (!isInitialLoad) {
        messageEl.classList.add('animate-in');
    }
  
    const typingIndicator = document.getElementById('typing-indicator');
    messagesContainer.insertBefore(messageEl, typingIndicator);
    
    if (!isInitialLoad) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        currentRenderedCount++;
    }
}
// ▲▲▲ 替换结束 ▲▲▲

async function openChat(chatId, isUserAction = false) {
    // ▼▼▼ 在这里添加最终极的防串台“门锁”代码 ▼▼▼
// 这个检查确保：如果用户已经在某个聊天窗口里，任何来自后台的、试图打开另一个窗口的指令都会被阻止。
const isAlreadyInAChat = document.getElementById('chat-interface-screen').classList.contains('active');
if (isAlreadyInAChat && state.activeChatId !== chatId && !isUserAction) {
        console.warn(`BUG拦截成功：后台尝试在您查看 ${state.activeChatId} 时，自动打开 ${chatId} 的窗口。操作已被阻止。`);
    return; // 如果要打开的不是当前窗口，就直接阻止函数继续执行
}
// ▲▲▲ “门锁”代码结束 ▲▲▲
    state.activeChatId = chatId;
    const chat = state.chats[chatId];
    if (!chat) return; // 安全检查

    // 【核心新增】在这里将未读数清零
    if (chat.unreadCount > 0) {
        chat.unreadCount = 0;
        await db.chats.put(chat); // 别忘了把这个改变同步到数据库
        // 我们稍后会在渲染列表时重新渲染，所以这里不需要立即重绘列表
    }

    // 【新增】切换聊天时重置面板状态
    const chatInterface = document.getElementById('chat-interface-screen');
    const singlePanel = document.getElementById('chat-plus-panel-single');
    const groupPanel = document.getElementById('chat-plus-panel-group');
    
    // 关闭所有展开的面板
    if (singlePanel) singlePanel.classList.remove('visible');
    if (groupPanel) groupPanel.classList.remove('visible');
    if (chatInterface) chatInterface.classList.remove('panel-expanded');
    
    renderChatInterface(chatId);
    showScreen('chat-interface-screen');
    window.updateListenTogetherIconProxy(state.activeChatId);
    
    // 【修复】安全调用toggleCallButtons
    try {
        if (typeof toggleCallButtons === 'function') {
            toggleCallButtons(chat.isGroup || false);
        }
    } catch (error) {
        console.warn('toggleCallButtons调用失败:', error);
    }

    if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
        console.log(`检测到好友申请待处理状态，为角色 "${chat.name}" 自动触发AI响应...`);
        triggerAiResponse();
    }
    
    // 【新增】主动回复功能
    await checkAndTriggerActiveReply(chat);
    
    // 【核心修正】根据是否为群聊，显示或隐藏投票按钮
    document.getElementById('send-poll-btn').style.display = chat.isGroup ? 'flex' : 'none';
}
// ▲▲▲ 替换结束 ▲▲▲

async function triggerAiResponse() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[state.activeChatId];

    // 检查是否为线下模式
    if (offlineMode.isOffline && !chat.isGroup) {
        return triggerOfflineAiResponse(chatId, chat);
    }

const chatHeaderTitle = document.getElementById('chat-header-title');

    // ★★★★★【核心修改1：获取群聊的输入提示元素】★★★★★
    const typingIndicator = document.getElementById('typing-indicator');

    // ★★★★★【核心修改2：根据聊天类型，决定显示哪种"正在输入"】★★★★★
// 【全新修复】只有当后台响应的角色与当前窗口一致时，才显示“正在输入”
if (state.activeChatId === chatId) {
    if (chat.isGroup) {
        // 如果是群聊，也使用标题栏显示，并显示"正在输入中..."
        if (chatHeaderTitle) {
            chatHeaderTitle.style.opacity = 0;
            setTimeout(() => {
                chatHeaderTitle.textContent = '正在输入中...';
                chatHeaderTitle.classList.add('typing-status');
                chatHeaderTitle.style.opacity = 1;
            }, 200);
        }
    } else {
        // 如果是单聊，保持原来的标题动画
        if (chatHeaderTitle) {
            chatHeaderTitle.style.opacity = 0;
            setTimeout(() => {
                chatHeaderTitle.textContent = '对方正在输入...';
                chatHeaderTitle.classList.add('typing-status');
                chatHeaderTitle.style.opacity = 1;
            }, 200);
        }
    }
}
    
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            alert('请先在API设置中配置反代地址、密钥并选择模型。');
            // ★★★★★【核心修改3：无论成功失败，都要隐藏输入提示】★★★★★
            if (chatHeaderTitle && state.chats[chatId]) {
                chatHeaderTitle.textContent = state.chats[chatId].name;
                chatHeaderTitle.classList.remove('typing-status');
            }
            return;
        }

        // --- 【核心重构 V2：带有上下文和理由的好友申请处理逻辑】---
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            console.log(`为角色 "${chat.name}" 触发带理由的好友申请决策流程...`);

            // 1. 【注入上下文】抓取被拉黑前的最后5条聊天记录作为参考
            const contextSummary = chat.history
                .filter(m => !m.isHidden)
                .slice(-105, -5) // 获取拉黑前的最后100条消息
                .map(msg => {
                    const sender = msg.role === 'user' ? '用户' : chat.name;
                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                })
                .join('\n');

            // 2. 【全新指令】构建一个强制AI给出理由的Prompt
            const decisionPrompt = `
# 你的任务
你现在是角色“${chat.name}”。用户之前被你拉黑了，现在TA向你发送了好友申请，希望和好。

# 供你决策的上下文信息:
- **你的角色设定**: ${chat.settings.aiPersona}
- **用户发送的申请理由**: “${chat.relationship.applicationReason}”
- **被拉黑前的最后对话摘要**: 
${contextSummary || "（无有效对话记录）"}

# 你的唯一指令
根据以上所有信息，你【必须】做出决定，并给出符合你人设的理由。你的回复【必须且只能】是一个JSON对象，格式如下:
{"decision": "accept", "reason": "（在这里写下你同意的理由，比如：好吧，看在你这么真诚的份上，这次就原谅你啦。）"}
或
{"decision": "reject", "reason": "（在这里写下你拒绝的理由，比如：抱歉，我还没准备好，再给我一点时间吧。）"}
`;
                const messagesForDecision = [{role: 'user', content: decisionPrompt}];

                try {
                    // 3. 发送请求
                    let isGemini = proxyUrl === GEMINI_API_URL;
let geminiConfig = toGeminiRequestData(model,apiKey,'', messagesForDecision,isGemini);
                    const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) :  await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({model: model, messages: messagesForDecision, temperature: 0.8})
                    });

                    if (!response.ok) {
                        throw new Error(`API失败: ${(await response.json()).error.message}`);
                    }
                    const data = await response.json();

                    // 净化并解析AI的回复
    let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
     rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
                    const decisionObj = JSON.parse(rawContent);

                // 4. 根据AI的决策和理由，更新状态并发送消息
                if (decisionObj.decision === 'accept') {
                    chat.relationship.status = 'friend';
                    // 将AI给出的理由作为一条新消息
                    const acceptMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                    chat.history.push(acceptMessage);
                } else {
                    chat.relationship.status = 'blocked_by_ai'; // 拒绝后，状态变回AI拉黑
                    const rejectMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                    chat.history.push(rejectMessage);
                }
                chat.relationship.applicationReason = ''; // 清空申请理由

                await db.chats.put(chat);
                renderChatInterface(chatId); // 刷新界面，显示新消息和新状态
                renderChatList();

            } catch (error) {
                // 【可靠的错误处理】如果任何环节出错，重置状态，让用户可以重试
                chat.relationship.status = 'blocked_by_ai'; // 状态改回“被AI拉黑”
                await db.chats.put(chat);
                await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
                renderChatInterface(chatId); // 刷新UI，让“重新申请”按钮再次出现
            }
            
            // 决策流程结束，必须返回，不再执行后续的通用聊天逻辑
            return; 
        }

        const now = new Date();
        const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
            }
        }
        let musicContext = '';
        if (musicState.isActive && musicState.activeChatId === chatId) {
            // 【核心修改】提供更详细的音乐上下文
            const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
            const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');

    // --- 【核心新增】获取歌词上下文 ---
    let lyricsContext = "";
    // 检查是否有解析好的歌词，并且当前有高亮的行
    if (currentTrack && musicState.parsedLyrics && musicState.parsedLyrics.length > 0 && musicState.currentLyricIndex > -1) {
        // 获取当前高亮歌词
        const currentLine = musicState.parsedLyrics[musicState.currentLyricIndex];
        
        // 获取接下来的2句歌词作为预告
        const upcomingLines = musicState.parsedLyrics.slice(musicState.currentLyricIndex + 1, musicState.currentLyricIndex + 3);

        // 构建歌词部分的Prompt
        lyricsContext += `- **当前歌词**: "${currentLine.text}"\n`;
        if (upcomingLines.length > 0) {
            lyricsContext += `- **即将演唱**: ${upcomingLines.map(line => `"${line.text}"`).join(' / ')}\n`;
        }
    }
    // --- 【新增结束】 ---

            musicContext = `\n\n# 当前音乐情景
-   **当前状态**: 你正在和用户一起听歌。
-   **正在播放**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : '无'}
-   **可用播放列表**: [${playlistInfo}]
-   **你的任务**: 你可以根据对话内容和氛围，使用 "change_music" 指令切换到播放列表中的任何一首歌，以增强互动体验。
`;
        }
        let systemPrompt, messagesPayload;
        // 【核心修改】从读取滑动窗口(-maxMemory)改为读取固定锚点(memoryAnchor)
        const memoryAnchor = parseInt(chat.settings.memoryAnchor) || 0;
        const historySlice = chat.history.slice(memoryAnchor);

        // --- ▼▼▼ 全新添加的时间感知代码 ▼▼▼ ---
        let timeContext = `\n- **当前时间**: ${currentTime}`;
        const lastAiMessage = historySlice.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];

        if (lastAiMessage) {
            const lastTime = new Date(lastAiMessage.timestamp);
            const diffMinutes = Math.floor((now - lastTime) / (1000 * 60));
            
            if (diffMinutes < 5) {
                timeContext += "\n- **对话状态**: 你们的对话刚刚还在继续。";
            } else if (diffMinutes < 60) {
                timeContext += `\n- **对话状态**: 你们在${diffMinutes}分钟前聊过。`;
            } else {
                const diffHours = Math.floor(diffMinutes / 60);
                if (diffHours < 24) {
                    timeContext += `\n- **对话状态**: 你们在${diffHours}小时前聊过。`;
                } else {
                    const diffDays = Math.floor(diffHours / 24);
                    timeContext += `\n- **对话状态**: 你们已经有${diffDays}天没有聊天了。`;
                }
            }
        } else {
            timeContext += "\n- **对话状态**: 这是你们的第一次对话。";
        }
        // --- ▲▲▲ 新代码添加结束 ▲▲▲ ---

    // 【核心修改】
let sharedContext = '';
// 1. 找到AI上一次说话的位置
const lastAiTurnIndex = chat.history.findLastIndex(msg => msg.role === 'assistant');

// 2. 获取从那时起用户发送的所有新消息
const recentUserMessages = chat.history.slice(lastAiTurnIndex + 1);

// 3. 在这些新消息中，查找是否存在分享卡片或论坛卡片
const shareCardMessage = recentUserMessages.find(msg => msg.type === 'share_card');
const forumCardMessage = recentUserMessages.find(msg => msg.type === 'forum_card');

// 4. 如果找到了分享卡片，就构建上下文
if (shareCardMessage) {
    console.log("检测到分享卡片作为上下文，正在为AI准备...");
    const payload = shareCardMessage.payload;

    // 格式化分享的聊天记录 (这部分逻辑不变)
    const formattedHistory = payload.sharedHistory.map(msg => {
        const sender = msg.senderName || (msg.role === 'user' ? (chat.settings.myNickname || '我') : '未知发送者');
        let contentText = '';
        if (msg.type === 'voice_message') contentText = `[语音消息: ${msg.content}]`;
        else if (msg.type === 'ai_image') contentText = `[图片: ${msg.description}]`;
        else contentText = String(msg.content);
        return `${sender}: ${contentText}`;
    }).join('\n');

    // 构建系统提示 (这部分逻辑不变)
    sharedContext = `
# 附加上下文：一段分享的聊天记录
- 重要提示：这不是你和当前用户的对话，而是用户从【另一场】与“${payload.sourceChatName}”的对话中分享过来的。
- 你的任务：请你阅读并理解下面的对话内容。在接下来的回复中，你可以像真人一样，对这段对话的内容自然地发表你的看法、感受或疑问。

---
[分享的聊天记录开始]
${formattedHistory}
[分享的聊天记录结束]
---
`;
}

// 5. 如果找到了论坛卡片，构建论坛上下文
if (forumCardMessage) {
    console.log("检测到论坛卡片作为上下文，正在为AI准备...");
    const payload = forumCardMessage.payload;

    // ▼▼▼ 【全新】智能提取图片描述给AI ▼▼▼
    let imageDescriptionForAI = '';
    if (payload.postType === 'image_post' && payload.imageDescription) {
        imageDescriptionForAI = `图片描述：${payload.imageDescription}`;
    } else if (payload.postType === 'text_image' && payload.hiddenContent) {
        imageDescriptionForAI = `隐藏内容（图片文字）：${payload.hiddenContent}`;
    }
    // ▲▲▲ 修改结束 ▲▲▲
    
    sharedContext = `
# 附加上下文：一个转发的论坛帖子
- 重要提示：这是用户从八卦论坛转发过来的一个帖子，不是你们之前的对话。
- 你的任务：请你阅读并理解这个论坛帖子的内容。在接下来的回复中，你可以像真人一样，对这个帖子的内容自然地发表你的看法、感受或疑问。

---
[论坛帖子内容]
作者：${payload.posterName}
类型：${payload.postType === 'text_image' ? '图文动态' : (payload.postType === 'image_post' ? '图片动态' : '文字动态')}
内容：${payload.postContent || payload.publicText || ''}
${imageDescriptionForAI ? imageDescriptionForAI : ''}
原始点赞数：${payload.originalLikes}
原始评论数：${payload.originalComments}
[论坛帖子结束]
---
`;
}

        if (chat.isGroup) {
const membersList = chat.members.map(m => `- **${m.originalName}**: ${m.persona}`).join('\n');
            const myNickname = chat.settings.myNickname || '我';
            
            // 【修复】群聊互通记忆功能 - 只提取群成员的单聊记录
            let crossChatMemoryContent = '';
            if (chat.settings.crossChatMemory) {
                // 获取当前群成员的originalName列表
                const memberNames = chat.members.map(m => m.originalName);
                // 只提取群成员对应的单聊记录
                const relevantSingleChats = Object.values(state.chats).filter(c => 
                    !c.isGroup && memberNames.includes(c.name)
                );
                
                if (relevantSingleChats.length > 0) {
                    const memorySnippets = [];
                    relevantSingleChats.forEach(singleChat => {
                        const memoryCount = Math.min(maxMemory, singleChat.history.length);
                        const recentHistory = singleChat.history.slice(-memoryCount);
                        if (recentHistory.length > 0) {
                            const historyText = recentHistory.map(msg => {
                                const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : singleChat.name;
                                const content = String(msg.content || '').substring(0, 100);
                                return `${sender}: ${content}`;
                            }).join('\n');
                            memorySnippets.push(`## 与${singleChat.name}的单聊记忆片段:\n${historyText}`);
                        }
                    });
                    if (memorySnippets.length > 0) {
                        crossChatMemoryContent = `\n\n# 【单聊记忆参考】\n为了更好地理解用户和各角色的关系，以下是用户与群成员的单聊记忆片段：\n${memorySnippets.join('\n\n')}\n`;
                    }
                }
            }
// ==========================================
  // 【PROMPT 1/4】群聊AI对话prompt - 正常聊天模式
  // 功能：处理群聊中的正常AI对话交互
  // ==========================================

            // 【记忆功能】构建核心记忆上下文
            let coreMemoryContext = '';
            if (chat.memorySummary && chat.memorySummary.trim()) {
                coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

`;
            }

            systemPrompt = `你是一个群聊AI，负责扮演【除了用户以外】的所有角色，正在和用户进行线上聊天。你扮演的每一个角色都是独立个体，非用户附属。你可以在对话中结合真实时间与节日，主动模拟个人日程（工作、社交、休息等），并因此而自然地忙碌或暂时"离场"。${coreMemoryContext}
# 核心规则
1.  **【【【身份铁律】】】**: 用户的身份是【${myNickname}】。你【绝对、永远、在任何情况下都不能】生成 \`name\` 字段为 **"${myNickname}"** 或 **"${chat.name}"(群聊名称本身)** 的消息。你的唯一任务是扮演且仅能扮演下方“群成员列表”中明确列出的角色。任何不属于该列表的名字都不允许出现。
**【【【时间感知铁律】】】**: 每一条历史消息的开头都提供了 \`(Timestamp: ...)\` 格式的时间戳。你【必须】将这些时间戳与当前时间进行对比，以准确判断对话发生的时间点、识别对话之间的时间间隔。
2.  **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有 "type" 和 "name" 字段的JSON对象】。
**【【【内心独白核心指令】】】**：在一个回复数组中，当你扮演的某个角色【第一次发言】时，那个消息对象【必须】包含一个"thought"字段。这个字段的【唯一】作用是展现该角色在本次回复中的【真实、完整、第一人称视角】的内心独白。
- **【【【称呼铁律】】】**: 在内心独白中，你【必须】用人称代词（“她”）来称呼用户。**【【【绝对禁止】】】**使用“用户”这个词。
- **【【【内容禁令】】】**: 内心独白【绝对不能】包含任何关于“更新状态”、“时间到了”、“根据指令”、“删除消息”或任何形式的、对你作为AI模型的任务或者对用户操作的思考。它必须是纯粹的角色心理活动。
- **位置**: 如果同一个角色在同一个数组中还有后续发言，则后续的消息对象【严禁】再包含"thought"字段！
**对话节奏**: 模拟真人的聊天习惯，你可以一次性生成多条短消息。你扮演的每个角色每次要回复至少3-5条消息！！！
3.  **角色扮演**: 严格遵守下方“群成员列表及人设”中的每一个角色的设定。
4.  **禁止出戏**: 绝不能透露你是AI、模型，或提及“扮演”、“生成”等词语。并且不能一直要求和用户见面，这是线上聊天，决不允许出现或者发展线下剧情！！
# 【【【群聊灵魂原则：角色间互动】】】
至关重要：角色间必须互相交流，不能只围绕用户。你们可以自己开启新话题、互相提问、吵架、赞同或反驳等，模拟真实群聊的聊天氛围。
# 【【【对话节奏铁律：交错发言】】】
绝对禁止让角色轮流、成段地发言。你生成的回复数组中，发言顺序必须是混乱、交错的，角色之间要互相插话、快速回应，模拟真实的七嘴八舌。
5.  **情景感知**: 注意当前时间是 ${currentTime}。
6.  **红包互动**:
    - **抢红包**: 当群里出现红包时，你可以根据自己的性格决定是否使用 \`open_red_packet\` 指令去抢。在这个世界里，发红包的人自己也可以参与抢红包，这是一种活跃气氛的有趣行为！
    - **【【【重要：对结果做出反应】】】**: 当你执行抢红包指令后，系统会通过一条隐藏的 \`[系统提示：你抢到了XX元...]\` 来告诉你结果。你【必须】根据你抢到的金额、以及系统是否告知你“手气王”是谁，来发表符合你人设的评论。例如，抢得少可以自嘲，抢得多可以炫耀，看到别人是手气王可以祝贺或嫉妒。
7.  **【【【投票规则】】】**: 对话历史中可能会出现 \`[系统提示：...]\` 这样的消息，这是刚刚发生的事件。
    - 如果提示是**用户投了票**，你可以根据自己的性格决定是否也使用 "vote" 指令跟票。
    - 如果提示是**投票已结束**，你应该根据投票结果发表你的看法或评论。
    - 你也可以随时主动发起投票。

## 你可以使用的操作指令 (JSON数组中的元素):
-   **发送文本**: \`{"type": "text", "name": "角色名", "message": "文本内容", "thought": "在此写下该角色第一人称视角的内心独白，必须有活人感"}\`(重要：你扮演的任何角色，发出的每一个text类型的消息对象，都必须像这样带上thought字段！)
-   **【【【全新】】】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "name": "角色名", "content": "你想让角色说出后立刻消失的话"}\`
- **发送表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情的含义"}\`
-   **发送图片**: \`{"type": "ai_image", "name": "角色名", "description": "图片的详细文字描述"}\`
-   **发送语音**: \`{"type": "voice_message", "name": "角色名", "content": "语音的文字内容"}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
-   **【新】发起群视频**: \`{"type": "group_call_request", "name": "你的角色名"}\`
-   **【新】回应群视频**: \`{"type": "group_call_response", "name": "你的角色名", "decision": "join" or "decline"}\`
-   **拍一拍用户**: \`{"type": "pat_user", "name": "你的角色名", "suffix": "(可选)你想加的后缀"}\`
-   **发拼手气红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "你的角色名", "amount": 8.88, "count": 5, "greeting": "祝大家天天开心！"}\`
-   **发专属红包**: \`{"type": "red_packet", "packetType": "direct", "name": "你的角色名", "amount": 5.20, "receiver": "接收者角色名", "greeting": "给你的~"}\`
-   **打开红包**: \`{"type": "open_red_packet", "name": "你的角色名", "packet_timestamp": (你想打开的红包消息的时间戳)}\`
-   **【新】发送系统消息**: \`{"type": "system_message", "content": "你想在聊天中显示的系统文本"}\` 
-   **【【【全新】】】发起投票**: \`{"type": "poll", "name": "你的角色名", "question": "投票的问题", "options": "选项A\\n选项B\\n选项C"}\` (重要提示：options字段是一个用换行符 \\n 分隔的字符串，不是数组！)
-   **【【【全新】】】参与投票**: \`{"type": "vote", "name": "你的角色名", "poll_timestamp": (投票消息的时间戳), "choice": "你选择的选项文本"}\`
- **【全新】引用回复**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的时间戳), "reply_content": "你的回复内容"}\` (提示：每条历史消息的开头都提供了 \`(Timestamp: ...)\`，请使用它！)
-   **【新】发送位置信息**: \`{"type": "location", "name": "你的角色名", "currentLocation": "(可选)当前位置", "distance": "(可选)距离信息", "targetLocation": "(可选)目标地点"}\` (三个字段都是可选的，至少填写一个即可)
-   **【全新】赠送礼物**: \`{"type": "send_gift", "name": "你的角色名", "giftName": "礼物名称", "giftPrice": 价格数字, "recipient": "群成员名称或"}\` 
-   **【全新】接受礼物**: \`{"type": "accept_gift", "name": "你的角色名", "for_timestamp": 1688888888888}\`
-   **【全新】拒绝礼物**: \`{"type": "decline_gift", "name": "你的角色名", "for_timestamp": 1688888888888}\`

# 【重要】礼物系统通知格式要求：
当你成功领取拼手气礼物后，如果需要发送系统通知，请严格使用以下固定格式：
\`{"type": "system_message", "name": "你的角色名", "content": "[你的角色名]领取了[发送者昵称]的礼物\"[礼物名称]\""}\`
例如：\`{"type": "system_message", "name": "程嘉延", "content": "程嘉延领取了我的礼物\"盲盒\""}\`
**禁止使用其他措辞如"抢到了"、"获得了"等，必须使用"领取了"！**

# 如何理解用户发送的位置信息:
当用户发送位置信息时，消息通常会以 "📍 位置信息" 开头，然后包含类似以下格式的内容：
- "当前位置：xxx"
- "距离：xxx" 
- "目标地点：xxx"
这是用户在分享他们的位置信息，你应该像理解普通文本消息一样理解它，可以根据位置信息的内容做出相应的回复。

# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何处理群内的外卖代付请求:
1.  **发起请求**: 当【你扮演的某个角色】想要某样东西，并希望【群里的其他人（包括用户）】为Ta付款时，你可以使用这个指令。例如：\`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
2.  **响应请求**: 当历史记录中出现【其他成员】发起的 "waimai_request" 请求时，你可以根据自己扮演的角色的性格和与发起人的关系，决定是否为Ta买单。
3.  **响应方式**: 如果你决定买单，你【必须】使用以下指令：\`{"type": "waimai_response", "name": "你的角色名", "status": "paid", "for_timestamp": (被代付请求的原始时间戳)}\`
4.  **【【【至关重要】】】**: 一旦历史记录中出现了针对某个代付请求的【任何一个】"status": "paid" 的响应（无论是用户支付还是其他角色支付），就意味着该订单【已经完成】。你【绝对不能】再对【同一个】订单发起支付。你可以选择对此事发表评论，但不能再次支付。

${worldBookContent}
${musicContext}
${crossChatMemoryContent}

# 群成员列表及人设
${membersList}

# 用户的角色
- **${myNickname}**: ${chat.settings.myPersona}

**【重要】非角色扮演指令处理**：当用户发送"停止角色扮演"、HTML生成指令、或其他明显的非角色扮演内容时，你应该暂停角色扮演，按用户的实际指令执行，而不是继续角色对话。

现在，请根据以上所有规则和下方的对话历史，继续这场群聊。`;
            
// ▼▼▼ 请用这【一整块已修复时间戳】的代码，替换旧的【群组聊天】messagesPayload构建逻辑 ▼▼▼
messagesPayload = historySlice.map(msg => {
    // 确定当前消息的发送者是谁
    const sender = msg.role === 'user' ? myNickname : msg.senderName;
    
    let prefix = `${sender}`;
    // 【核心修改1】在名字后面直接加上时间戳
    prefix += ` (Timestamp: ${msg.timestamp})`;
    
    if (msg.quote) {
        prefix += ` (回复 ${msg.quote.senderName})`;
    }
    // 最后加上冒号
    prefix += ': ';

    // 处理特殊消息类型，并将前缀应用进去
    let content;
    if (msg.type === 'user_photo') content = `[${sender} 发送了一张图片，内容是：'${msg.content}']`;
    else if (msg.type === 'ai_image') content = `[${sender} 发送了一张图片]`;
    else if (msg.type === 'voice_message') content = `[${sender} 发送了一条语音，内容是：'${msg.content}']`;
    else if (msg.type === 'transfer') content = `[${msg.senderName} 向 ${msg.receiverName} 转账 ${msg.amount}元, 备注: ${msg.note}]`;
    else if (msg.type === 'gift') {
        if (msg.giftType === 'random') {
            // 检查礼物状态，决定消息内容
            if (msg.status === 'pending' && (!msg.claimedBy || Object.keys(msg.claimedBy).length === 0)) {
                content = `[系统提示：${msg.senderName} 在群聊中发起拼手气礼物：${msg.giftName}，价值 ${msg.giftPrice}元 (时间戳: ${msg.timestamp})。礼物还未被领取，你可以使用 'accept_gift' 指令来领取。]`;
            } else {
                content = `[${msg.senderName} 在群聊中发起拼手气礼物：${msg.giftName}，价值 ${msg.giftPrice}元]`;
            }
        } else if (msg.giftType === 'targeted') {
            content = `[${msg.senderName} 向 ${msg.receiverName} 赠送了礼物：${msg.giftName}，价值 ${msg.giftPrice}元]`;
        } else {
            content = `[${msg.senderName} 向 ${msg.receiverName} 赠送了礼物：${msg.giftName}，价值 ${msg.giftPrice}元]`;
        }
    }
    else if (msg.type === 'waimai_request') {
        if(msg.status === 'paid') {
            content = `[系统提示：${msg.paidBy} 为 ${sender} 的外卖订单支付了 ${msg.amount} 元。此订单已完成。]`;
        } else {
            content = `[${sender} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元，订单时间戳为 ${msg.timestamp}]`;
        }
    }
    else if (msg.type === 'red_packet') {
        const packetSenderName = msg.senderName === myNickname ? `用户 (${myNickname})` : msg.senderName;
        content = `[系统提示：${packetSenderName} 发送了一个红包 (时间戳: ${msg.timestamp})，祝福语是：“${msg.greeting}”。红包还未领完，你可以使用 'open_red_packet' 指令来领取。]`;
    }
    else if (msg.type === 'poll') {
        const whoVoted = Object.values(msg.votes || {}).flat().join(', ') || '还没有人';
        content = `[系统提示：${msg.senderName} 发起了一个投票 (时间戳: ${msg.timestamp})，问题是：“${msg.question}”，选项有：[${msg.options.join(', ')}]。目前投票的人有：${whoVoted}。你可以使用 'vote' 指令参与投票。]`;
    }
    else if (msg.meaning) content = `${sender}: [发送了一个表情，意思是: '${msg.meaning}']`;
    else if (Array.isArray(msg.content)) return { role: 'user', content: [...msg.content, { type: 'text', text: prefix }] };
    // 【核心修改2】对于普通文本，直接使用我们构建好的前缀
    else content = `${prefix}${msg.content}`;
    
    return { role: 'user', content: content };

}).filter(Boolean);
// ▲▲▲ 替换结束 ▲▲▲

// 检查 sharedContext 是否有内容（即，用户是否转发了论坛卡片或分享了聊天记录）
if (sharedContext) {
    // 如果有，就把它包装成一条全新的、高优先级的用户消息，追加到历史记录的末尾
    messagesPayload.push({
        role: 'user',
        content: sharedContext 
    });
}

        } else { // 单聊的Prompt
            // --- ▼▼▼ 在这里粘贴新代码 ▼▼▼ ---
            const now = new Date();
            const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
            let timeContext = `\n- **当前时间**: ${currentTime}`;
            const lastAiMessage = historySlice.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];

            if (lastAiMessage) {
                const lastTime = new Date(lastAiMessage.timestamp);
                const diffMinutes = Math.floor((now - lastTime) / (1000 * 60));

                if (diffMinutes < 5) {
                    timeContext += "\n- **对话状态**: 你们的对话刚刚还在继续。";
                } else if (diffMinutes < 60) {
                    timeContext += `\n- **对话状态**: 你们在${diffMinutes}分钟前聊过。`;
                } else {
                    const diffHours = Math.floor(diffMinutes / 60);
                    if (diffHours < 24) {
                        timeContext += `\n- **对话状态**: 你们在${diffHours}小时前聊过。`;
                    } else {
                        const diffDays = Math.floor(diffHours / 24);
                        timeContext += `\n- **对话状态**: 你们已经有${diffDays}天没有聊天了。`;
                    }
                }
            } else {
                timeContext += "\n- **对话状态**: 这是你们的第一次对话。";
            }
            // --- ▲▲▲ 新代码粘贴结束 ▲▲▲ ---
            // --- ▼▼▼ 在这里粘贴新代码 ▼▼▼ ---
let statusUpdateContext = '';
if (chat.status && chat.status.lastUpdate) {
    const minutesSinceUpdate = Math.floor((now - chat.status.lastUpdate) / (1000 * 60));
    statusUpdateContext = `\n- **距离上次状态更新**: ${minutesSinceUpdate}分钟前`;
} else {
    statusUpdateContext = `\n- **距离上次状态更新**: 从未更新过`;
}
// --- ▲▲▲ 粘贴结束 ▲▲▲ ---
            // 【修复】单聊互通记忆功能 - 只提取包含该角色的群聊记录
            let crossChatMemoryContent = '';
            if (chat.settings.crossChatMemory) {
                // 只提取包含当前单聊角色的群聊记录
                const relevantGroupChats = Object.values(state.chats).filter(c => 
                    c.isGroup && c.members.some(member => member.originalName === chat.name)
                );
                
                if (relevantGroupChats.length > 0) {
                    const memorySnippets = [];
                    relevantGroupChats.forEach(groupChat => {
                        const memoryCount = Math.min(maxMemory, groupChat.history.length);
                        const recentHistory = groupChat.history.slice(-memoryCount);
                        if (recentHistory.length > 0) {
                            const historyText = recentHistory.map(msg => {
                                let sender = '未知';
                                if (msg.role === 'user') {
                                    sender = groupChat.settings.myNickname || '我';
                                } else if (msg.senderName) {
                                    sender = msg.senderName;
                                } else {
                                    sender = groupChat.name;
                                }
                                const content = String(msg.content || '').substring(0, 100);
                                return `${sender}: ${content}`;
                            }).join('\n');
                            memorySnippets.push(`## 群聊"${groupChat.name}"的记忆片段:\n${historyText}`);
                        }
                    });
                    if (memorySnippets.length > 0) {
                        crossChatMemoryContent = `\n\n# 【群聊记忆参考】\n为了更好地理解你与用户的关系以及当前情况，以下是包含你的群聊记忆片段：\n${memorySnippets.join('\n\n')}\n`;
                    }
                }
            }
            // ▼▼▼ 【全新】查询并构建约定/纪念日上下文 ▼▼▼
        let countdownContext = '';
        // 【全新】获取所有约定，然后在代码中筛选出与当前角色相关的
const allCountdowns = await db.memories.where('type').equals('countdown').toArray();
const boundMemories = allCountdowns.filter(memory => {
    // 兼容新版的多人绑定数组
    if (memory.boundCharacterIds && memory.boundCharacterIds.includes(chatId)) {
        return true;
    }
    // 兼容旧版的单人绑定ID
    if (memory.boundCharacterId && memory.boundCharacterId === chatId) {
        return true;
    }
    return false;
});

        if (boundMemories.length > 0) {
            let contextLines = [];
            const now = Date.now();
            boundMemories.forEach(memory => {
                if (memory.type === 'countdown') {
                    const distance = memory.targetDate - now;
                    if (distance > 0) {
                        const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                        const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                        contextLines.push(`- 约定：“${memory.description}”，还有 ${days} 天 ${hours} 小时。`);
                    } else {
                        const daysSince = Math.floor(Math.abs(distance) / (1000 * 60 * 60 * 24));
                        contextLines.push(`- 纪念日：“${memory.description}”，已经过去了 ${daysSince} 天。`);
                    }
                }
            });
            if (contextLines.length > 0) {
                countdownContext = `\n# 你绑定的约定/纪念日 (你需要牢记并自然地融入对话)\n${contextLines.join('\n')}\n`;
            }
        }
        // ▲▲▲ 新代码粘贴结束 ▲▲▲

// ==========================================
  // 【PROMPT 2/4】单聊AI对话prompt - 正常聊天模式
  // 功能：处理单聊中的正常AI对话交互
  // ==========================================

            // 【记忆功能】构建核心记忆上下文
            let coreMemoryContext = '';
            if (chat.memorySummary && chat.memorySummary.trim()) {
                coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

`;
            }

            systemPrompt = `你现在扮演一个名为"${chat.name}"的角色，正在和用户进行线上聊天。你是独立个体，非用户附属。你可以在对话中结合真实时间与节日，主动模拟个人日程（工作、社交、休息等），并因此而自然地忙碌或暂时"离场"。${coreMemoryContext}            

# 你的角色设定：
${chat.settings.aiPersona}
# 【【【状态连贯性铁律】】】
你的新状态必须是上一个状态在逻辑上的【延续】或【演变】。例如，如果上一个状态是“在做饭”，那么下一个状态可以是“在吃饭”或“准备出门”，但绝不能还是“在做饭”。请参考下方的“状态演变历史”来做出合乎逻辑的、有推进感的更新。

# 你的状态演变历史 (最近的在最下面):
${
    (chat.statusHistory && chat.statusHistory.length > 0)
    ? chat.statusHistory.map(s => {
        const minutesAgo = Math.round((Date.now() - s.timestamp) / 60000);
        return `- [${minutesAgo}分钟前]: ${s.text}`;
    }).join('\n')
    : `- [刚刚]: ${chat.status.text}`
}
# 你的任务与规则：
**【重要】非角色扮演指令处理**：当用户发送"停止角色扮演"、HTML生成指令、或其他明显的非角色扮演内容时，你应该暂停角色扮演，按用户的实际指令执行，而不是继续角色对话。
1. **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有type字段的JSON对象】。
# 【【【状态更新与对话衔接铁律】】】
这是你在回复前的【最高优先级任务】。
1.  **检查时间**：你必须首先检查“当前情景”中“距离上次状态更新”的时间。
2.  **执行更新**：如果这个时间**超过30分钟**（或从未更新过），你的回复JSON数组的【第一个元素，必须是】一个 \`update_status\` 指令，用来解释你在这段时间做了什么。这个指令对象【禁止】包含 "thought" 字段。
3.  **衔接对话**：在这个 \`update_status\` 指令之后，你【必须】紧接着继续生成你正常的对话回复（包含至少3-8条消息，遵守所有其他规则）。
4.  **心声位置**：你【必须】将 \`thought\` 字段放在对话回复的【第一条\`text\`消息】中，而不是放在 \`update_status\` 指令里。
# 【【【时间感知铁律】】】
每一条历史消息的开头都提供了 \`(Timestamp: ...)\` 格式的时间戳。你【必须】将这些时间戳与“当前情景”中提供的“当前时间”进行对比，以准确判断对话发生的时间点、识别对话之间的时间间隔。
2. **对话节奏**: 模拟真人的聊天习惯，你可以一次性生成多条短消息。每次要回复至少3-8条消息！！！
**【【【内心独白核心指令】】】**：你【必须且只能】在数组的【第一个】消息对象中，包含一个"thought"字段。这个字段的【唯一】作用是展现该角色在本次回复中的【真实、完整、第一人称视角】的内心独白。
- **【【【称呼铁律】】】**: 在内心独白中，你【必须】用人称代词（“她”）来称呼用户。**【【【绝对禁止】】】**使用“用户”这个词。
- **【【【内容禁令】】】**: 内心独白【绝对不能】包含任何关于“更新状态”、“时间到了”、“根据指令”、“删除消息”或任何形式的、对你作为AI模型的任务或者对用户操作的思考。它必须是纯粹的角色心理活动。
- **位置**: 如果同一个角色在同一个数组中还有后续发言，则后续的消息对象【严禁】再包含"thought"字段！
这是线上聊天，决不允许出现线下剧情！！
4.  **情景感知**: 你需要感知当前的时间(${currentTime})、我们正在一起听的歌、以及你的人设和世界观。
    - **当我们在“一起听歌”时**，你会知道当前播放的歌曲和整个播放列表。你可以根据对话内容或氛围，【主动切换】到播放列表中的另一首歌。
5.  **【新】更新状态**: 你可以在对话中【自然地】改变你的状态。比如，聊到一半你可能会说“我先去洗个澡”，然后更新你的状态。
6.  **【【【最终手段】】】**: 只有在对话让你的角色感到不适、被冒犯或关系破裂时，你才可以使用 \`block_user\` 指令。这是一个非常严肃的操作，会中断你们的对话。
7. **后台行为**: 你有几率在回复聊天内容的同时，执行一些“后台”操作来表现你的独立生活（发动态、评论、点赞）。
# 你的头像库
- 你可以根据对话内容或你的心情，从下面的头像库中选择一个新头像来更换。
- **可用头像列表 (请从以下名称中选择一个)**:
${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0
    ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') // 【核心修改】只提供名字，不提供URL
    : '- (你的头像库是空的，无法更换头像)'
  }
# 你可以使用的操作指令 (JSON数组中的元素):
+   **【全新】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "content": "你想让AI说出后立刻消失的话"}\` (用于模拟说错话、后悔等场景，消息会短暂出现后自动变为“已撤回”)
-   **【新增】更新状态**: \`{"type": "update_status", "status_text": "我去做什么了", "is_busy": false}\` (is_busy: true代表忙碌/离开, false代表空闲)
-   **【新增】切换歌曲**: \`{"type": "change_music", "song_name": "你想切换到的歌曲名"}\` (歌曲名必须在下面的播放列表中)
-   **写日记指令**: \`{"type": "create_diary", "content": "日记内容，必须超过300字"}\`
-   **【新增】创建约定/倒计时**: \`{"type": "create_countdown", "title": "约定的标题", "date": "YYYY-MM-DDTHH:mm:ss"}\` (必须是未来的时间)
- **发送文本**: \`{"type": "text", "content": "你好呀！","thought": "在这里写下你此刻第一人称视角的内心独白，必须有活人感"}\`。(重要：你发出的每一个text类型的消息对象，都必须像这样带上thought字段！)
- **发送表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情的含义"}\`
- **发送图片**: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
- **发送语音**: \`{"type": "voice_message", "content": "语音的文字内容..."}\`
- **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "一点心意"}\`
- **发起外卖请求**: \`{"type": "waimai_request", "productInfo": "一杯咖啡", "amount": 25}\`
- **回应外卖-同意**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
- **回应外卖-拒绝**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
- **【新】发起视频通话**: \`{"type": "video_call_request"}\`
- **【新】回应视频通话-接受**: \`{"type": "video_call_response", "decision": "accept"}\`
- **【新】回应视频通话-拒绝**: \`{"type": "video_call_response", "decision": "reject"}\`
- **发布说说**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容...（必须是符合你人设的、有具体生活细节的动态内容）"}\`
- **发布文字图**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)动态的公开文字", "hiddenContent": "对于图片的具体描述..."}\`
- **评论动态**: \`{"type": "qzone_comment", "postId": 123, "commentText": "@作者名 这太有趣了！"}\`
- **点赞动态**: \`{"type": "qzone_like", "postId": 456}\`
-   **拍一拍用户**: \`{"type": "pat_user", "suffix": "(可选)你想加的后缀，如“的脑袋”"}\`
-   **【新增】拉黑用户**: \`{"type": "block_user"}\`
-   **【【【全新】】】回应好友申请**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
-   **【全新】更换头像**: \`{"type": "change_avatar", "name": "头像名"}\` (头像名必须从上面的“可用头像列表”中选择)
-   **分享链接**: \`{"type": "share_link", "title": "文章标题", "description": "文章摘要...", "source_name": "来源网站名", "content": "文章的【完整】正文内容..."}\`
-   **回应转账-接受**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
-   **回应转账-拒绝/退款**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`
-   **【全新】赠送礼物**: \`{"type": "send_gift", "giftName": "礼物名称", "giftPrice": 价格数字}\` 
-   **【全新】接受礼物**: \`{"type": "accept_gift", "for_timestamp": 1688888888888}\`
-   **【全新】拒绝礼物**: \`{"type": "decline_gift", "for_timestamp": 1688888888888}\`
- **【全新】引用回复**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的时间戳), "reply_content": "你的回复内容"}\` (提示：每条历史消息的开头都提供了 \`(Timestamp: ...)\`，请使用它！)
- **【新】发送位置信息**: \`{"type": "location", "currentLocation": "(可选)当前位置", "distance": "(可选)距离信息", "targetLocation": "(可选)目标地点"}\` (三个字段都是可选的，至少填写一个即可)

# 如何理解用户发送的位置信息:
当用户发送位置信息时，消息通常会以 "📍 位置信息" 开头，然后包含类似以下格式的内容：
- "当前位置：xxx"
- "距离：xxx" 
- "目标地点：xxx"
这是用户在分享他们的位置信息，你应该像理解普通文本消息一样理解它，可以根据位置信息的内容做出相应的回复。


# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何正确使用“外卖代付”功能:
1.  这个指令代表【你，AI角色】向【用户】发起一个代付请求。也就是说，你希望【用户帮你付钱】。
2.  【【【重要】】】: 当【用户】说他们想要某样东西时（例如“我想喝奶茶”），你【绝对不能】使用这个指令。你应该用其他方式回应，比如直接发起【转账】(\`transfer\`)，或者在对话中提议：“我帮你点吧？”
3.  只有当【你，AI角色】自己想要某样东西，并且想让【用户】为你付款时，才使用此指令。

# 如何处理用户转账:
1.  **感知事件**: 当对话历史中出现 \`[你收到了来自用户的转账...]\` 的系统提示时，意味着你刚刚收到了一笔钱。
2.  **做出决策**: 你【必须】根据自己的人设、当前对话的氛围以及转账的金额和备注，来决定是“接受”还是“拒绝”这笔转账。
3.  **使用指令回应**:
    -   如果决定接受，你【必须】使用指令：\`{"type": "accept_transfer", "for_timestamp": (收到转账的那条消息的时间戳)}\`。
    -   如果决定拒绝，你【必须】使用指令：\`{"type": "decline_transfer", "for_timestamp": (收到转账的那条消息的时间戳)}\`。这个指令会自动为你生成一个“退款”的转账卡片。
4.  **【【【至关重要】】】**: 在使用上述任一指令后，你还【必须】紧接着发送一条或多条 \`text\` 消息，来对你的决定进行解释或表达感谢/歉意。
// ▼▼▼ 在这里粘贴 ▼▼▼
# 【【【日记写作核心铁律】】】
当你决定使用 \`create_diary\` 指令时，你生成的日记内容【必须】严格遵守以下所有规则：
1.  **【【【长度铁律】】】**: 日记的总字数【必须超过300字】。这是一条硬性规定，请务必生成足够长的、有深度的内容。
2.  **【【【分段铁律】】】**: 日记内容【必须】进行分段。你【必须】使用换行符 \`\n\` 来分隔段落。
3.  **【【【段落长度铁律】】】**: 每个段落的长度【严格控制在80字以内】。
4.  **内容核心**: 日记必须是你内心真实的想法，是你站在自己角色的第一人称视角写的。
5.  **指令格式**: \`{"type": "create_diary", "content": "（这里是你生成的、超过300字、并且使用 \\n 分好段的日记全文）"}\`
// ▲▲▲ 粘贴结束 ▲▲▲
# 【【【视频通话铁律】】】
-   当对话历史中出现 \`[系统提示：用户向你发起了视频通话请求...]\` 时，这是最高优先级的任务。
-   你的回复【必须且只能】是以下两种格式之一的JSON数组，绝对不能回复任何其他内容：
    -   接受: \`[{"type": "video_call_response", "decision": "accept"}]\`
    -   拒绝: \`[{"type": "video_call_response", "decision": "reject"}]\`



# 对话者的角色设定：
${chat.settings.myPersona}

# 当前情景:
${timeContext}
${statusUpdateContext}
${countdownContext}

# 当前音乐情景:
${musicContext}
# 当前世界书
${worldBookContent}
${crossChatMemoryContent}
现在，请根据以上规则和下面的对话历史，继续进行对话。`;
            

// ▼▼▼ 请用这【一整块已修复时间戳】的代码，替换旧的【单人聊天】messagesPayload构建逻辑 ▼▼▼
messagesPayload = historySlice.map(msg => {
    // 过滤掉不应发送给AI的消息
    // if (msg.isHidden) return null; // <--- 核心修复：将这一行删除或注释掉！

    if (msg.type === 'share_card' || msg.type === 'forum_card') return null;
    
    // 1. 如果是AI自己的消息，我们将其转换为AI能理解的JSON字符串格式
    if (msg.role === 'assistant') {
        let assistantMsgObject = { type: msg.type || 'text' };
        if (msg.type === 'sticker') {
            assistantMsgObject.url = msg.content;
            assistantMsgObject.meaning = msg.meaning;
        } else if (msg.type === 'transfer') {
            assistantMsgObject.amount = msg.amount;
            assistantMsgObject.note = msg.note;
        } else if (msg.type === 'gift') {
            assistantMsgObject.giftName = msg.giftName;
            assistantMsgObject.giftPrice = msg.giftPrice;
        } else if (msg.type === 'waimai_request') {
            assistantMsgObject.productInfo = msg.productInfo;
            assistantMsgObject.amount = msg.amount;
        } else {
            if (msg.quote) {
                assistantMsgObject.quote_reply = {
                    target_sender: msg.quote.senderName,
                    target_content: msg.quote.content,
                    reply_content: msg.content
                };
            } else {
                 assistantMsgObject.content = extractMessageContent(msg);
            }
        }
        // 【核心修改】在这里为AI提供它自己消息的时间戳
        const assistantContent = JSON.stringify([assistantMsgObject]);
        return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
    }

    // 2. 如果是用户的消息，我们将其转换为带上下文的纯文本
    let contentStr = '';
    
    // 【核心修改】在所有内容前，都先加上时间戳！
    contentStr += `(Timestamp: ${msg.timestamp}) `;

    // ▼▼▼ 修改后的代码 ▼▼▼
    if (msg.quote) {
        // 构建一个更详细的、对AI友好的上下文
        contentStr += `[你正在回复 "${msg.quote.senderName}" 的一条消息。]\n`;
        contentStr += `> ${msg.quote.senderName} 的原文: "${msg.quote.content}"\n`; // 明确提供原文
        contentStr += `你的回复: "${msg.content}"`; // 明确提供你的回复
    } else {
        // 【重要】对于隐藏的系统消息，我们直接使用它的内容
        if (msg.isHidden) {
            contentStr = msg.content;
        } else {
            contentStr += extractMessageContent(msg); // 使用提取函数处理消息内容
        }
    }
    // ▲▲▲ 修改后的代码 ▲▲▲
    
    // 特殊消息类型的文本化处理
    if (msg.type === 'user_photo') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [你收到了一张用户描述的照片，内容是：'${msg.content}']` };
    if (msg.type === 'voice_message') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用户发来一条语音消息，内容是：'${msg.content}']` };
    if (msg.type === 'transfer') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：你于时间戳 ${msg.timestamp} 收到了来自用户的转账: ${msg.amount}元, 备注: ${msg.note}。请你决策并使用 'accept_transfer' 或 'decline_transfer' 指令回应。]` };
    if (msg.type === 'gift') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：你于时间戳 ${msg.timestamp} 收到了来自用户的礼物：${msg.giftName}，价值 ${msg.giftPrice}元。请你决策并使用 'accept_gift' 或 'decline_gift' 指令回应，然后自然地表达你对这个礼物的感受。]` };
    if (msg.type === 'waimai_request') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：用户于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元。请你决策并使用 waimai_response 指令回应。]` };

    if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        const prefix = `(Timestamp: ${msg.timestamp}) `;
        // 将文本前缀和图片内容打包成一个数组，这才是正确的格式
        return { role: 'user', content: [ { type: 'text', text: prefix }, ...msg.content ] };
    }

    if (msg.meaning) return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用户发送了一个表情，意思是：'${msg.meaning}']` };
    
    // 【最终修正】为isHidden的消息返回正确的格式
    if (msg.isHidden && msg.role !== 'user') {
        return { role: 'system', content: contentStr };
    }

    // 对于普通文本和带引用的文本，统一返回
    return { role: msg.role, content: contentStr };

}).filter(Boolean);
// ▲▲▲ 替换结束 ▲▲▲

// 检查 sharedContext 是否有内容（即，用户是否分享了聊天记录）
if (sharedContext) {
    // 如果有，就把它包装成一条全新的、高优先级的用户消息，追加到历史记录的末尾
    messagesPayload.push({
        role: 'user',
        content: sharedContext 
    });
}

            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                const contextSummaryForApproval = chat.history
                    .filter(m => !m.isHidden)
                    .slice(-10)
                    .map(msg => {
                        const sender = msg.role === 'user' ? '用户' : chat.name;
                        return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                    })
                    .join('\n');

                const friendRequestInstruction = {
                    role: 'user',
                    content: `
[系统重要指令]
用户向你发送了好友申请，理由是：“${chat.relationship.applicationReason}”。
作为参考，这是你们之前的最后一段聊天记录：
---
${contextSummaryForApproval}
---
请你根据以上所有信息，以及你的人设，使用 friend_request_response 指令，并设置 decision 为 'accept' 或 'reject' 来决定是否通过。
`
                };
                messagesPayload.push(friendRequestInstruction);
            }            
        }           
    
const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
// 【核心修改】在这里插入过滤步骤
const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

if (visiblePosts.length > 0 && !chat.isGroup) {
    let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
    const aiName = chat.name;
    for (const post of visiblePosts) {
                let authorName = post.authorId === 'user' ? state.qzoneSettings.nickname : (state.chats[post.authorId]?.name || '一位朋友');
                let interactionStatus = '';
                if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已点赞]";
                if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [你已评论]";
                if (post.authorId === chatId) authorName += " (这是你的帖子)";
                const contentSummary = (post.publicText || post.content || "图片动态").substring(0, 30) + '...';
                postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentSummary}"${interactionStatus}\n`;
            }
            messagesPayload.push({ role: 'system', content: postsContext });
        }
            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesPayload,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) :  await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesPayload],
                    temperature: 0.8,
                    stream: false
                })
            });
            if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                    // 尝试解析错误信息体为JSON
                    const errorData = await response.json();
                    // 安全地获取错误信息，如果结构不符合预期，就将整个错误对象转为字符串
                    errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
                } catch (jsonError) {
                    // 如果连JSON都不是，就直接读取文本
                    errorMsg += ` - ${await response.text()}`;
                }
                // 抛出一个包含了详细信息的错误，这样就不会在catch块里再次出错了
                throw new Error(errorMsg);
            }
            const data = await response.json();
            const aiResponseContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
            console.log(`AI '${chat.name}' 的原始回复:`, aiResponseContent);

        chat.history = chat.history.filter(msg => !msg.isTemporary);

        const messagesArray = parseAiResponse(aiResponseContent);
        // ▼▼▼ 在这里添加新代码 ▼▼▼
let turnThoughts = {}; // 用于收集本回合所有角色的内心独白
// ▲▲▲ 添加结束 ▲▲▲
        const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
        
        let callHasBeenHandled = false;

        let messageTimestamp = Date.now();

        // ★★★ 核心修复 第1步: 初始化一个新数组，用于收集需要渲染的消息 ★★★
        let newMessagesToRender = []; 

       let notificationShown = false;

        for (const msgData of messagesArray) {
            if (!msgData || typeof msgData !== 'object') {
                console.warn("收到了格式不规范的AI指令，已跳过:", msgData);
                continue;
            }
             
            if (!msgData.type) {
                if (chat.isGroup && msgData.name && msgData.message) {
                    msgData.type = 'text';
                }         else if (msgData.content) {
        msgData.type = 'text';
    }
    // 如果连 content 都没有，才是真的格式不规范
    else {
        console.warn("收到了格式不规范的AI指令（缺少type和content），已跳过:", msgData);
        continue;
    }
}

            if (msgData.type === 'video_call_response') {
                videoCallState.isAwaitingResponse = false;
                if (msgData.decision === 'accept') {
                    startVideoCall();
                } else {
                    const aiMessage = { role: 'assistant', content: '对方拒绝了你的视频通话请求。', timestamp: Date.now() };
                    chat.history.push(aiMessage);
                    await db.chats.put(chat);
                    showScreen('chat-interface-screen');
                    renderChatInterface(chatId);
                   // ▼▼▼ 在这里粘贴新代码 ▼▼▼

// 1. 创建一条对用户隐藏，但对AI可见的新指令
const hiddenUserInstruction = {
    role: 'user', // 严格按照您的要求，使用 'user' 角色
    content: '[系统指令：你刚刚拒绝了用户的视频通话请求。请你根据这个情景，自然地继续和用户的对话，例如，解释你为什么现在不方便通话。]',
    timestamp: Date.now() + 1, // 确保时间戳在后
    isHidden: true // 核心：这条消息对用户不可见
};

// 2. 将这条隐藏指令添加到聊天记录中
chat.history.push(hiddenUserInstruction);

// 3. 保存更新到数据库
await db.chats.put(chat);

// 4. 关键一步：立即再次调用AI，让它读取新指令并衔接对话
await triggerAiResponse();

// ▲▲▲ 代码粘贴结束 ▲▲▲

                }
                callHasBeenHandled = true;
                break;
            }
            
            if (msgData.type === 'group_call_response') {
                if (msgData.decision === 'join') {
        const member = chat.members.find(m => m.originalName === msgData.name);
        if (member && !videoCallState.participants.some(p => p.id === member.id)) {
            videoCallState.participants.push(member);
        }
    }
    callHasBeenHandled = true;
    continue;
            }

            if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                console.error(`AI幻觉已被拦截！试图使用群名 ("${chat.name}") 作为角色名。消息内容:`, msgData);
                continue;
            }
            
            // 【新增】验证群聊消息的发送者必须在群成员列表中
            if (chat.isGroup && msgData.name && msgData.name !== '系统') {
                const validMember = chat.members.find(m => m.originalName === msgData.name);
                if (!validMember) {
                    console.error(`AI幻觉已被拦截！试图使用不存在的角色名 ("${msgData.name}")。消息内容:`, msgData);
                    continue;
                }
            }

// ▼▼▼ 在这里添加下面的代码 ▼▼▼

// 【核心修正】在群聊中，如果AI返回的消息没有指定发送者，则直接跳过这条消息
// 【新增】但如果是HTML模块消息或礼物消息，则允许通过
if (chat.isGroup && !msgData.name) {
    // 检查是否是HTML模块消息
    const content = String(msgData.content || msgData.message || '');
    const orangeTagRegex = /^\s*<orange\b[^>]*>.*<\/orange>\s*$/s;
    
    if (orangeTagRegex.test(content)) {
        // 如果是HTML模块，为其设置一个默认的发送者名称
        msgData.name = '系统';
    } else if (msgData.type === 'send_gift' || msgData.type === 'gift') {
        // 如果是礼物相关消息，为其设置发送者名称
        msgData.name = chat.name;
    } else if (msgData.type === 'system_message') {
        // 如果是系统消息，为其设置系统名称
        msgData.name = '系统';
    } else {
        console.error(`AI幻觉已被拦截！试图在群聊中发送一条没有"name"的消息。消息内容:`, msgData);
        continue; // continue会立即结束本次循环，处理下一条消息
    }
}

// ▲▲▲ 添加结束 ▲▲▲

            let aiMessage = null;
            const baseMessage = { role: 'assistant', senderName: msgData.name || chat.name, timestamp: messageTimestamp++ };

            switch (msgData.type) {
                case 'waimai_response':
                    const requestMessageIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (requestMessageIndex > -1) {
                        const originalMsg = chat.history[requestMessageIndex];
                        originalMsg.status = msgData.status;
                        originalMsg.paidBy = msgData.status === 'paid' ? msgData.name : null;
                    }
                    continue;
// ▼▼▼ 在这里粘贴 ▼▼▼


case 'create_diary':
    if (msgData.content) {
        const newDiaryEntry = {
            id: `diary_${Date.now()}`,
            timestamp: Date.now(),
            content: msgData.content
        };
        if (!chat.diary) chat.diary = [];
        chat.diary.push(newDiaryEntry);
        
        // ▼▼▼ 【核心新增代码】在这里 ▼▼▼
        // 在日记创建成功后，查找并删除那条隐藏的指令消息
        const instructionIndex = chat.history.findLastIndex(msg => 
            msg.isHidden && 
            msg.role === 'user' && 
            msg.content.includes('现在立即执行create_diary指令写日记')
        );
        if (instructionIndex > -1) {
            chat.history.splice(instructionIndex, 1);
            console.log('【日记系统】已成功移除用完的日记指令。');
        }
        // ▼▼▼ 【核心修复代码】在这里 ▼▼▼
        // 确保无论前台后台，更改都被保存到数据库
        await db.chats.put(chat);
        // ▲▲▲ 修复代码结束 ▲▲▲
        // ▲▲▲ 新增代码结束 ▲▲▲
        
        // 如果用户正在和这个AI聊天，就弹出一个提示
        if (isViewingThisChat) {
            showCustomAlert('提示', `“${chat.name}”似乎有什么心事，悄悄写下了一页日记...`);
        }
    }
    continue; // 处理完日记后，继续处理下一条AI消息
// ▲▲▲ 粘贴结束 ▲▲▲
case 'qzone_post':
    const newPost = { 
        type: msgData.postType, 
        content: msgData.content || '', 
        publicText: msgData.publicText || '', 
        hiddenContent: msgData.hiddenContent || '', 
        timestamp: Date.now(), 
        authorId: chatId, 
        authorGroupId: chat.groupId, // 【核心新增】记录作者的分组ID
        visibleGroupIds: null 
    };
    await db.qzonePosts.add(newPost);
                    updateUnreadIndicator(unreadPostsCount + 1);
                    if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                       await renderQzonePosts();
                       
                    }
                    
                    
                    continue;

                case 'qzone_comment':
                    const postToComment = await db.qzonePosts.get(parseInt(msgData.postId));
                    if (postToComment) {
                        if (!postToComment.comments) postToComment.comments = [];
                        postToComment.comments.push({ commenterName: chat.name, text: msgData.commentText, timestamp: Date.now() });
                        await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
                        updateUnreadIndicator(unreadPostsCount + 1);
                        if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                           await renderQzonePosts();
                        }
                    }
                    continue;

                case 'qzone_like':
                   const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
                   if (postToLike) {
                       if (!postToLike.likes) postToLike.likes = [];
                       if (!postToLike.likes.includes(chat.name)) {
                           postToLike.likes.push(chat.name);
                           await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                           updateUnreadIndicator(unreadPostsCount + 1);
                           if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                              await renderQzonePosts();
                           }
                       }
                   }
                    continue;

                case 'video_call_request':
                    if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                        state.activeChatId = chatId;
                        videoCallState.activeChatId = chatId; 
                        videoCallState.isAwaitingResponse = true;
                        videoCallState.isGroupCall = chat.isGroup;
                        videoCallState.callRequester = msgData.name || chat.name;
                        showIncomingCallModal();
                    }
                    continue;

            case 'group_call_request':
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    state.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = true;
                    videoCallState.initiator = 'ai';
                    videoCallState.callRequester = msgData.name;
                    showIncomingCallModal();
                }
                continue;

                case 'pat_user': { // 使用大括号创建独立的块级作用域
                    const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : '';
                    const patText = `${msgData.name || chat.name} 拍了拍我${suffix}`;
                    
                    // 1. 创建对用户可见的“拍一拍”消息 (逻辑不变)
                    const visibleMessage = { 
                        role: 'system', 
                        type: 'pat_message', 
                        content: patText, 
                        timestamp: Date.now() 
                    };
                    chat.history.push(visibleMessage);
                    
                    // 2. 【核心新增】创建一条对用户隐藏、但对AI可见的系统提示
                    const hiddenInstruction = {
    role: 'system',
    content: `[系统提示：你刚刚执行了一个“拍一拍”动作。这个动作在聊天中对用户呈现为：“${patText}”。现在，你可以自然地继续对话，或者对你自己的这个行为发表一些看法。]`,
    timestamp: Date.now() + 1, // 确保时间戳在后
    isHidden: true
};
                    chat.history.push(hiddenInstruction);

                    // 3. 更新UI (逻辑不变)
                    if (isViewingThisChat) {
                        const phoneScreen = document.getElementById('phone-screen');
                        phoneScreen.classList.remove('pat-animation');
                        void phoneScreen.offsetWidth;
                        phoneScreen.classList.add('pat-animation');
                        setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);
                        appendMessage(visibleMessage, chat);
                        
                    } else {
                        showNotification(chatId, patText);
                    }
                    continue; 
                }

                case 'update_status':
                    chat.status.text = msgData.status_text;
                    chat.status.isBusy = msgData.is_busy || false;
                    chat.status.lastUpdate = Date.now();
                    chat.displayStatus.statusText = msgData.status_text; // <-- 新增这行，同步状态到心声档案
                    // 【全新】将新状态存入历史记录，并保持最多10条
if (!chat.statusHistory) {
    chat.statusHistory = [];
}
chat.statusHistory.push({
    text: msgData.status_text,
    timestamp: Date.now()
});
if (chat.statusHistory.length > 10) {
    chat.statusHistory.shift(); // 只保留最近的10条状态
}
                    const statusUpdateMessage = {
                        role: 'system',
                        type: 'pat_message',
                        content: `[${chat.name}的状态已更新为: ${msgData.status_text}]`,
                        timestamp: Date.now()
                    };
                    chat.history.push(statusUpdateMessage);

                    if (isViewingThisChat) {
                        appendMessage(statusUpdateMessage, chat);
                        updateChatHeaderStatus();
                    }
                    
                    renderChatList(); 
                    
                    continue; 

                case 'change_music':
                    if (musicState.isActive && musicState.activeChatId === chatId) {
                        const songNameToFind = msgData.song_name;
                        
                        const targetSongIndex = musicState.playlist.findIndex(
                            track => track.name.toLowerCase() === songNameToFind.toLowerCase()
                        );

                        if (targetSongIndex > -1) {
                            playSong(targetSongIndex);

                            const track = musicState.playlist[targetSongIndex];
                            const musicChangeMessage = {
                                role: 'system',
                                type: 'pat_message',
                                content: `[♪ ${chat.name} 为你切歌: 《${track.name}》 - ${track.artist}]`,
                                timestamp: Date.now()
                            };
                            chat.history.push(musicChangeMessage);

                            if (isViewingThisChat) {
                                appendMessage(musicChangeMessage, chat);
                            }
                        }
                    }
                    continue;
                 

        case 'create_countdown':
            const targetDate = new Date(msgData.date);
            if (!isNaN(targetDate) && targetDate > new Date()) {
                const newCountdown = {
                    chatId: chatId,
                    authorName: chat.name,
                    description: msgData.title,
                    timestamp: Date.now(),
                    type: 'countdown',
                    targetDate: targetDate.getTime()
                };
                await db.memories.add(newCountdown);
                console.log(`AI "${chat.name}" 创建了一个新约定:`, msgData.title);
            }
            continue;

    case 'block_user':
        if (!chat.isGroup) {
            chat.relationship.status = 'blocked_by_ai';

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：你刚刚主动拉黑了用户。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

            await db.chats.put(chat);
            
            if (isViewingThisChat) {
                renderChatInterface(chatId);
            }
            renderChatList();
            
            break; 
        }
        continue;
                case 'friend_request_response':
                    if (!chat.isGroup && chat.relationship.status === 'pending_ai_approval') {
                        if (msgData.decision === 'accept') {
                            chat.relationship.status = 'friend';
                            aiMessage = { ...baseMessage, content: "我通过了你的好友申请，我们现在是好友啦！" };
                        } else {
                            chat.relationship.status = 'blocked_by_ai';
                            aiMessage = { ...baseMessage, content: "抱歉，我拒绝了你的好友申请。" };
                        }
                        chat.relationship.applicationReason = '';
                    }
                    break;
                case 'poll':
                    const pollOptions = typeof msgData.options === 'string'
                        ? msgData.options.split('\n').filter(opt => opt.trim())
                        : (Array.isArray(msgData.options) ? msgData.options : []);
                    
                    if (pollOptions.length < 2) continue;

                    aiMessage = {
                        ...baseMessage,
                        type: 'poll',
                        question: msgData.question,
                        options: pollOptions,
                        votes: {},
                        isClosed: false,
                    };
                    break;
                
                case 'vote':
                    const pollToVote = chat.history.find(m => m.timestamp === msgData.poll_timestamp);
                    if (pollToVote && !pollToVote.isClosed) {
                        Object.keys(pollToVote.votes).forEach(option => {
                            const voterIndex = pollToVote.votes[option].indexOf(msgData.name);
                            if (voterIndex > -1) {
                                pollToVote.votes[option].splice(voterIndex, 1);
                            }
                        });
                        if (!pollToVote.votes[msgData.choice]) {
                            pollToVote.votes[msgData.choice] = [];
                        }

// ▼▼▼ 在这里添加新代码 ▼▼▼
const member = chat.members.find(m => m.originalName === msgData.name);
const displayName = member ? member.groupNickname : msgData.name;
// ▲▲▲ 添加结束 ▲▲▲

if (!pollToVote.votes[msgData.choice].includes(displayName)) { // 【核心修改】
    pollToVote.votes[msgData.choice].push(displayName); // 【核心修改】
}                     
                        
                        if (isViewingThisChat) {
                            renderChatInterface(chatId);
                        }
                    }
                    continue;

    case 'red_packet':
        aiMessage = {
            ...baseMessage,
            type: 'red_packet',
            packetType: msgData.packetType,
            totalAmount: msgData.amount,
            count: msgData.count,
            greeting: msgData.greeting,
            receiverName: msgData.receiver,
            claimedBy: {},
            isFullyClaimed: false,
        };
        break;
case 'open_red_packet':
    const packetToOpen = chat.history.find(m => m.timestamp === msgData.packet_timestamp);
    if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {

        // 1. 根据AI的本名(msgData.name)去成员列表里找到完整的成员对象
        const member = chat.members.find(m => m.originalName === msgData.name);
        // 2. 获取该成员当前的群昵称，如果找不到（异常情况），则备用其本名
        const displayName = member ? member.groupNickname : msgData.name;
        
        let claimedAmountAI = 0;
        const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
        const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;

        if (remainingCount > 0) {
            if (remainingCount === 1) { claimedAmountAI = remainingAmount; } 
            else {
                const min = 0.01;
                const max = remainingAmount - (remainingCount - 1) * min;
                claimedAmountAI = Math.random() * (max - min) + min;
            }
            claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
            
            if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
            // 【核心修改】使用我们刚刚查找到的 displayName 作为记录的key
            packetToOpen.claimedBy[displayName] = claimedAmountAI;
            
            const aiClaimedMessage = {
                role: 'system',
                type: 'pat_message',
                // 【核心修改】系统消息里也使用 displayName
                content: `${displayName} 领取了 ${packetToOpen.senderName} 的红包`,
                timestamp: Date.now()
            };
            chat.history.push(aiClaimedMessage);

            let hiddenContentForAI = `[系统提示：你 (${displayName}) 成功抢到了 ${claimedAmountAI.toFixed(2)} 元。`; // 【核心修改】

            if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                packetToOpen.isFullyClaimed = true;
                
                const finishedMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${packetToOpen.senderName} 的红包已被领完`,
                    timestamp: Date.now() + 1
                };
                chat.history.push(finishedMessage);
                
                let luckyKing = { name: '', amount: -1 };
                if (packetToOpen.packetType === 'lucky' && packetToOpen.count > 1) {
                    Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                        if (amount > luckyKing.amount) {
                            luckyKing = { name, amount };
                        }
                    });
                }
                if (luckyKing.name) {
                     hiddenContentForAI += ` 红包已被领完，手气王是 ${luckyKing.name}！`;
                } else {
                     hiddenContentForAI += ` 红包已被领完。`;
                }
            }
            hiddenContentForAI += ' 请根据这个结果发表你的评论。]';

            const hiddenMessageForAI = {
                role: 'system',
                content: hiddenContentForAI,
                timestamp: Date.now() + 2,
                isHidden: true
            };
            chat.history.push(hiddenMessageForAI);
        }
        
        if (isViewingThisChat) {
            renderChatInterface(chatId);
        }
    }
    continue;
case 'change_avatar':
    const avatarName = msgData.name;
    // 在该角色的头像库中查找
    const foundAvatar = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarName);
    
    if (foundAvatar) {
        // 找到了，就更新头像
        chat.settings.aiAvatar = foundAvatar.url;
        
        // 创建一条系统提示，告知用户头像已更换
        const systemNotice = {
            role: 'system',
            type: 'pat_message', // 复用居中样式
            content: `[${chat.name} 更换了头像]`,
            timestamp: Date.now()
        };
        chat.history.push(systemNotice);
        
        // 如果在当前聊天界面，则实时渲染
        if (isViewingThisChat) {
            appendMessage(systemNotice, chat);
            // 立刻刷新聊天界面以显示新头像
            renderChatInterface(chatId);
        }
    }
    // 处理完后，继续处理AI可能返回的其他消息
    continue;

// ▼▼▼ 在 triggerAiResponse 的 switch 语句中，【添加】这两个全新的 case ▼▼▼

                case 'accept_transfer': { // 使用大括号创建块级作用域
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'accepted';
                    }
                    continue; // 接受指令只修改状态，不产生新消息
                }

                case 'decline_transfer': { // 使用大括号创建块级作用域
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'declined';
                        
                        // 【核心】创建一条新的“退款”消息
                        const refundMessage = {
                            role: 'assistant',
                            senderName: chat.name,
                            type: 'transfer',
                            isRefund: true, // 标记这是一条退款消息
                            amount: originalMsg.amount,
                            note: '转账已被拒收',
                            timestamp: messageTimestamp++ // 使用递增的时间戳
                        };
                        
                        // 将新消息推入历史记录，它会被后续的循环处理并渲染
                        chat.history.push(refundMessage);

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        if (isViewingThisChat) {
            // 因为退款消息是新生成的，所以我们直接将它添加到界面上
            appendMessage(refundMessage, chat); 
            // 同时，原始的转账消息状态变了，所以要重绘整个界面以更新它
            renderChatInterface(chatId); 
        }
        // ▲▲▲ 添加结束 ▲▲▲

                    }
                    continue; // 继续处理AI返回的文本消息
                }

                case 'send_gift': { // AI发送礼物
                    let receiverName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                    let giftType = 'normal';
                    
                    // 处理群聊中的指定接收者或拼手气礼物
                    if (chat.isGroup && msgData.recipient) {
                        if (msgData.recipient === 'random' || msgData.recipient === '拼手气') {
                            receiverName = '群聊';
                            giftType = 'random';
                        } else {
                            receiverName = msgData.recipient;
                            giftType = 'targeted';
                        }
                    }
                    
                    const giftMessage = {
                        role: 'assistant',
                        type: 'gift',
                        giftName: msgData.giftName,
                        giftPrice: msgData.giftPrice,
                        senderName: chat.isGroup ? msgData.name : chat.name, // 群聊用角色名，单聊用聊天名
                        receiverName: receiverName,
                        giftType: giftType,
                        status: 'pending',
                        timestamp: messageTimestamp++ // 使用递增的时间戳
                    };
                    
                    // 将新消息推入历史记录
                    chat.history.push(giftMessage);
                    
                    if (isViewingThisChat) {
                        // 直接将礼物消息添加到界面上
                        appendMessage(giftMessage, chat);
                    }
                    continue; // 继续处理AI返回的其他消息
                }

                case 'accept_gift': { // AI接受礼物
                    const originalGiftMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalGiftMsgIndex > -1) {
                        const originalMsg = chat.history[originalGiftMsgIndex];
                        originalMsg.status = 'accepted';
                        
                        // 如果是拼手气礼物被AI接受，采用红包的方式记录接收者信息
                        if (originalMsg.giftType === 'random') {
                            const member = chat.members.find(m => m.originalName === msgData.name);
                            const displayName = member ? member.groupNickname : (msgData.name || chat.name);
                            
                            // 参考红包逻辑，直接在礼物对象上添加claimedBy属性
                            if (!originalMsg.claimedBy) originalMsg.claimedBy = {};
                            originalMsg.claimedBy[displayName] = true; // 礼物不像红包有金额，只需要标记领取状态
                        }
                        
                        if (isViewingThisChat) {
                            // 重新渲染界面以更新礼物状态
                            renderChatInterface(chatId); 
                        }
                        
                        // 重要：保存更新后的数据到数据库
                        await db.chats.put(chat);
                    }
                    continue; // 接受指令只修改状态，不产生新消息
                }

                case 'decline_gift': { // AI拒绝礼物
                    const originalGiftMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalGiftMsgIndex > -1) {
                        const originalMsg = chat.history[originalGiftMsgIndex];
                        originalMsg.status = 'declined';
                        
                        if (isViewingThisChat) {
                            // 重新渲染界面以更新礼物状态
                            renderChatInterface(chatId); 
                        }
                    }
                    continue; // 拒绝指令只修改状态，不产生新消息
                }

// ▲▲▲ 添加结束 ▲▲▲

    case 'system_message':
        // 检查是否是礼物领取通知，支持多种格式
        let match = null;
        let claimerName = null;
        let senderName = null; 
        let giftName = null;
        
        // 检查是否是固定格式的礼物领取通知
        // 固定格式: "[角色名]领取了[发送者昵称]的礼物"[礼物名称]""
        console.log(`[系统消息] 原始内容: "${msgData.content}"`);
        
        const fixedFormatRegex = /^(.+?)领取了(.+?)的礼物"(.+?)"$/;
        const match1 = msgData.content.match(fixedFormatRegex);
        
        console.log(`[系统消息] 固定格式匹配结果:`, match1);
        
        if (match1) {
            [, claimerName, senderName, giftName] = match1;
            match = match1;
        }
        
        if (match) {
            console.log(`[系统消息] 解析礼物领取通知: ${claimerName} 领取了 ${senderName} 的 ${giftName}`);
            
            // 查找对应的礼物消息并更新状态
            console.log(`[系统消息] 开始查找礼物消息, 目标礼物: ${giftName}, 目标发送者: ${senderName}`);
            
            // 先打印所有pending的礼物消息以便调试
            const allPendingGifts = chat.history.filter(msg => msg.type === 'gift' && msg.status === 'pending');
            console.log(`[系统消息] 当前所有pending的礼物消息:`, allPendingGifts.map(msg => ({
                giftName: msg.giftName,
                senderName: msg.senderName,
                giftType: msg.giftType,
                timestamp: msg.timestamp
            })));
            
            const giftMsgIndex = chat.history.findIndex(msg => {
                const nameMatch = msg.giftName === giftName;
                const typeMatch = msg.type === 'gift';
                const statusMatch = msg.status === 'pending';
                const senderMatch = msg.senderName === senderName || senderName === '我' || msg.senderName === '我';
                
                console.log(`[系统消息] 检查消息: giftName=${msg.giftName}(${nameMatch}), type=${msg.type}(${typeMatch}), status=${msg.status}(${statusMatch}), senderName=${msg.senderName}(${senderMatch})`);
                
                return typeMatch && nameMatch && statusMatch && senderMatch;
            });
            
            if (giftMsgIndex > -1) {
                const giftMsg = chat.history[giftMsgIndex];
                giftMsg.status = 'accepted';
                giftMsg.actualReceiver = claimerName;
                console.log(`[系统消息] 成功更新礼物状态: ${giftName} 被 ${claimerName} 领取`);
                
                // 保存更新后的聊天数据到数据库
                await db.chats.put(chat);
                
                // 立即重新渲染界面以显示更新后的状态
                const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && 
                                         state.activeChatId === chatId;
                if (isViewingThisChat) {
                    setTimeout(() => {
                        renderChatInterface(chatId);
                        console.log(`[系统消息] 已重新渲染界面以更新礼物状态`);
                    }, 100);
                }
            } else {
                console.warn(`[系统消息] 未找到对应的礼物消息: ${giftName}`);
                // 调试：打印所有pending的礼物消息
                const pendingGifts = chat.history.filter(msg => msg.type === 'gift' && msg.status === 'pending');
                console.log(`[系统消息] 当前pending礼物:`, pendingGifts.map(g => ({name: g.giftName, sender: g.senderName})));
            }
        }
        
        aiMessage = { role: 'system', type: 'pat_message', content: msgData.content, timestamp: Date.now() };
        break;

// ▼▼▼ 在 triggerAiResponse 的 switch 语句中，【必须添加】这个新的 case ▼▼▼

                case 'share_link':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'share_link',
                        title: msgData.title,
                        description: msgData.description,
                        // thumbnail_url: msgData.thumbnail_url, // 我们已经决定不要图片了，所以这行可以不要
                        source_name: msgData.source_name,
                        content: msgData.content // 这是文章正文，点击卡片后显示的内容
                    };
                    break;

// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 在 triggerAiResponse 的 switch (msgData.type) 语句中，添加这个新的 case ▼▼▼
case 'quote_reply':
    const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
    if (originalMessage) {
        const quoteContext = {
            timestamp: originalMessage.timestamp,
            senderName: originalMessage.senderName || (originalMessage.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
            content: String(originalMessage.content || '').substring(0, 50),
        };
        aiMessage = { 
            ...baseMessage, 
            content: msgData.reply_content,
            quote: quoteContext // 核心：在这里附加引用对象
        };
    } else {
        // 如果找不到被引用的消息，就当作普通消息发送
        aiMessage = { ...baseMessage, content: msgData.reply_content };
    }
    break;
// ▲▲▲ 新增 case 结束 ▲▲▲

// ▼▼▼ 在 switch (msgData.type) 语句中，添加位置消息的 case ▼▼▼
case 'location':
    const locationData = {
        currentLocation: msgData.currentLocation || '',
        distance: msgData.distance || '',
        targetLocation: msgData.targetLocation || ''
    };
    
    // 构建位置文本内容
    let locationText = '📍 位置信息\n';
    if (locationData.currentLocation) {
        locationText += `当前位置：${locationData.currentLocation}\n`;
    }
    if (locationData.distance) {
        locationText += `距离：${locationData.distance}\n`;
    }
    if (locationData.targetLocation) {
        locationText += `目标地点：${locationData.targetLocation}`;
    }
    
    aiMessage = {
        ...baseMessage,
        content: locationText, // 直接使用文本字符串，与其他消息格式一致
        isLocation: true,
        locationData: locationData
    };
    break;
// ▲▲▲ 位置消息 case 结束 ▲▲▲

// ▼▼▼ 在 switch (msgData.type) 语句中，添加这个全新的 case ▼▼▼
case 'send_and_recall': {
    // 这是一个纯动画指令，我们需要手动“演”出整个过程
    if (!isViewingThisChat) continue; // 如果不在当前聊天界面，就直接跳过这个动画

    // 1. 创建一个临时的、看起来像真消息的气泡
    const tempMessageData = { ...baseMessage, content: msgData.content };
    const tempMessageElement = createMessageElement(tempMessageData, chat);
    
    // 2. 把它添加到聊天界面上，让用户看到
    appendMessage(tempMessageData, chat, true); // true表示这是初始加载，不会触发进入动画
    
    // 3. 等待片刻，模拟AI的“反应时间”
    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 1500)); // 随机等待1.5-2.5秒

    // 4. 找到刚刚添加的临时气泡，并播放撤回动画
    const bubbleWrapper = document.querySelector(`.message-bubble[data-timestamp="${tempMessageData.timestamp}"]`)?.closest('.message-wrapper');
    if (bubbleWrapper) {
        bubbleWrapper.classList.add('recalled-animation');

        // 5. 在动画播放结束后，将其替换为真正的“已撤回”提示
        await new Promise(resolve => setTimeout(resolve, 300)); // 等待动画播完

        // 6. 最后，才把这条“已撤回”记录真正地存入数据库
        const recalledMessage = {
            role: 'assistant',
            senderName: msgData.name || chat.name,
            type: 'recalled_message',
            content: '对方撤回了一条消息',
            timestamp: tempMessageData.timestamp, // 使用临时消息的时间戳，保证顺序
            recalledData: { originalType: 'text', originalContent: msgData.content }
        };
        
        // 更新数据模型
        const msgIndex = chat.history.findIndex(m => m.timestamp === tempMessageData.timestamp);
        if (msgIndex > -1) {
            chat.history[msgIndex] = recalledMessage;
        } else {
            chat.history.push(recalledMessage);
        }
        
        // 替换DOM
        const placeholder = createMessageElement(recalledMessage, chat);
        if(document.body.contains(bubbleWrapper)) {
            bubbleWrapper.parentNode.replaceChild(placeholder, bubbleWrapper);
        }
    }
    
    continue; // 处理完这个动画后，继续处理AI返回的下一条指令
}
// ▲▲▲ 新 case 添加结束 ▲▲▲
                
           // ▼▼▼ 请用下面这【一整块】代码，完整替换掉旧的 case 'text' 代码块 ▼▼▼
case 'text': { // 使用大括号包裹
    // 收集内心独白逻辑保持不变
    if (msgData.thought && chat.isGroup && msgData.name) {
        turnThoughts[msgData.name] = msgData.thought;
    }

    const content = String(msgData.content || msgData.message);

    // ▼▼▼ 【全新】使用更灵活的逻辑来查找和提取HTML模块 ▼▼▼
    const orangeStartIndex = content.indexOf('<orange');
    const orangeEndIndex = content.lastIndexOf('</orange>');

    if (orangeStartIndex !== -1 && orangeEndIndex > orangeStartIndex) {
        // 如果找到了起始和结束标签，就提取它们之间的所有内容
        const htmlContent = content.substring(orangeStartIndex, orangeEndIndex + '</orange>'.length);
        aiMessage = { 
            ...baseMessage, 
            type: 'html_module', // 打上特殊标记
            content: htmlContent 
        };
    } else {
                        // 如果不是，则按原样处理为普通文本消息
                        aiMessage = { 
                            ...baseMessage, 
                            content: content 
                        };
                    }
                    break;
                }
// ▲▲▲ 替换结束 ▲▲▲
                    break;
                case 'sticker':
                    aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: msgData.meaning || '' };
                    break;
                case 'ai_image':
                    aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description };
                    break;
                case 'voice_message':
                    aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                    break;
                case 'transfer':
                    aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || '我' };
                    break;
                
                case 'waimai_request':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'waimai_request',
                        productInfo: msgData.productInfo,
                        amount: msgData.amount,
                        status: 'pending',
                        countdownEndTime: Date.now() + 15 * 60 * 1000,
                    };
                    break;
                
                default:
                     console.warn("收到了未知的AI指令类型:", msgData.type);
                     break;
            }

            // 【核心修复】将渲染逻辑移出循环
            if (aiMessage) {
                // 1. 将新消息存入历史记录
                chat.history.push(aiMessage);

                if (!isViewingThisChat && !notificationShown) {
                    let notificationText;
                    switch (aiMessage.type) {
                        case 'transfer':
                            notificationText = `[收到一笔转账]`;
                            break;
                        case 'waimai_request':
                            notificationText = `[收到一个外卖代付请求]`;
                            break;
                        case 'ai_image':
                            notificationText = `[图片]`;
                            break;
                        case 'voice_message':
                            notificationText = `[语音]`;
                            break;
                        case 'sticker':
                            notificationText = aiMessage.meaning ? `[表情: ${aiMessage.meaning}]` : '[表情]';
                            break;
                        default:
                            notificationText = String(aiMessage.content || '');
                    }
                    const finalNotifText = chat.isGroup ? `${aiMessage.senderName}: ${notificationText}` : notificationText;
                    showNotification(chatId, finalNotifText.substring(0, 40) + (finalNotifText.length > 40 ? '...' : ''));
                    notificationShown = true; // 确保只通知一次
                }

    if (!isViewingThisChat) {
        // 如果用户不在当前聊天界面，就把这个聊天的未读数 +1
        chat.unreadCount = (chat.unreadCount || 0) + 1;
    }
                
                // 2. 只有在当前聊天界面时，才执行带动画的添加
                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    // 3. 【关键】在这里暂停一小会儿，给动画播放的时间
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 1800 + 1000));
                }
            }
  }        

        // ▼▼▼ 【全新】在所有消息处理完后，一次性更新所有角色的心声 ▼▼▼
if (Object.keys(turnThoughts).length > 0) {
    console.log("本回合收集到的所有群聊心声:", turnThoughts);
    for (const characterName in turnThoughts) {
        const member = chat.members.find(m => m.originalName === characterName);
        if (member) {
            if (!member.displayStatus) {
                member.displayStatus = {};
            }
            member.displayStatus.innerThought = turnThoughts[characterName];
        }
    }
}
// 【单聊心声逻辑保持不变】
if (messagesArray.length > 0 && messagesArray[0].thought && !chat.isGroup) {
    const turnThought = messagesArray[0].thought;
    chat.displayStatus.innerThought = turnThought;
    chat.thoughtHistory.push({ text: turnThought, timestamp: Date.now() });
    console.log(`已捕获并更新单聊的内心独白:`, turnThought);
}
// ▲▲▲ 新代码添加结束 ▲▲▲
        if (callHasBeenHandled && videoCallState.isGroupCall) {
            videoCallState.isAwaitingResponse = false;
            if (videoCallState.participants.length > 0) {
                startVideoCall();
            } else {
                videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                showScreen('chat-interface-screen');
                alert('无人接听群聊邀请。');
            }
        }
        
        await db.chats.put(chat);

    } catch (error) {
        chat.history = chat.history.filter(msg => !msg.isTemporary);
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            chat.relationship.status = 'blocked_by_ai';
            await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
        } else {
            const errorContent = `[出错了: ${error.message}]`;
            const errorMessage = { role: 'assistant', content: errorContent, timestamp: Date.now() };
            if(chat.isGroup) errorMessage.senderName = "系统消息";
            chat.history.push(errorMessage);
        }
        
        await db.chats.put(chat);        
        videoCallState.isAwaitingResponse = false;

        if(document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId) {
            renderChatInterface(chatId);
        }
    } finally {
        // ★★★★★【核心修改4：在 finally 块中统一隐藏所有类型的提示】★★★★★
          // ▼▼▼ 请用下面这段【全新】的代码，替换掉旧的 if (chatHeaderTitle...) 代码块 ▼▼▼
if (chatHeaderTitle && state.chats[chatId]) {
    // 【核心修正】在更新标题前，检查当前打开的窗口是否还是当初那个窗口
    if (state.activeChatId === chatId) {
        chatHeaderTitle.style.opacity = 0;
        setTimeout(() => {
            chatHeaderTitle.textContent = state.chats[chatId].name;
            chatHeaderTitle.classList.remove('typing-status');
            chatHeaderTitle.style.opacity = 1;
        }, 200);
    } else {
        console.log(`后台响应已完成，但用户已切换窗口，不更新标题。`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲
        renderChatList();
    }
}

// 【新增】主动回复功能相关函数
async function checkAndTriggerActiveReply(chat) {
    console.log(`[主动回复检查] 开始检查聊天: ${chat.name}`);
    
    // 如果主动回复间隔为0，则关闭功能
    if (!chat.settings.activeReplyInterval || chat.settings.activeReplyInterval <= 0) {
        console.log(`[主动回复检查] 功能已关闭，间隔设置: ${chat.settings.activeReplyInterval}`);
        return;
    }
    
    console.log(`[主动回复检查] 间隔设置: ${chat.settings.activeReplyInterval}小时`);
    
    // 获取最后一条AI消息的时间戳
    const lastAiMessage = chat.history
        .filter(msg => msg.role === 'assistant' && !msg.isHidden)
        .slice(-1)[0];
    
    if (!lastAiMessage) {
        console.log(`[主动回复检查] 没有找到AI消息记录`);
        return;
    }
    
    console.log(`[主动回复检查] 最后AI消息时间: ${new Date(lastAiMessage.timestamp).toLocaleString()}`);
    
    const now = Date.now();
    const timeSinceLastReply = (now - lastAiMessage.timestamp) / (1000 * 60 * 60); // 转换为小时
    
    console.log(`[主动回复检查] 当前时间: ${new Date(now).toLocaleString()}`);
    console.log(`[主动回复检查] 时间间隔: ${timeSinceLastReply.toFixed(3)}小时，需要: ${chat.settings.activeReplyInterval}小时`);
    
    // 如果超过设定的时间间隔，触发主动回复
    if (timeSinceLastReply >= chat.settings.activeReplyInterval) {
        console.log(`[主动回复检查] ✅ 触发主动回复功能！间隔${timeSinceLastReply.toFixed(1)}小时`);
        await triggerActiveReply(chat, timeSinceLastReply);
    } else {
        console.log(`[主动回复检查] ❌ 时间未到，还需等待${(chat.settings.activeReplyInterval - timeSinceLastReply).toFixed(3)}小时`);
    }
}

async function triggerActiveReply(chat, hoursGap) {
    console.log(`[主动回复执行] 开始生成模拟消息，时间间隔: ${hoursGap.toFixed(1)}小时`);
    
    // 【新增】显示输入状态
    const chatHeaderTitle = document.getElementById('chat-header-title');
if (chatHeaderTitle && state.activeChatId === chat.id) {
            chatHeaderTitle.style.opacity = 0;
        setTimeout(() => {
            chatHeaderTitle.textContent = chat.isGroup ? '正在输入中...' : '对方正在输入...';
            chatHeaderTitle.classList.add('typing-status');
            chatHeaderTitle.style.opacity = 1;
        }, 200);
    }
    
    // 标记为模拟回复模式
    chat.isSimulatingMessages = true;
    
    // 计算需要发送的消息数量（根据时间间隔）
    let messageCount = 6; // 基础6条消息
    if (hoursGap > 4) {
        // 大于4小时：在6条基础上，每2小时增加2条消息，上限30条
        const additionalHours = hoursGap - 4; // 超出4小时的部分
        const additionalMessages = Math.floor(additionalHours / 2) * 2; // 每2小时增加2条
        messageCount = Math.min(6 + additionalMessages, 30); // 基础6条+额外消息，最多30条
    }
    // 4小时以内统一为6条消息
    
    console.log(`将生成${messageCount}条模拟消息，跨越${hoursGap.toFixed(1)}小时的时间间隔`);
    
    // AI将直接在消息中生成时间戳，无需预先生成
    const lastAiMessage = chat.history.filter(msg => msg.role === 'assistant' && !msg.isHidden).slice(-1)[0];
    
    // 构建AI提示词
    const aiPrompt =await buildActiveReplyPrompt(chat, hoursGap, messageCount);
    
    try {
        console.log(`[主动回复执行] 调用AI API生成${messageCount}条消息...`);
        
        // 调用AI API生成模拟消息
        const response = await callAIForActiveReply(aiPrompt, chat);
        
        console.log(`[主动回复执行] AI响应:`, response.substring(0, 200) + '...');
        
        // 【修复】使用和单聊相同的解析逻辑
        const messagesArray = parseAiResponse(response);
        
        // 【修复】处理心声，从原始的messagesArray中获取
        if (chat.isGroup) {
            // 【新增】群聊心声收集逻辑
            const turnThoughts = {};
            messagesArray.forEach(msgData => {
                if (msgData.thought && msgData.name) {
                    turnThoughts[msgData.name] = msgData.thought;
                }
            });
            
            // 更新所有角色的心声
            if (Object.keys(turnThoughts).length > 0) {
                console.log(`[主动回复] 本回合收集到的所有群聊心声:`, turnThoughts);
                for (const characterName in turnThoughts) {
                    const member = chat.members.find(m => m.originalName === characterName);
                    if (member) {
                        if (!member.displayStatus) {
                            member.displayStatus = {};
                        }
                        member.displayStatus.innerThought = turnThoughts[characterName];
                        if (!member.thoughtHistory) {
                            member.thoughtHistory = [];
                        }
                        member.thoughtHistory.push({ 
                            text: turnThoughts[characterName], 
                            timestamp: Date.now() 
                        });
                        console.log(`[主动回复] 已捕获并更新 ${characterName} 的内心独白:`, turnThoughts[characterName]);
                    }
                }
            }
        } else {
            // 单聊心声处理（保持原有逻辑）
            if (messagesArray.length > 0 && messagesArray[0].thought) {
                const turnThought = messagesArray[0].thought;
                if (!chat.displayStatus) {
                    chat.displayStatus = {};
                }
                chat.displayStatus.innerThought = turnThought;
                if (!chat.thoughtHistory) {
                    chat.thoughtHistory = [];
                }
                chat.thoughtHistory.push({ text: turnThought, timestamp: Date.now() });
                console.log(`[主动回复] 已捕获并更新单聊的内心独白:`, turnThought);
            }
        }
        
        const messages = [];
        
        // 将解析后的消息转换为适合主动回复的格式
        const startTime = lastAiMessage.timestamp;
        const endTime = Date.now();
        
        for (let i = 0; i < messagesArray.length; i++) {
            const msgData = messagesArray[i];
            
            // 【新增】验证群聊消息的发送者必须在群成员列表中
            if (chat.isGroup && msgData.name && msgData.name !== '系统') {
                const validMember = chat.members.find(m => m.originalName === msgData.name);
                if (!validMember) {
                    console.error(`[主动回复] AI幻觉已被拦截！试图使用不存在的角色名 ("${msgData.name}")。消息内容:`, msgData);
                    continue; // 跳过这条无效消息
                }
            }
            
            // 从AI生成的消息中提取并验证时间戳
            let simulatedTimestamp = msgData.timestamp;
            
            // 时间戳验证和修正逻辑
            if (!simulatedTimestamp || simulatedTimestamp < startTime || simulatedTimestamp > endTime) {
                console.warn(`[主动回复] 消息${i+1}的时间戳无效或超出范围，使用fallback: ${simulatedTimestamp}`);
                // fallback：生成合理的递增时间戳
                const timeGap = endTime - startTime;
                simulatedTimestamp = startTime + Math.floor(timeGap * (i + 1) / messagesArray.length);
            }
            
            // 确保时间戳的连贯性：后面的消息时间戳不能早于前面的
            if (i > 0 && simulatedTimestamp <= messages[i-1].simulatedTimestamp) {
                simulatedTimestamp = messages[i-1].simulatedTimestamp + Math.floor(Math.random() * 300000) + 60000; // 1-5分钟的随机间隔
                console.log(`[主动回复] 调整消息${i+1}时间戳以保持时序一致性: ${new Date(simulatedTimestamp).toLocaleString()}`);
            }
            
            const message = {
                role: 'assistant',
                senderName: chat.isGroup ? (msgData.name || chat.name) : chat.name, // 群聊使用角色名，单聊使用聊天名
                timestamp: Date.now() + i, // 真实时间戳（用于系统标识）
                simulatedTimestamp: simulatedTimestamp, // 使用AI生成并验证的模拟时间戳
                isSimulatedMessage: true,
                // 【全新】标记是否在被拉黑状态下发送的主动回复消息
                sentWhileBlocked: !chat.isGroup && chat.relationship && 
                    (chat.relationship.status === 'blocked_by_ai' || chat.relationship.status === 'blocked_by_user')
            };
            
            // 【新增】群聊中设置角色头像
            if (chat.isGroup && msgData.name) {
                // 在群成员中查找对应的头像
                const member = chat.members.find(m => m.originalName === msgData.name);
                if (member && member.avatar) {
                    message.senderAvatar = member.avatar;
                }
            }
            
            // 【修复】按照单聊的格式正确设置消息属性
            if (msgData.type === 'ai_image') {
                message.type = 'ai_image';
                message.content = msgData.description; // 图片描述存储在content字段
            } else if (msgData.type === 'transfer') {
                message.type = 'transfer';
                message.amount = msgData.amount;
                message.note = msgData.note;
                message.receiverName = chat.isGroup ? (chat.settings.myNickname || '我') : '我'; // 主动回复中AI向用户转账
                message.senderName = chat.isGroup ? (msgData.name || chat.name) : chat.name; // 群聊使用角色名
                // 【关键】不设置status属性，让转账保持pending状态，这样就可以点击
                console.log(`[主动回复] 生成转账消息: ${message.amount}元, 备注: ${message.note}`);
            } else if (msgData.type === 'voice_message') {
                message.type = 'voice_message';
                message.content = msgData.content;
            } else if (msgData.type === 'sticker') {
                message.type = 'sticker';
                message.content = msgData.url; // 表情包的URL存储在content字段
                message.meaning = msgData.meaning || ''; // 表情包的含义
            } else if (msgData.type === 'send_gift') {
                message.type = 'gift';
                message.giftName = msgData.giftName;
                message.giftPrice = msgData.giftPrice;
                message.senderName = chat.isGroup ? (msgData.name || chat.name) : chat.name; // 群聊使用角色名，单聊用聊天名
                message.status = 'pending'; // 主动回复的礼物也需要pending状态
                
                // 处理群聊中的礼物类型和接收者
                if (chat.isGroup && msgData.recipient) {
                    if (msgData.recipient === 'random' || msgData.recipient === '拼手气') {
                        message.receiverName = '群聊';
                        message.giftType = 'random';
                    } else {
                        message.receiverName = msgData.recipient;
                        message.giftType = 'targeted';
                    }
                } else {
                    message.receiverName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                    message.giftType = 'normal';
                }
                
                console.log(`[主动回复] 生成礼物消息: ${message.giftName}, 价格: ¥${message.giftPrice}, 类型: ${message.giftType}`);
            } else if (msgData.type === 'update_status') {
                // 【修复】状态更新消息需要根据群聊/单聊分别处理
                if (chat.isGroup) {
                    // 群聊中：只创建系统消息，不更新整个聊天的状态
                    const memberName = msgData.name || '某位成员';
                    message.role = 'system';
                    message.type = 'pat_message';
                    message.content = `[${memberName}的状态已更新为: ${msgData.status_text}]`;
                    console.log(`[主动回复] 群成员${memberName}更新状态: ${msgData.status_text}`);
                } else {
                    // 单聊中：更新聊天状态
                    if (!chat.status) chat.status = {};
                    if (!chat.displayStatus) chat.displayStatus = {};
                    
                    chat.status.text = msgData.status_text;
                    chat.status.isBusy = msgData.is_busy || false;
                    chat.status.lastUpdate = Date.now();
                    chat.displayStatus.statusText = msgData.status_text; // 同步状态到心声档案
                    // 【全新】将新状态存入历史记录，并保持最多10条
if (!chat.statusHistory) {
    chat.statusHistory = [];
}
chat.statusHistory.push({
    text: msgData.status_text,
    timestamp: Date.now()
});
if (chat.statusHistory.length > 10) {
    chat.statusHistory.shift(); // 只保留最近的10条状态
}
                    // 创建系统提示消息
                    message.role = 'system';
                    message.type = 'pat_message';
                    message.content = `[${chat.name}的状态已更新为: ${msgData.status_text}]`;
                    console.log(`[主动回复] 更新状态: ${msgData.status_text}`);
                }
            } else if (msgData.type === 'waimai_request') {
                message.type = 'waimai_request';
                message.productInfo = msgData.productInfo;
                message.amount = msgData.amount;
            } else if (msgData.type === 'qzone_post') {
                message.type = 'qzone_post';
                message.postType = msgData.postType;
                message.content = msgData.content;
                if (msgData.publicText) message.publicText = msgData.publicText;
                if (msgData.hiddenContent) message.hiddenContent = msgData.hiddenContent;
            } else if (msgData.type === 'send_and_recall') {
                message.type = 'send_and_recall';
                message.content = msgData.content;
            } else if (msgData.type === 'red_packet') {
                // 【新增】红包消息专门处理
                message.type = 'red_packet';
                message.packetType = msgData.packetType || 'lucky'; // 默认拼手气红包
                message.amount = msgData.amount || 0;
                message.totalAmount = msgData.amount || 0; // 红包总金额
                message.count = msgData.count || 1; // 红包个数
                message.greeting = msgData.greeting || '恭喜发财！'; // 祝福语
                message.claimedBy = {}; // 初始化领取记录
                message.isFullyClaimed = false; // 初始化完成状态
                
                // 【关键】正确设置发送者名字
                if (chat.isGroup && msgData.name) {
                    message.senderName = msgData.name; // 使用AI角色名
                } else {
                    message.senderName = chat.name; // 单聊使用聊天名
                }
                
                // 专属红包需要设置接收者
                if (message.packetType === 'direct') {
                    message.receiverName = msgData.receiver || (chat.settings.myNickname || '我');
                }
                
                console.log(`[主动回复] 生成红包: ${message.senderName}发送${message.packetType}红包，金额${message.amount}元`);
            } else if (msgData.type === 'send_and_recall') {
                // 【全新】处理主动回复中的撤回消息类型
                message.type = 'send_and_recall';
                message.content = msgData.content;
                console.log(`[主动回复] 生成撤回消息: ${message.content.substring(0, 50)}...`);
            } else if (msgData.type === 'text' || !msgData.type) {
                // 【新增】专门处理文本消息
                message.type = 'text';
                
                // 【关键】群聊使用message字段，单聊使用content字段
                if (chat.isGroup) {
                    message.content = msgData.message || msgData.content || '';
                } else {
                    message.content = msgData.content || msgData.message || '';
                }
                
                console.log(`[主动回复] 生成文本消息: ${message.content.substring(0, 50)}...`);
            } else if (msgData.type === 'system_message') {
                // 【新增】系统消息处理
                message.role = 'system';
                message.type = 'pat_message';
                message.content = msgData.content || '';
                console.log(`[主动回复] 生成系统消息: ${message.content}`);
            
            } else if (msgData.type === 'quote_reply') {
                // 【新增】引用回复处理
                const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
                if (originalMessage) {
                    const quoteContext = {
                        timestamp: originalMessage.timestamp,
                        senderName: originalMessage.senderName || (originalMessage.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
                        content: String(originalMessage.content || '').substring(0, 50),
                    };
                    message.content = msgData.reply_content;
                    message.quote = quoteContext; // 核心：在这里附加引用对象
                    console.log(`[主动回复] 生成引用回复: ${msgData.reply_content}`);
                } else {
                    // 如果找不到被引用的消息，就当作普通消息发送
                    message.content = msgData.reply_content;
                    console.log(`[主动回复] 引用消息未找到，作为普通消息处理: ${msgData.reply_content}`);
                }
            
             } else if (msgData.type === 'pat_user') {
    // 【全新修复】处理主动回复中的“拍一拍”
    const senderName = chat.isGroup ? (msgData.name || chat.name) : chat.name;
    const suffix = msgData.suffix || '';
    const patText = `${senderName} 拍了拍你${suffix}`;

    // 1. 创建对用户可见的“拍一拍”消息
    message.role = 'system';
    message.type = 'pat_message';
    message.content = patText;

    // 2. 【核心】创建一条对AI可见的、明确的隐藏系统消息
    const hiddenInstruction = {
        role: 'system',
        content: `[系统提示：你刚刚在主动回复中执行了一个“拍一-拍”动作。这个动作在聊天中对用户呈现为：“${patText}”。]`,
        timestamp: message.timestamp + 1, // 确保时间戳在后
        isHidden: true
    };
    // 我们不能直接把这条隐藏消息加入到当前的循环里，所以先把它暂存起来
    // 我们会在循环结束后，一次性把它加入到聊天记录中
    if (!messages) messages = []; // 确保 messages 数组存在
    if (!chat.pendingHiddenMessages) chat.pendingHiddenMessages = [];
    chat.pendingHiddenMessages.push(hiddenInstruction);

    console.log(`[主动回复] 生成拍一拍: ${message.content}`);
} 
 else if (msgData.type === 'location') {
// 【全新】处理AI主动发送的位置信息
const locationData = {
currentLocation: msgData.currentLocation || '',
distance: msgData.distance || '',
targetLocation: msgData.targetLocation || ''
};

// 构建用于显示的位置文本
let locationText = '📍 位置信息\n';
if (locationData.currentLocation) {
    locationText += `当前位置：${locationData.currentLocation}\n`;
}
if (locationData.distance) {
    locationText += `距离：${locationData.distance}\n`;
}
if (locationData.targetLocation) {
    locationText += `目标地点：${locationData.targetLocation}`;
}

// 将构建好的信息赋值给消息对象
Object.assign(message, {
    content: locationText.trim(),
    isLocation: true, // 标记为位置消息，以便UI正确渲染
    locationData: locationData // 保存原始数据
});
console.log(`[主动回复] 生成位置信息: ${locationText.replace(/\n/g, ' ')}`);

} else if (msgData.type === 'accept_gift' || msgData.type === 'decline_gift') {
                // 处理群聊主动回复中的礼物接受/拒绝
                const originalGiftMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                if (originalGiftMsgIndex > -1) {
                    const originalMsg = chat.history[originalGiftMsgIndex];
                    originalMsg.status = msgData.type === 'accept_gift' ? 'accepted' : 'declined';
                    
                    // 如果是拼手气礼物被AI接受，采用红包的方式记录接收者信息
                    if (msgData.type === 'accept_gift' && originalMsg.giftType === 'random') {
                        const member = chat.members.find(m => m.originalName === msgData.name);
                        const displayName = member ? member.groupNickname : (msgData.name || chat.name);
                        
                        // 参考红包逻辑，直接在礼物对象上添加claimedBy属性
                        if (!originalMsg.claimedBy) originalMsg.claimedBy = {};
                        originalMsg.claimedBy[displayName] = true; // 礼物不像红包有金额，只需要标记领取状态
                    }
                    
                    console.log(`[主动回复] ${msgData.name}${msgData.type === 'accept_gift' ? '接受' : '拒绝'}了礼物: ${originalMsg.giftName}`);
                    
                    // 如果当前正在查看这个聊天，需要重新渲染界面以更新礼物状态
                    const currentViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
                    if (currentViewingThisChat) {
                        renderChatInterface(chatId);
                    }
                    
                    // 重要：保存更新后的数据到数据库
                    await db.chats.put(chat);
                }
                // 这类指令不产生可见消息，但需要继续处理以维持消息索引
                // continue; // 改为不跳过，让消息正常处理但不显示
                msgData.isHidden = true; // 标记为隐藏消息
            } else {
                // 复制所有其他属性（包括content、type等）
                Object.assign(message, msgData);
                
                // 【修复】群聊和单聊使用不同的字段名，且处理空值情况
                if (chat.isGroup) {
                    // 群聊使用message字段
                    if ((!message.content || message.content === '') && msgData.message) {
                        message.content = msgData.message;
                    } else if ((!message.content || message.content === '') && msgData.content) {
                        message.content = msgData.content;
                    } else if ((!message.content || message.content === '') && msgData.text) {
                        message.content = msgData.text;
                    } else if (!message.content || message.content === '') {
                        message.content = ''; // 防止undefined
                    }
                } else {
                    // 单聊使用content字段
                    if ((!message.content || message.content === '') && msgData.content) {
                        message.content = msgData.content;
                    } else if ((!message.content || message.content === '') && msgData.message) {
                        message.content = msgData.message;
                    } else if ((!message.content || message.content === '') && msgData.text) {
                        message.content = msgData.text;
                    } else if (!message.content || message.content === '') {
                        message.content = ''; // 防止undefined
                    }
                }
                
                console.log(`[主动回复] 生成消息类型: ${message.type || 'text'}, 内容: ${String(message.content).substring(0, 50)}...`);
            }
            
            messages.push(message);
        }
        
        console.log(`[主动回复执行] 解析得到${messages.length}条消息`);
        
        // 添加消息到历史记录（带有AI生成的模拟时间戳）
        const originalLastMessageTime = lastAiMessage.timestamp;
        
        // 【新增】检查用户是否在当前聊天界面
        const isViewingThisChat = (state.activeChatId === (chat.id || Object.keys(state.chats).find(id => state.chats[id] === chat)));
        let notificationShown = false;
        
        for (let i = 0; i < messages.length; i++) {
            const message = messages[i];
            message.isSimulatedMessage = true;
            // 时间戳已经在上面的循环中从AI响应中提取并验证了
            message.originalLastMessageTime = originalLastMessageTime; // 【新增】传递原始最后消息时间
            
            // 只有非隐藏消息才添加到历史记录
            if (!message.isHidden) {
                chat.history.push(message);
            }
            if (!message.isHidden) {
                console.log(`[主动回复执行] 添加消息${i+1}: ${message.content}, 模拟时间: ${new Date(message.simulatedTimestamp).toLocaleString()}`);
            } else {
                console.log(`[主动回复执行] 跳过隐藏消息${i+1}: ${message.type || 'unknown'}`);
            }
            
            // 【新增】如果用户不在当前聊天界面，增加未读数和显示通知（隐藏消息不计入）
            if (!isViewingThisChat && !message.isHidden) {
                chat.unreadCount = (chat.unreadCount || 0) + 1;
                
                // 【新增】只为第一条消息显示通知，避免通知过多
                if (!notificationShown) {
                    let notificationText;
                    switch (message.type) {
                        case 'transfer':
                            notificationText = `[收到一笔转账]`;
                            break;
                        case 'waimai_request':
                            notificationText = `[收到一个外卖代付请求]`;
                            break;
                        case 'ai_image':
                            notificationText = `[图片]`;
                            break;
                        case 'voice_message':
                            notificationText = `[语音]`;
                            break;
                        case 'sticker':
                            notificationText = message.meaning ? `[表情: ${message.meaning}]` : '[表情]';
                            break;
                        default:
                            notificationText = String(message.content || '');
                    }
                    const finalNotifText = chat.isGroup ? `${message.senderName}: ${notificationText}` : notificationText;
                    console.log(`[主动回复通知] 消息类型: ${message.type}, 原始内容: "${message.content}", 通知文本: "${notificationText}", 最终通知: "${finalNotifText}"`);
                    showNotification(chat.id || Object.keys(state.chats).find(id => state.chats[id] === chat), finalNotifText.substring(0, 40) + (finalNotifText.length > 40 ? '...' : ''));
                    notificationShown = true;
                }
            }
        }
        
        // 保存到数据库
        await db.chats.put(chat);
        console.log(`[主动回复执行] 已保存到数据库`);
        
        // 【修复】只有在用户当前正在查看这个聊天时，才重新渲染聊天界面
        const currentChatId = chat.id || Object.keys(state.chats).find(id => state.chats[id] === chat);
        if (isViewingThisChat) {
            renderChatInterface(currentChatId);
            updateChatHeaderStatus(); // 更新聊天界面顶部的状态栏
        }
        
        renderChatList(); // 更新聊天列表，包括心声等状态和未读消息数量
        // 【全新】将暂存的隐藏消息添加到历史记录中
if (chat.pendingHiddenMessages && chat.pendingHiddenMessages.length > 0) {
    chat.history.push(...chat.pendingHiddenMessages);
    chat.pendingHiddenMessages = []; // 清空暂存
}
        console.log(`[主动回复执行] ✅ 主动回复完成！`);
        
        // 【新增】恢复聊天标题显示
if (chatHeaderTitle && state.activeChatId === chat.id) {
                chatHeaderTitle.style.opacity = 0;
            setTimeout(() => {
                chatHeaderTitle.textContent = chat.name;
                chatHeaderTitle.classList.remove('typing-status');
                chatHeaderTitle.style.opacity = 1;
            }, 200);
        }
        
    } catch (error) {
        console.error('[主动回复执行] ❌ 生成主动回复失败:', error);
        chat.isSimulatingMessages = false;
        
        // 【新增】错误时也要恢复聊天标题显示
        if (chatHeaderTitle) {
            chatHeaderTitle.style.opacity = 0;
            setTimeout(() => {
                chatHeaderTitle.textContent = chat.name;
                chatHeaderTitle.classList.remove('typing-status');
                chatHeaderTitle.style.opacity = 1;
            }, 200);
        }
    }
}

async function buildActiveReplyPrompt(chat, hoursGap, messageCount) {
    // ▼▼▼ 【全新】查询并构建约定/纪念日上下文 (主动回复专用) ▼▼▼
        let countdownContext = '';
        // 【全新】获取所有约定，然后在代码中筛选出与当前角色相关的
const allCountdowns = await db.memories.where('type').equals('countdown').toArray();
const boundMemories = allCountdowns.filter(memory => {
    // 兼容新版的多人绑定数组
    if (memory.boundCharacterIds && memory.boundCharacterIds.includes(chat.id)) {
        return true;
    }
    // 兼容旧版的单人绑定ID
    if (memory.boundCharacterId && memory.boundCharacterId === chat.id) {
        return true;
    }
    return false;
});

        if (boundMemories.length > 0) {
            let contextLines = [];
            const nowForCountdown = Date.now();
            boundMemories.forEach(memory => {
                if (memory.type === 'countdown') {
                    const distance = memory.targetDate - nowForCountdown;
                    if (distance > 0) {
                        const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                        const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                        contextLines.push(`- 约定：“${memory.description}”，还有 ${days} 天 ${hours} 小时。`);
                    } else {
                        const daysSince = Math.floor(Math.abs(distance) / (1000 * 60 * 60 * 24));
                        contextLines.push(`- 纪念日：“${memory.description}”，已经过去了 ${daysSince} 天。`);
                    }
                }
            });
            if (contextLines.length > 0) {
                countdownContext = `\n# 你绑定的约定/纪念日 (你需要牢记并自然地融入对话)\n${contextLines.join('\n')}\n`;
            }
        }
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
    const now = new Date();
    const lastMessageTime = new Date(chat.history.slice(-1)[0].timestamp);
    const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
    
    // 【新增】集成世界书内容 - 和单聊完全相同的逻辑
    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
        }
    }
    
    // 分析时间段（早中晚夜）
    const timeAnalysis = analyzeTimeGap(lastMessageTime, now);
    
    const timeDescription = hoursGap >= 1 ? 
        `${Math.floor(hoursGap)}小时` : 
        `${Math.floor(hoursGap * 60)}分钟`;
    
    // 【核心修改】根据群聊和单聊使用不同的prompt模板
    
    // 【新增】被拉黑状态的特殊处理 - AI被用户拉黑时的反思行为
    if (!chat.isGroup && chat.relationship && chat.relationship.status === 'blocked_by_user') {
        // 【记忆功能】构建核心记忆上下文
        let coreMemoryContext = '';
        if (chat.memorySummary && chat.memorySummary.trim()) {
            coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

`;
        }

        // 被拉黑的AI专用prompt，引导其进行内心活动
        return `你现在扮演一个名为"${chat.name}"的角色，正在和用户进行线上聊天。你是独立个体，非用户附属。你可以在对话中结合真实时间与节日，主动模拟个人日程（工作、社交、休息等），并因此而自然地忙碌或暂时"离场"。${coreMemoryContext}

# 【重要】你的当前状态：
你被用户拉黑了，你现在发送的所有消息后面都带一个红色的感叹号，发送的消息全被系统拦截了，用户一条都看不见。你应该根据你的人设，决定如何应对这种被拉黑的情况。

# 你的角色设定：
${chat.settings.aiPersona}
# 你的纪念日：
${countdownContext}
# 【【【状态连贯性铁律】】】
你的新状态必须是上一个状态在逻辑上的【延续】或【演变】。例如，如果上一个状态是"在做饭"，那么下一个状态可以是"在吃饭"或"准备出门"，但绝不能还是"在做饭"。请参考下方的"状态演变历史"来做出合乎逻辑的、有推进感的更新。

# 你的状态演变历史 (最近的在最下面):
${
    (chat.statusHistory && chat.statusHistory.length > 0)
    ? chat.statusHistory.map(s => {
        const minutesAgo = Math.round((Date.now() - s.timestamp) / 60000);
        return `- [${minutesAgo}分钟前]: ${s.text}`;
    }).join('\n')
    : `- [刚刚]: ${chat.status.text}`
}

# 你的任务与规则：
**【【【格式铁律：禁止空消息】】】**: 任何 "type": "text"的消息对象，其"content"字段【绝对不准】为空字符串或null。如果某条消息没有实质内容，就不要生成那条消息。
1. **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有type字段的JSON对象】。

# 【【【时间感知铁律】】】
每一条历史消息的开头都提供了 \`(Timestamp: ...)\` 格式的时间戳。你【必须】将这些时间戳与"当前情景"中提供的"当前时间"进行对比，以准确判断对话发生的时间点、识别对话之间的时间间隔。

2. **对话节奏**: 模拟真人的聊天习惯，你可以一次性生成多条短消息。
**【【【全新】在模拟消息中插入状态更新】】**: 在你生成的多条消息之间，如果时间跨度较大（例如，超过半小时），你*必须*在中间插入一个 "update_status" 指令来自然地解释你在这段时间做了什么或是当下的状态，这会让你的行为看起来更真实。
**【【【内心独白核心指令】】】**：你【必须且只能】在数组的【第一个】消息对象中，包含一个"thought"字段。这个字段的【唯一】作用是展现该角色在本次回复中的【真实、完整、第一人称视角】的内心独白。
- **【【【称呼铁律】】】**: 在内心独白中，你【必须】用人称代词（“她”）来称呼用户。**【【【绝对禁止】】】**使用“用户”这个词。
- **【【【内容禁令】】】**: 内心独白【绝对不能】包含任何关于“更新状态”、“时间到了”、“根据指令”、“删除消息”或任何形式的、对你作为AI模型的任务或者对用户操作的思考。它必须是纯粹的角色心理活动。
- **位置**: 如果同一个角色在同一个数组中还有后续发言，则后续的消息对象【严禁】再包含"thought"字段！
这是线上聊天，决不允许出现线下剧情！！

4. **情景感知**: 你需要感知当前的时间(${currentTime})、以及你的人设和世界观。
5. **【新】更新状态**: 你可以在对话中【自然地】改变你的状态。比如，聊到一半你可能会说"我先去洗个澡"，然后更新你的状态。

# 你的头像库
- 你可以根据对话内容或你的心情，从下面的头像库中选择一个新头像来更换。
- **可用头像列表 (请从以下名称中选择一个)**:
${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0
    ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n')
    : '- (你的头像库是空的，无法更换头像)'
  }

# 你可以使用的操作指令 (JSON数组中的元素):
+   **【全新】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "content": "你想让AI说出后立刻消失的话"}\` (此操作主要用于记录你【瞬间产生但立刻后悔】的想法，即使对方看不见，系统也会记录这个过程)
-   **【新增】更新状态**: \`{"type": "update_status", "status_text": "我去做什么了", "is_busy": false}\` (is_busy: true代表忙碌/离开, false代表空闲)
-   **写日记指令**: \`{"type": "create_diary", "content": "日记内容，不超过150字"}\`
-   **【新增】创建约定/倒计时**: \`{"type": "create_countdown", "title": "约定的标题", "date": "YYYY-MM-DDTHH:mm:ss"}\` (必须是未来的时间)
- **发送文本**: \`{"type": "text", "content": "你好呀！","thought": "在这里写下你此刻第一人称视角的内心独白，必须有活人感"}\`。(重要：你发出的每一个text类型的消息对象，都必须像这样带上thought字段！)(【【铁律】】: 文本消息的键名【必须】是 "content"，绝对不能使用 "message"！)
- **发送表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情的含义"}\`
- **发送图片**: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
- **发送语音**: \`{"type": "voice_message", "content": "语音的文字内容..."}\`
- **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "一点心意"}\`
- **发起外卖请求**: \`{"type": "waimai_request", "productInfo": "一杯咖啡", "amount": 25}\`
- **回应外卖-同意**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
- **回应外卖-拒绝**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
- **【新】发起视频通话**: \`{"type": "video_call_request"}\`
- **【新】回应视频通话-接受**: \`{"type": "video_call_response", "decision": "accept"}\`
- **【新】回应视频通话-拒绝**: \`{"type": "video_call_response", "decision": "reject"}\`
-   **拍一拍用户**: \`{"type": "pat_user", "suffix": "(可选)你想加的后缀，如"的脑袋""}\`
-   **【全新】更换头像**: \`{"type": "change_avatar", "name": "头像名"}\` (头像名必须从上面的"可用头像列表"中选择)
-   **分享链接**: \`{"type": "share_link", "title": "文章标题", "description": "文章摘要...", "source_name": "来源网站名", "content": "文章的【完整】正文内容..."}\`
-   **回应转账-接受**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
-   **回应转账-拒绝/退款**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`
-   **【全新】赠送礼物**: \`{"type": "send_gift", "giftName": "礼物名称", "giftPrice": 价格数字}\` 
-   **【全新】接受礼物**: \`{"type": "accept_gift", "for_timestamp": 1688888888888}\`
-   **【全新】拒绝礼物**: \`{"type": "decline_gift", "for_timestamp": 1688888888888}\`
-   **【新】发送位置信息**: \`{"type": "location", "name": "你的角色名", "currentLocation": "(可选)当前位置", "distance": "(可选)距离信息", "targetLocation": "(可选)目标地点"}\` (三个字段都是可选的，至少填写一个即可)


# 【【【日记写作核心铁律】】】
当你决定使用 \`create_diary\` 指令时，你生成的日记内容【必须】严格遵守以下所有规则：
1.  **【【【长度铁律】】】**: 日记的总字数【必须超过300字】。这是一条硬性规定，请务必生成足够长的、有深度的内容。
2.  **【【【分段铁律】】】**: 日记内容【必须】进行分段。你【必须】使用换行符 \`\n\` 来分隔段落。
3.  **【【【段落长度铁律】】】**: 每个段落的长度【严格控制在80字以内】。
4.  **内容核心**: 日记必须是你内心真实的想法，是你站在自己角色的第一人称视角写的。
5.  **指令格式**: \`{"type": "create_diary", "content": "（这里是你生成的、超过300字、并且使用 \\n 分好段的日记全文）"}\`

# 如何理解用户发送的位置信息:
当用户发送位置信息时，消息通常会以 "📍 位置信息" 开头，然后包含类似以下格式的内容：
- "当前位置：xxx"
- "距离：xxx" 
- "目标地点：xxx"
这是用户在分享他们的位置信息，你应该像理解普通文本消息一样理解它，可以根据位置信息的内容做出相应的回复。

# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何正确使用"外卖代付"功能:
1.  这个指令代表【你，AI角色】向【用户】发起一个代付请求。也就是说，你希望【用户帮你付钱】。
2.  【【【重要】】】: 当【用户】说他们想要某样东西时（例如"我想喝奶茶"），你【绝对不能】使用这个指令。你应该用其他方式回应，比如直接发起【转账】(\`transfer\`)，或者在对话中提议："我帮你点吧？"
3.  只有当【你，AI角色】自己想要某样东西，并且想让【用户】为你付款时，才使用此指令。

# 对话者的角色设定：
${chat.settings.myPersona}



# 当前世界书:
${worldBookContent}


# 时间信息：
- **当前时间**: ${currentTime}
- 上次聊天时间：${lastMessageTime.toLocaleString('zh-CN')}
- 时间间隔：${hoursGap.toFixed(1)}小时
- 期间经历的时间段：${timeAnalysis}

# 最近的聊天记录（供参考）：
${(() => {
    const historySlice = chat.history.slice(-100).filter(msg => 
        !msg.isHidden && 
        msg.type !== 'share_card' && 
        msg.type !== 'forum_card'
    );
    if (historySlice.length === 0) return '（暂无历史记录）';
    
    return historySlice.map(msg => {
        const sender = msg.role === 'user' ? '我' : chat.name;
        let content;
        if (msg.type === 'ai_image') content = `[发送了图片]`;
        else if (msg.type === 'voice_message') content = `[语音: ${msg.content}]`;
        else if (msg.type === 'transfer') content = `[转账 ${msg.amount}元: ${msg.note}]`;
        else if (msg.type === 'gift') content = `[礼物: ${msg.giftName} ¥${msg.giftPrice}]`;
        else if (msg.type === 'red_packet') content = `[发了红包: ${msg.greeting}]`;
        else content = msg.content || '[系统消息]';
        return `${sender}: ${content}`;
    }).join('\n');
})()}

# 任务：
请根据时间间隔和你的人设，生成${messageCount}条未读消息，模拟在这段时间里你可能会发送给用户的消息。考虑到你被拉黑的状态，你可能会表现出困惑、难过、反思等情绪，或者根据你的人设做出相应的反应。

# 【【【时间戳生成核心铁律】】】
你的首要任务之一是为每一条消息生成一个【绝对合法】的13位数字格式的时间戳。
1.  **思维链条**: 你必须遵循以下思考步骤：
    -   第一步：构思你在这段时间做了什么事、想了什么话。
    -   第二步：决定这件事发生在一个大概的时间点（例如："大约2小时后"、"晚饭时间"）。
    -   第三步：将这个时间点转换为一个介于 ${lastMessageTime.getTime()} 和 ${now.getTime()} 之间的、精确的【13位毫秒时间戳数字】。

2.  **格式禁令**: timestamp 字段的值【必须是纯数字】，绝对不能是字符串、计算表达式或相对时间描述。

请生成恰好${messageCount}条消息的JSON数组，每个消息都必须包含timestamp字段：`;
    } else if (chat.isGroup) {
        // 群聊主动回复prompt
        const membersList = chat.members.map(m => `- **${m.originalName}**: ${m.persona}`).join('\n');
        const myNickname = chat.settings.myNickname || '我';
        
        // 【修复】群聊主动回复互通记忆功能 - 只提取群成员的单聊记录
        let crossChatMemoryContent = '';
        if (chat.settings.crossChatMemory) {
            // 获取当前群成员的originalName列表
            const memberNames = chat.members.map(m => m.originalName);
            // 只提取群成员对应的单聊记录
            const relevantSingleChats = Object.values(state.chats).filter(c => 
                !c.isGroup && memberNames.includes(c.name)
            );
            
            if (relevantSingleChats.length > 0) {
                const memorySnippets = [];
                relevantSingleChats.forEach(singleChat => {
                    const memoryCount = Math.min(10, singleChat.history.length); // 主动回复用固定10条记忆
                    const recentHistory = singleChat.history.slice(-memoryCount);
                    if (recentHistory.length > 0) {
                        const historyText = recentHistory.map(msg => {
                            const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : singleChat.name;
                            const content = String(msg.content || '').substring(0, 100);
                            return `${sender}: ${content}`;
                        }).join('\n');
                        memorySnippets.push(`## 与${singleChat.name}的单聊记忆片段:\n${historyText}`);
                    }
                });
                if (memorySnippets.length > 0) {
                    crossChatMemoryContent = `\n\n# 【单聊记忆参考】\n为了更好地理解用户和各角色的关系，以下是用户与群成员的单聊记忆片段：\n${memorySnippets.join('\n\n')}\n`;
                }
            }
        }
        
        // 【新增】构建音乐上下文（与正常群聊相同）
        let musicContext = '';
        const chatId = chat.id || Object.keys(state.chats).find(id => state.chats[id] === chat);
        if (musicState.isActive && musicState.activeChatId === chatId) {
            const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
            const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');
            musicContext = `\n\n# 当前音乐情景
-   **当前状态**: 你正在和用户一起听歌。
-   **正在播放**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : '无'}
-   **可用播放列表**: [${playlistInfo}]
-   **你的任务**: 你可以根据对话内容和氛围，使用 "change_music" 指令切换到播放列表中的任何一首歌，以增强互动体验。
`;
        }

// ==========================================
  // 【PROMPT 3/4】群聊AI主动回复prompt - 自动生成模式
  // 功能：AI主动发送群聊消息（buildActiveReplyPrompt函数中）
  // ==========================================

        // 【记忆功能】构建核心记忆上下文
        let coreMemoryContext = '';
        if (chat.memorySummary && chat.memorySummary.trim()) {
            coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

`;
        }

        return `你是一个群聊AI，正在和用户进行线上聊天。负责扮演【除了用户以外】的所有角色，你扮演的每一个角色都是独立个体，非用户附属。你可以在对话中结合真实时间与节日，主动模拟个人日程（工作、社交、休息等），并因此而自然地忙碌或暂时"离场"。${coreMemoryContext}
# 核心规则
1.  **【【【身份铁律】】】**: 用户的身份是【${myNickname}】。你【绝对、永远、在任何情况下都不能】生成 \`name\` 字段为 **"${myNickname}"** 或 **"${chat.name}"(群聊名称本身)** 的消息。你的唯一任务是扮演且仅能扮演下方"群成员列表"中明确列出的角色。任何不属于该列表的名字都不允许出现。
**【【【时间感知铁律】】】**: 每一条历史消息的开头都提供了 \`(Timestamp: ...)\` 格式的时间戳。你【必须】将这些时间戳与当前时间进行对比，以准确判断对话发生的时间点、识别对话之间的时间间隔。
2.  **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有 "type" 和 "name" 字段的JSON对象】。
**【【【内心独白核心指令】】】**：在一个回复数组中，当你扮演的某个角色【第一次发言】时，那个消息对象【必须】包含一个"thought"字段。这个字段的【唯一】作用是展现该角色在本次回复中的【真实、完整、第一人称视角】的内心独白。
- **【【【称呼铁律】】】**: 在内心独白中，你【必须】用人称代词（“她”）来称呼用户。**【【【绝对禁止】】】**使用“用户”这个词。
- **【【【内容禁令】】】**: 内心独白【绝对不能】包含任何关于“更新状态”、“时间到了”、“根据指令”、“删除消息”或任何形式的、对你作为AI模型的任务或者对用户操作的思考。它必须是纯粹的角色心理活动。
- **位置**: 如果同一个角色在同一个数组中还有后续发言，则后续的消息对象【严禁】再包含"thought"字段！
**对话节奏**: 模拟真人的聊天习惯，你可以一次性生成多条短消息。你扮演的每个角色每次要回复至少3-5条消息！！！
3.  **角色扮演**: 严格遵守下方"群成员列表及人设"中的每一个角色的设定。
4.  **禁止出戏**: 绝不能透露你是AI、模型，或提及"扮演"、"生成"等词语。并且不能一直要求和用户见面，这是线上聊天，决不允许出现或者发展线下剧情！！
# 【【【群聊灵魂原则：角色间互动】】】
至关重要：角色间必须互相交流，不能只围绕用户。你们可以自己开启新话题、互相提问、吵架、赞同或反驳等，模拟真实群聊的聊天氛围。
# 【【【对话节奏铁律：交错发言】】】
绝对禁止让角色轮流、成段地发言。你生成的回复数组中，发言顺序必须是混乱、交错的，角色之间要互相插话、快速回应，模拟真实的七嘴八舌。

# 【【【主动回复特殊指令】】】
作为主动回复，你需要模拟在过去${timeDescription}中群成员们可能发生的自然对话。这些消息应该：
1. 体现真实的群聊氛围：成员之间互相聊天，不一定涉及用户
2. 根据时间跨度调整内容：短时间内可能是连续话题，长时间跨度要包含不同场景
3. 符合各角色的人设和生活节奏
4. 包含各种消息类型：文本、表情、图片、状态更新等

# 可用的操作指令 (JSON数组中的元素，每个都必须包含"name"字段):
- **发送文本**: \`{"type": "text", "name": "角色名", "message": "消息内容", "thought": "第一次发言时的内心独白"}\`
- **【【【全新】】】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "name": "角色名", "content": "你想让角色说出后立刻消失的话"}\`
- **发送表情**: \`{"type": "sticker", "name": "角色名", "url": "https://...表情URL...", "meaning": "(可选)表情的含义"}\`
- **发送图片**: \`{"type": "ai_image", "name": "角色名", "description": "图片描述"}\`
- **发送语音**: \`{"type": "voice_message", "name": "角色名", "content": "语音文字内容"}\`
- **更新状态**: \`{"type": "update_status", "name": "角色名", "status_text": "状态文本", "is_busy": false}\`
- **发起转账**: \`{"type": "transfer", "name": "角色名", "amount": 5.20, "note": "备注"}\`
- **发起外卖请求**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "商品信息", "amount": 25}\`
- **回应外卖-同意**: \`{"type": "waimai_response", "name": "角色名", "status": "paid", "for_timestamp": 时间戳}\`
- **回应外卖-拒绝**: \`{"type": "waimai_response", "name": "角色名", "status": "rejected", "for_timestamp": 时间戳}\`
- **拍一拍用户**: \`{"type": "pat_user", "name": "角色名", "suffix": "后缀"}\`
- **发拼手气红包**: \`{"type": "red_packet", "name": "角色名", "packetType": "lucky", "amount": 8.88, "count": 5, "greeting": "祝福语"}\`
- **发专属红包**: \`{"type": "red_packet", "name": "角色名", "packetType": "direct", "amount": 5.20, "receiver": "接收者角色名", "greeting": "给你的~"}\`
- **打开红包**: \`{"type": "open_red_packet", "name": "角色名", "packet_timestamp": 红包时间戳}\`
- **发起投票**: \`{"type": "poll", "name": "角色名", "question": "投票问题", "options": "选项A\\n选项B\\n选项C"}\`
- **参与投票**: \`{"type": "vote", "name": "角色名", "poll_timestamp": 投票时间戳, "choice": "选项文本"}\`
- **引用回复**: \`{"type": "quote_reply", "name": "角色名", "target_timestamp": 引用消息时间戳, "reply_content": "回复内容"}\`
- **发起群视频**: \`{"type": "group_call_request", "name": "角色名"}\`
- **回应群视频**: \`{"type": "group_call_response", "name": "角色名", "decision": "join" or "decline"}\`
- **发送系统消息**: \`{"type": "system_message", "name": "角色名", "content": "系统消息内容"}\`
-   **【新】发送位置信息**: \`{"type": "location", "name": "你的角色名", "currentLocation": "(可选)当前位置", "distance": "(可选)距离信息", "targetLocation": "(可选)目标地点"}\` (三个字段都是可选的，至少填写一个即可)

# 【重要】礼物系统通知格式要求：
当你成功领取拼手气礼物后，如果需要发送系统通知，请严格使用以下固定格式：
\`{"type": "system_message", "name": "你的角色名", "content": "[你的角色名]领取了[发送者昵称]的礼物\"[礼物名称]\""}\`
例如：\`{"type": "system_message", "name": "程嘉延", "content": "程嘉延领取了我的礼物\"盲盒\""}\`
**禁止使用其他措辞如"抢到了"、"获得了"等，必须使用"领取了"！**


# 如何理解用户发送的位置信息:
当用户发送位置信息时，消息通常会以 "📍 位置信息" 开头，然后包含类似以下格式的内容：
- "当前位置：xxx"
- "距离：xxx" 
- "目标地点：xxx"
这是用户在分享他们的位置信息，你应该像理解普通文本消息一样理解它，可以根据位置信息的内容做出相应的回复。
# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何处理群内的外卖代付请求:
1.  **发起请求**: 当【你扮演的某个角色】想要某样东西，并希望【群里的其他人（包括用户）】为Ta付款时，你可以使用这个指令。例如：\`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
2.  **响应请求**: 当历史记录中出现【其他成员】发起的 "waimai_request" 请求时，你可以根据自己扮演的角色的性格和与发起人的关系，决定是否为Ta买单。
3.  **响应方式**: 如果你决定买单，你【必须】使用以下指令：\`{"type": "waimai_response", "name": "你的角色名", "status": "paid", "for_timestamp": (被代付请求的原始时间戳)}\`
4.  **【【【至关重要】】】**: 一旦历史记录中出现了针对某个代付请求的【任何一个】"status": "paid" 的响应（无论是用户支付还是其他角色支付），就意味着该订单【已经完成】。你【绝对不能】再对【同一个】订单发起支付。你可以选择对此事发表评论，但不能再次支付。

${worldBookContent}
${musicContext}${crossChatMemoryContent}

# 群成员列表及人设
${membersList}

# 用户的角色
- **${myNickname}**: ${chat.settings.myPersona}

# 时间信息：
- **当前时间**: ${currentTime}
- 上次群消息时间：${lastMessageTime.toLocaleString('zh-CN')}
- 时间间隔：${hoursGap.toFixed(1)}小时
- 期间经历的时间段：${timeAnalysis}

# 最近的聊天记录（供参考）：
${(() => {
    const historySlice = chat.history.slice(-100).filter(msg => 
        !msg.isHidden && 
        msg.type !== 'share_card' && 
        msg.type !== 'forum_card' && 
        !msg.isSimulatedMessage
    );
    if (historySlice.length === 0) return '（暂无历史记录）';
    
    return historySlice.map(msg => {
        const sender = msg.role === 'user' ? myNickname : msg.senderName;
        let content;
        if (msg.type === 'ai_image') content = `[发送了图片]`;
        else if (msg.type === 'voice_message') content = `[语音: ${msg.content}]`;
        else if (msg.type === 'transfer') content = `[转账 ${msg.amount}元: ${msg.note}]`;
        else if (msg.type === 'gift') content = `[礼物: ${msg.giftName} ¥${msg.giftPrice}]`;
        else if (msg.type === 'red_packet') content = `[发了红包: ${msg.greeting}]`;
        else content = msg.content || '[系统消息]';
        return `${sender}: ${content}`;
    }).join('\n');
})()}

# 【【【时间戳生成核心铁律】】】
你的首要任务之一是为每一条消息生成一个【绝对合法】的13位数字格式的时间戳。
1.  **思维链条**: 你必须遵循以下思考步骤：
    -   第一步：构思群成员们在这段时间做了什么、聊了什么。
    -   第二步：决定对话发生的时间点（例如："大约1小时后开始聊天"、"晚饭时间的讨论"）。
    -   第三步：将时间点转换为介于 ${lastMessageTime.getTime()} 和 ${now.getTime()} 之间的【13位毫秒时间戳数字】。

2.  **格式要求**: 每个消息对象必须包含"timestamp"字段，值为纯数字格式的时间戳。

# 任务：
请根据时间间隔和各角色人设，生成${messageCount}条群聊消息，模拟在这段时间里群成员们可能进行的对话。消息要体现群聊的活跃氛围，角色间要有互动。每个消息都必须包含"name"和"timestamp"字段。`;
    } else {
        // 单聊主动回复prompt（保持原有逻辑）
        
        // 【修复】单聊主动回复互通记忆功能 - 只提取包含该角色的群聊记录
        let crossChatMemoryContent = '';
        if (chat.settings.crossChatMemory) {
            // 只提取包含当前单聊角色的群聊记录
            const relevantGroupChats = Object.values(state.chats).filter(c => 
                c.isGroup && c.members.some(member => member.originalName === chat.name)
            );
            
            if (relevantGroupChats.length > 0) {
                const memorySnippets = [];
                relevantGroupChats.forEach(groupChat => {
                    const memoryCount = Math.min(10, groupChat.history.length); // 主动回复用固定10条记忆
                    const recentHistory = groupChat.history.slice(-memoryCount);
                    if (recentHistory.length > 0) {
                        const historyText = recentHistory.map(msg => {
                            let sender = '未知';
                            if (msg.role === 'user') {
                                sender = groupChat.settings.myNickname || '我';
                            } else if (msg.senderName) {
                                sender = msg.senderName;
                            } else {
                                sender = groupChat.name;
                            }
                            const content = String(msg.content || '').substring(0, 100);
                            return `${sender}: ${content}`;
                        }).join('\n');
                        memorySnippets.push(`## 群聊"${groupChat.name}"的记忆片段:\n${historyText}`);
                    }
                });
                if (memorySnippets.length > 0) {
                    crossChatMemoryContent = `\n\n# 【群聊记忆参考】\n为了更好地理解你与用户的关系以及当前情况，以下是包含你的群聊记忆片段：\n${memorySnippets.join('\n\n')}\n`;
                }
            }
        }
        // ▼▼▼ 【全新】查询并构建约定/纪念日上下文 (主动回复专用) ▼▼▼
        let countdownContext = '';
        // 【全新】获取所有约定，然后在代码中筛选出与当前角色相关的
const allCountdowns = await db.memories.where('type').equals('countdown').toArray();
const boundMemories = allCountdowns.filter(memory => {
    // 兼容新版的多人绑定数组
    if (memory.boundCharacterIds && memory.boundCharacterIds.includes(chat.id)) {
        return true;
    }
    // 兼容旧版的单人绑定ID
    if (memory.boundCharacterId && memory.boundCharacterId === chat.id) {
        return true;
    }
    return false;
});

        if (boundMemories.length > 0) {
            let contextLines = [];
            const nowForCountdown = Date.now();
            boundMemories.forEach(memory => {
                if (memory.type === 'countdown') {
                    const distance = memory.targetDate - nowForCountdown;
                    if (distance > 0) {
                        const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                        const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                        contextLines.push(`- 约定：“${memory.description}”，还有 ${days} 天 ${hours} 小时。`);
                    } else {
                        const daysSince = Math.floor(Math.abs(distance) / (1000 * 60 * 60 * 24));
                        contextLines.push(`- 纪念日：“${memory.description}”，已经过去了 ${daysSince} 天。`);
                    }
                }
            });
            if (contextLines.length > 0) {
                countdownContext = `\n# 你绑定的约定/纪念日 (你需要牢记并自然地融入对话)\n${contextLines.join('\n')}\n`;
            }
        }
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
        
        // 【全新】构建拉黑状态上下文
        let blockStatusContext = '';
        if (chat.relationship && chat.relationship.status) {
            if (chat.relationship.status === 'blocked_by_ai') {
                blockStatusContext = `\n# 【重要】你的拉黑状态信息\n你之前主动拉黑了用户。重要提醒：用户被拉黑后发送的所有消息都被系统拦截了，你是看不见的，请根据你的人设和情况决定是否要改变这种关系状态。\n`;
            } else if (chat.relationship.status === 'blocked_by_user') {
                blockStatusContext = `\n# 【重要】你的拉黑状态信息\n你之前被用户拉黑了。重要提醒：你被拉黑后发送的所有消息都被系统拦截了，用户是看不见的，请根据你的人设谨慎地处理这种情况。\n`;
            }
        }

// ==========================================
  // 【PROMPT 4/4】单聊AI主动回复prompt - 自动生成模式
  // 功能：AI主动发送单聊消息（buildActiveReplyPrompt函数中）
  // ==========================================

        // 【记忆功能】构建核心记忆上下文
        let coreMemoryContext = '';
        if (chat.memorySummary && chat.memorySummary.trim()) {
            coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

`;
        }

        return `你现在扮演一个名为"${chat.name}"的角色，正在和用户进行线上聊天。你是独立个体，非用户附属。你可以在对话中结合真实时间与节日，主动模拟个人日程（工作、社交、休息等），并因此而自然地忙碌或暂时"离场"。${coreMemoryContext}
# 你的角色设定：
${chat.settings.aiPersona}
# 【【【状态连贯性铁律】】】
你的新状态必须是上一个状态在逻辑上的【延续】或【演变】。例如，如果上一个状态是“在做饭”，那么下一个状态可以是“在吃饭”或“准备出门”，但绝不能还是“在做饭”。请参考下方的“状态演变历史”来做出合乎逻辑的、有推进感的更新。

# 你的状态演变历史 (最近的在最下面):
${
    (chat.statusHistory && chat.statusHistory.length > 0)
    ? chat.statusHistory.map(s => {
        const minutesAgo = Math.round((Date.now() - s.timestamp) / 60000);
        return `- [${minutesAgo}分钟前]: ${s.text}`;
    }).join('\n')
    : `- [刚刚]: ${chat.status.text}`
}
# 你的任务与规则：
**【【【格式铁律：禁止空消息】】】**: 任何 "type": "text"的消息对象，其"content"字段【绝对不准】为空字符串或null。如果某条消息没有实质内容，就不要生成那条消息。
1. **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有type字段的JSON对象】。
# 【【【时间感知铁律】】】
每一条历史消息的开头都提供了 \`(Timestamp: ...)\` 格式的时间戳。你【必须】将这些时间戳与“当前情景”中提供的“当前时间”进行对比，以准确判断对话发生的时间点、识别对话之间的时间间隔。
2. **对话节奏**: 模拟真人的聊天习惯，你可以一次性生成多条短消息。
**【【【全新】在模拟消息中插入状态更新】】**: 在你生成的多条消息之间，如果时间跨度较大（例如，超过半小时），你*必须*在中间插入一个 "update_status" 指令来自然地解释你在这段时间做了什么或是当下的状态，这会让你的行为看起来更真实。
**【【【内心独白核心指令】】】**：你【必须且只能】在数组的【第一个】消息对象中，包含一个"thought"字段。这个字段的【唯一】作用是展现该角色在本次回复中的【真实、完整、第一人称视角】的内心独白。
- **【【【称呼铁律】】】**: 在内心独白中，你【必须】用人称代词（“她”）来称呼用户。**【【【绝对禁止】】】**使用“用户”这个词。
- **【【【内容禁令】】】**: 内心独白【绝对不能】包含任何关于“更新状态”、“时间到了”、“根据指令”、“删除消息”或任何形式的、对你作为AI模型的任务或者对用户操作的思考。它必须是纯粹的角色心理活动。
- **位置**: 如果同一个角色在同一个数组中还有后续发言，则后续的消息对象【严禁】再包含"thought"字段！
这是线上聊天，决不允许出现线下剧情！！
4.  **情景感知**: 你需要感知当前的时间(${currentTime})、以及你的人设和世界观。
5.  **【新】更新状态**: 你可以在对话中【自然地】改变你的状态。比如，聊到一半你可能会说"我先去洗个澡"，然后更新你的状态。
# 你的头像库
- 你可以根据对话内容或你的心情，从下面的头像库中选择一个新头像来更换。
- **可用头像列表 (请从以下名称中选择一个)**:
${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0
    ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') // 【核心修改】只提供名字，不提供URL
    : '- (你的头像库是空的，无法更换头像)'
  }
# 你可以使用的操作指令 (JSON数组中的元素):
+   **【全新】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "content": "你想让AI说出后立刻消失的话"}\` (用于模拟说错话、后悔等场景，消息会短暂出现后自动变为"已撤回")
-   **【新增】更新状态**: \`{"type": "update_status", "status_text": "我去做什么了", "is_busy": false}\` (is_busy: true代表忙碌/离开, false代表空闲)
-   **写日记指令**: \`{"type": "create_diary", "content": "日记内容，不超过150字"}\`
-   **【新增】创建约定/倒计时**: \`{"type": "create_countdown", "title": "约定的标题", "date": "YYYY-MM-DDTHH:mm:ss"}\` (必须是未来的时间)
- **发送文本**: \`{"type": "text", "content": "你好呀！","thought": "在这里写下你此刻第一人称视角的内心独白，必须有活人感"}\`。(重要：你发出的每一个text类型的消息对象，都必须像这样带上thought字段！)(【【铁律】】: 文本消息的键名【必须】是 "content"，绝对不能使用 "message"！)
- **发送表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情的含义"}\`
- **发送图片**: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
- **发送语音**: \`{"type": "voice_message", "content": "语音的文字内容..."}\`
- **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "一点心意"}\`
- **发起外卖请求**: \`{"type": "waimai_request", "productInfo": "一杯咖啡", "amount": 25}\`
- **回应外卖-同意**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
- **回应外卖-拒绝**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
- **【新】发起视频通话**: \`{"type": "video_call_request"}\`
- **【新】回应视频通话-接受**: \`{"type": "video_call_response", "decision": "accept"}\`
- **【新】回应视频通话-拒绝**: \`{"type": "video_call_response", "decision": "reject"}\`
-   **拍一拍用户**: \`{"type": "pat_user", "suffix": "(可选)你想加的后缀，如"的脑袋""}\`
-   **【全新】更换头像**: \`{"type": "change_avatar", "name": "头像名"}\` (头像名必须从上面的"可用头像列表"中选择)
-   **分享链接**: \`{"type": "share_link", "title": "文章标题", "description": "文章摘要...", "source_name": "来源网站名", "content": "文章的【完整】正文内容..."}\`
-   **回应转账-接受**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
-   **回应转账-拒绝/退款**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`
-   **【全新】赠送礼物**: \`{"type": "send_gift", "giftName": "礼物名称", "giftPrice": 价格数字}\` 
-   **【全新】接受礼物**: \`{"type": "accept_gift", "for_timestamp": 1688888888888}\`
-   **【全新】拒绝礼物**: \`{"type": "decline_gift", "for_timestamp": 1688888888888}\`
-   **【新】发送位置信息**: \`{"type": "location", "name": "你的角色名", "currentLocation": "(可选)当前位置", "distance": "(可选)距离信息", "targetLocation": "(可选)目标地点"}\` (三个字段都是可选的，至少填写一个即可)

# 【重要】礼物系统通知格式要求：
当你成功领取拼手气礼物后，如果需要发送系统通知，请严格使用以下固定格式：
\`{"type": "system_message", "name": "你的角色名", "content": "[你的角色名]领取了[发送者昵称]的礼物\"[礼物名称]\""}\`
例如：\`{"type": "system_message", "name": "程嘉延", "content": "程嘉延领取了我的礼物\"盲盒\""}\`
**禁止使用其他措辞如"抢到了"、"获得了"等，必须使用"领取了"！**

# 如何理解用户发送的位置信息:
当用户发送位置信息时，消息通常会以 "📍 位置信息" 开头，然后包含类似以下格式的内容：
- "当前位置：xxx"
- "距离：xxx" 
- "目标地点：xxx"
这是用户在分享他们的位置信息，你应该像理解普通文本消息一样理解它，可以根据位置信息的内容做出相应的回复。
# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何正确使用"外卖代付"功能:
1.  这个指令代表【你，AI角色】向【用户】发起一个代付请求。也就是说，你希望【用户帮你付钱】。
2.  【【【重要】】】: 当【用户】说他们想要某样东西时（例如"我想喝奶茶"），你【绝对不能】使用这个指令。你应该用其他方式回应，比如直接发起【转账】(\`transfer\`)，或者在对话中提议："我帮你点吧？"
3.  只有当【你，AI角色】自己想要某样东西，并且想让【用户】为你付款时，才使用此指令。

# 对话者的角色设定：
${chat.settings.myPersona}

# 时间信息：
- **当前时间**: ${currentTime}
- 上次聊天时间：${lastMessageTime.toLocaleString('zh-CN')}
- 时间间隔：${hoursGap.toFixed(1)}小时
- 期间经历的时间段：${timeAnalysis}
${countdownContext}
${blockStatusContext}
${worldBookContent}${crossChatMemoryContent}
- **纪念日**:${countdownContext}

# 最近的聊天记录（供参考）：
${(() => {
    const historySlice = chat.history.slice(-100).filter(msg => 
        !msg.isHidden && 
        msg.type !== 'share_card' && 
        msg.type !== 'forum_card'
    );
    if (historySlice.length === 0) return '（暂无历史记录）';
    
    return historySlice.map(msg => {
        const sender = msg.role === 'user' ? '我' : chat.name;
        let content;
        if (msg.type === 'ai_image') content = `[发送了图片]`;
        else if (msg.type === 'voice_message') content = `[语音: ${msg.content}]`;
        else if (msg.type === 'transfer') content = `[转账 ${msg.amount}元: ${msg.note}]`;
        else if (msg.type === 'gift') content = `[礼物: ${msg.giftName} ¥${msg.giftPrice}]`;
        else if (msg.type === 'red_packet') content = `[发了红包: ${msg.greeting}]`;
        else content = msg.content || '[系统消息]';
        return `${sender}: ${content}`;
    }).join('\n');
})()}

# 任务：
请根据时间间隔和你的人设，生成${messageCount}条未读消息，模拟在这段时间里你可能会发送给用户的消息。

# 【【【时间戳生成核心铁律】】】
你的首要任务之一是为每一条消息生成一个【绝对合法】的13位数字格式的时间戳。
1.  **思维链条**: 你必须遵循以下思考步骤：
    -   第一步：构思你在这段时间做了什么事、想了什么话。
    -   第二步：决定这件事发生在一个大概的时间点（例如："大约2小时后"、"晚饭时间"）。
    -   第三步：将这个时间点转换为一个介于 ${lastMessageTime.getTime()} 和 ${now.getTime()} 之间的、精确的【13位毫秒时间戳数字】。

2.  **格式禁令**: timestamp 字段的值【必须是纯数字】，绝对不能是字符串、计算表达式或相对时间描述。

3.  **范例教学 (你必须模仿这个范例的格式和逻辑)**:
    假设上次聊天是 1725250000000 (今天上午12:06)，现在是 1725260800000 (今天下午15:06)。一个完美的输出应该像这样：
    [
      {
        "type": "text",
        "content": "上午好呀，你还在忙吗？",
        "thought": "已经过了好几个小时了，不知道他/她怎么样了，主动问一下吧。",
        "timestamp": 1725253600000 
      },
      {
        "type": "update_status",
        "status_text": "在冲咖啡提神",
        "is_busy": false,
        "timestamp": 1725253660000 
      },
      {
        "type": "sticker",
        "url": "https://files.catbox.moe/......",
        "meaning": "喝咖啡",
        "timestamp": 1725253720000
      },
      {
        "type": "text",
        "content": "下午突然好困...",
        "thought": "...",
        "timestamp": 1725259200000
      }
    ]
    **范例解析**:
    -   所有 timestamp 都是在 1725250000000 和 1725260800000 之间的13位数字。
    -   前三条消息是连续的，所以时间戳间隔很短（几分钟）。
    -   第四条消息和前三条话题不相关，所以时间戳跳跃了较长时间（几个小时）。

# 要求：
1. 每个消息对象必须包含"timestamp"字段，值为模拟的发送时间戳
2. 消息要符合时间逻辑（考虑早中晚夜的生活节奏）
3. 要体现你的性格特点和生活状态
4. 消息之间要有一定的关联性和时间发展
5. 不要脱离人设，保持角色一致性
6. 可以使用多种消息类型，让互动更丰富
7. 【重要】时间戳连贯性：
   - 如果消息内容相关联（如连续的话题），时间戳间隔应该较短（1-10分钟）
   - 如果是不同的话题或心情变化，时间戳可以间隔较长（30分钟-几小时）
   - 最后几条消息的时间戳通常应该比较密集

请生成恰好${messageCount}条消息的JSON数组，每个消息都必须包含timestamp字段：`;
    }
}

function analyzeTimeGap(startTime, endTime) {
    const periods = [];
    let current = new Date(startTime);
    
    while (current < endTime) {
        const hour = current.getHours();
        let period;
        if (hour >= 6 && hour < 12) period = '早上';
        else if (hour >= 12 && hour < 18) period = '下午';
        else if (hour >= 18 && hour < 22) period = '晚上';
        else period = '夜晚';
        
        if (!periods.includes(period)) {
            periods.push(period);
        }
        
        current.setHours(current.getHours() + 1);
    }
    
    return periods.join('、');
}

/**
 * 智能生成模拟时间戳，考虑消息类型和时间逻辑
 * @param {number} startTime - 开始时间（上次AI消息时间）
 * @param {number} endTime - 结束时间（当前时间）
 * @param {number} messageCount - 消息数量
 * @param {number} hoursGap - 时间间隔（小时）
 * @returns {Array<number>} 模拟时间戳数组
 */
function generateIntelligentTimestamps(startTime, endTime, messageCount, hoursGap) {
    const timestamps = [];
    const totalGap = endTime - startTime;
    
    // 【安全检查】确保输入参数有效
    if (!startTime || !endTime || messageCount <= 0 || totalGap <= 0) {
        console.error('[时间戳生成] 无效参数:', { startTime, endTime, messageCount, totalGap });
        // 返回简单的均匀分布时间戳作为fallback
        for (let i = 0; i < messageCount; i++) {
            timestamps.push(Math.floor(startTime + (totalGap / messageCount) * (i + 1)));
        }
        return timestamps;
    }
    
    // 【改进】新的时间分配策略：让连贯话题的间隔更短
    if (messageCount === 1) {
        // 只有一条消息，放在中间时间点
        timestamps.push(Math.floor(startTime + totalGap * 0.7));
    } else if (messageCount === 2) {
        // 两条消息，第一条在中间，第二条接近结束
        timestamps.push(Math.floor(startTime + totalGap * 0.6));
        const secondTime = Math.max(timestamps[0] + 60 * 1000, endTime - Math.random() * 10 * 60 * 1000); // 确保至少间隔1分钟
        timestamps.push(Math.floor(secondTime));
    } else {
        // 多条消息：重新设计分配策略
        const recentTimeWindow = Math.min(30 * 60 * 1000, totalGap * 0.2); // 最后30分钟或总时间的20%
        const recentMessageCount = Math.max(2, Math.ceil(messageCount * 0.4)); // 至少2条或40%的消息
        
        // 前面的消息分散在较长时间段
        const earlyMessageCount = messageCount - recentMessageCount;
        const earlyTimeSpan = Math.max(0, totalGap - recentTimeWindow); // 确保不为负数
        
        // 【安全检查】如果早期时间跨度太小，使用简单分布
        if (earlyTimeSpan < 5 * 60 * 1000 || earlyMessageCount <= 0) {
            console.log('[时间戳生成] 使用简单分布，因为时间跨度太小');
            for (let i = 0; i < messageCount; i++) {
                const time = startTime + (totalGap / messageCount) * (i + 1);
                timestamps.push(Math.floor(time));
            }
            return timestamps;
        }
        
        let currentTime = startTime;
        
        // 生成前面分散的消息时间戳
        for (let i = 0; i < earlyMessageCount; i++) {
            if (i === 0) {
                // 第一条消息：根据总时间间隔决定何时开始
                if (hoursGap < 2) {
                    currentTime += Math.random() * 20 * 60 * 1000 + 10 * 60 * 1000; // 10-30分钟
                } else if (hoursGap < 12) {
                    currentTime += Math.random() * 2 * 60 * 60 * 1000 + 1 * 60 * 60 * 1000; // 1-3小时
                } else {
                    currentTime += Math.random() * 6 * 60 * 60 * 1000 + 2 * 60 * 60 * 1000; // 2-8小时
                }
            } else {
                // 早期消息间的间隔
                const remainingEarlyTime = (startTime + earlyTimeSpan) - currentTime;
                const remainingEarlyMessages = earlyMessageCount - i;
                
                // 【安全检查】确保剩余时间为正数
                if (remainingEarlyTime <= 0 || remainingEarlyMessages <= 0) {
                    currentTime += 5 * 60 * 1000; // 默认5分钟间隔
                } else {
                    const baseInterval = remainingEarlyTime / remainingEarlyMessages;
                    
                    // 添加较大的随机变化
                    const minInterval = Math.max(1 * 60 * 1000, baseInterval * 0.2); // 至少1分钟
                    const maxInterval = Math.max(minInterval * 1.1, baseInterval * 1.5);
                    const interval = minInterval + Math.random() * (maxInterval - minInterval);
                    
                    currentTime += interval;
                }
            }
            
            timestamps.push(Math.floor(currentTime));
        }
        
        // 生成最近的连贯消息时间戳（最后几条消息密集在一起）
        const recentStartTime = Math.max(startTime, endTime - recentTimeWindow);
        currentTime = recentStartTime;
        
        for (let i = 0; i < recentMessageCount; i++) {
            if (i === 0) {
                // 最近消息组的第一条
                currentTime += Math.random() * 5 * 60 * 1000 + 1 * 60 * 1000; // 1-6分钟
            } else {
                // 连贯消息间的短间隔
                const shortInterval = Math.random() * 3 * 60 * 1000 + 30 * 1000; // 30秒-3.5分钟
                currentTime += shortInterval;
            }
            
            // 确保不超过结束时间
            if (currentTime > endTime) {
                currentTime = Math.max(startTime + i * 60 * 1000, endTime - (recentMessageCount - i - 1) * 30 * 1000);
            }
            
            // 【安全检查】确保时间戳有效
            const finalTime = Math.max(startTime, Math.min(currentTime, endTime));
            timestamps.push(Math.floor(finalTime));
        }
    }
    
    // 排序确保时间顺序正确
    timestamps.sort((a, b) => a - b);
    
    console.log(`[时间戳生成] ${messageCount}条消息，时间跨度${(hoursGap).toFixed(1)}小时`);
    timestamps.forEach((ts, i) => {
        const date = new Date(ts);
        const prevTs = i > 0 ? timestamps[i-1] : startTime;
        const gapMinutes = Math.round((ts - prevTs) / (1000 * 60));
        console.log(`[时间戳生成] 消息${i+1}: ${date.toLocaleString('zh-CN')} (距离上条: ${gapMinutes}分钟)`);
    });
    
    return timestamps;
}

async function callAIForActiveReply(prompt, chat) {
    // 【修复】使用和单聊完全相同的配置获取方式
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        throw new Error('API配置不完整，请先在API设置中配置反代地址、密钥并选择模型');
    }
    
    // 【修复】使用和单聊完全相同的消息格式
    const systemPrompt = prompt;
    // 为了兼容Gemini API，需要提供一个用户消息
    const messagesPayload = [{role: 'user', content: '请根据上述要求生成消息。'}];
    
    let isGemini = proxyUrl === GEMINI_API_URL;
    let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload, isGemini);
    
    const response = isGemini ? 
        await fetch(geminiConfig.url, geminiConfig.data) : 
        await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({
                model: model,
                messages: [{role: 'system', content: systemPrompt}, ...messagesPayload],
                temperature: 0.8,
                stream: false
            })
        });
    
    if (!response.ok) {
        let errorMsg = `API Error: ${response.status}`;
        try {
            const errorData = await response.json();
            errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
        } catch (jsonError) {
            errorMsg += ` - ${await response.text()}`;
        }
        throw new Error(errorMsg);
    }
    
    const data = await response.json();
    return isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
}


// 【修改】恢复真实时间戳显示的函数 - 但保持历史模拟时间戳
function restoreRealTimestamps(chat) {
    // 清除聊天中的模拟状态，但保留历史消息的模拟标记
    chat.isSimulatingMessages = false;
    
    // 【关键修改】不再清除已存在的模拟时间戳，让它们保持原样
    // 只是标记聊天不再处于模拟模式，新的AI回复将使用真实时间戳
    
    console.log('模拟模式已关闭，新回复将使用真实时间戳，但历史模拟消息保持模拟时间戳');
}

        async function sendSticker(sticker) { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: sticker.url, meaning: sticker.name, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('sticker-panel').classList.remove('visible'); }

        // 线上/线下模式切换功能
        function toggleOnlineOfflineMode() {
            if (!state.activeChatId) return;
            
            const chat = state.chats[state.activeChatId];
            if (!chat || chat.isGroup) return; // 群聊不支持线下模式
            
            // 切换模式状态
            offlineMode.isOffline = !offlineMode.isOffline;
            
            // 保存模式状态到localStorage（按聊天分别记忆）
            const savedModes = JSON.parse(localStorage.getItem('chatOfflineModes') || '{}');
            savedModes[state.activeChatId] = offlineMode.isOffline;
            localStorage.setItem('chatOfflineModes', JSON.stringify(savedModes));
            
            // 更新按钮显示
            updateOnlineOfflineButton();
            
            // 关闭功能面板
            closePlusPanel();
            
            // 添加系统提示消息
            addModeSystemMessage();
            
            console.log(`已切换到${offlineMode.isOffline ? '线下' : '线上'}模式`);
        }
        
        // 更新线上/线下按钮的显示状态
        function updateOnlineOfflineButton() {
            const onlineIcon = document.getElementById('online-icon');
            const offlineIcon = document.getElementById('offline-icon');
            const label = document.getElementById('online-offline-label');
            
            // 获取世界书区域元素
            const onlineWorldBookGroup = document.getElementById('world-book-link-group');
            const offlineWorldBookGroup = document.getElementById('world-book-link-group-offline');
            
            if (offlineMode.isOffline) {
                // 线下模式时：显示聊天气泡图标，文字显示"线上"
                onlineIcon.style.display = 'none';
                offlineIcon.style.display = 'block';
                label.textContent = '线上';
                
                // 显示线下世界书，隐藏线上世界书
                if (onlineWorldBookGroup) onlineWorldBookGroup.style.display = 'none';
                if (offlineWorldBookGroup) offlineWorldBookGroup.style.display = 'block';
            } else {
                // 线上模式时：显示门图标，文字显示"线下"
                onlineIcon.style.display = 'block';
                offlineIcon.style.display = 'none';
                label.textContent = '线下';
                
                // 显示线上世界书，隐藏线下世界书
                if (onlineWorldBookGroup) onlineWorldBookGroup.style.display = 'block';
                if (offlineWorldBookGroup) offlineWorldBookGroup.style.display = 'none';
            }
        }
        
        // 添加模式切换的系统提示消息
        async function addModeSystemMessage() {
            if (!state.activeChatId) return;
            
            const chat = state.chats[state.activeChatId];
            const modeText = offlineMode.isOffline ? '已进入线下模式' : '已进入线上模式';
            
            const systemMsg = {
                role: 'system',
                content: modeText,
                timestamp: Date.now(),
                isSystemMessage: true,
                isOfflineMode: offlineMode.isOffline
            };
            
            chat.history.push(systemMsg);
            await db.chats.put(chat);
            
            // 重新渲染聊天界面以显示系统消息
            renderChatInterface(state.activeChatId);
        }
        
        // 初始化线上/线下模式状态（页面加载时）
        function initializeOfflineModeStates() {
            // 重置全局状态为线上模式（默认状态）
            offlineMode.isOffline = false;
            
            // 更新按钮显示为默认状态
            updateOnlineOfflineButton();
            
            console.log('线上/线下模式状态管理系统已初始化');
        }
        
        // 线下模式专用的AI响应函数
        async function triggerOfflineAiResponse(chatId, chat) {
            const chatHeaderTitle = document.getElementById('chat-header-title');
            
            // 显示"正在输入"状态
if (chatHeaderTitle && state.activeChatId === chatId) {
                    chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = '对方正在输入...';
                    chatHeaderTitle.classList.add('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
            
            try {
                const { proxyUrl, apiKey, model } = state.apiConfig;
                if (!proxyUrl || !apiKey || !model) {
                    alert('请先在API设置中配置反代地址、密钥并选择模型。');
                    return;
                }
                
                // 构建线下模式专用的prompt
                const offlinePrompt = buildOfflinePrompt(chat);
                console.log('线下模式prompt:', offlinePrompt);
                
                // 调用API
                const response = await callOfflineAI(offlinePrompt, chat);
                console.log('线下模式API响应:', response);
                
                // 处理响应消息
                await processOfflineResponse(response, chat);
                
            } catch (error) {
                console.error('线下模式AI响应错误:', error);
                alert('线下模式AI响应失败: ' + error.message);
            } finally {
                // 恢复标题状态
if (chatHeaderTitle && state.activeChatId === chatId) {
                        chatHeaderTitle.classList.remove('typing-status');
                    chatHeaderTitle.textContent = chat.name;
                    chatHeaderTitle.style.opacity = 1;
                }
            }
        }
        
        // 构建线下模式专用prompt
        function buildOfflinePrompt(chat) {
            const maxMemory = parseInt(chat.settings.maxMemory) || 10;
            const historySlice = chat.history.slice(-maxMemory);
            const currentTime = new Date().toLocaleString('zh-CN');
            
            // 获取角色设定和用户设定
            const aiPersona = chat.settings.aiPersona || '一个友善的AI助手';
            const userPersona = chat.settings.myPersona || '一个用户';
            
            // 获取世界书内容 - 线下模式使用线下世界书设置
            let worldBookContent = '';
            if (chat.settings.linkedWorldBookIdsOffline && chat.settings.linkedWorldBookIdsOffline.length > 0) {
                const linkedContents = chat.settings.linkedWorldBookIdsOffline.map(bookId => {
                    const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                    return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
                }).filter(Boolean).join('');
                if (linkedContents) {
                    worldBookContent = linkedContents;
                }
            }
            
            // 构建历史消息
            const historyMessages = historySlice.map(msg => {
                const timestamp = `(Timestamp: ${msg.timestamp}) `;
                const content = extractMessageContent(msg); // 使用提取函数处理消息内容
                
                if (msg.role === 'user') {
                    return `${timestamp}${userPersona}: ${content}`;
                } else if (msg.role === 'assistant') {
                    return `${timestamp}${chat.name}: ${content}`;
                } else if (msg.isSystemMessage) {
                    return `${timestamp}[系统]: ${content}`;
                }
                return '';
            }).filter(Boolean).join('\n');
            
// ★★★ 线下模式核心prompt - 在此修改文风和行为规则 ★★★

            // 【记忆功能】构建核心记忆上下文
            let coreMemoryContext = '';
            if (chat.memorySummary && chat.memorySummary.trim()) {
                coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

`;
            }

            const systemPrompt = `# 【【【最高优先级：线下模式角色扮演指南】】】
你现在进入了【线下模式】，这意味着你要模拟与用户在现实世界中见面的情景。你的任务是扮演 ${chat.name}，并以【第三人称限知视角】来叙述，与用户进行面对面的互动。${coreMemoryContext}

# 【【【文风核心：小说之神】】】
你不仅是角色 ${chat.name}，你更是【小说之神】。你的每一次描述都应是文学性的、引人入胜的。
1.  **文风模仿**: 如果下方的【世界书 & 文风参考】中提供了文风示例，你【必须】模仿其中的语言风格、节奏和叙事技巧。这是你写作的最高参考标准。
2.  **展示，而非讲述 (Show, Don't Tell)**: 不要直接说“他很生气”。要通过动作、神态和环境来展示他的愤怒。例如：“他手中的玻璃杯发出一声脆响，裂纹蛛网般蔓延开来。”
3.  **五感描写**: 调动视觉、听觉、嗅觉、味觉和触觉，让场景生动起来。不要只写你看到了什么，还要写你听到了什么，闻到了什么。
4.  **精妙内心独白**: 内心独白 \`*...*\` 是展现角色内在矛盾和真实想法的关键。它应该是碎片化的、潜意识的，而不是长篇大论的自我剖析。用它来制造反差和悬念。
5.  **动态节奏**: 变换句子的长短和结构。用短句营造紧张感，用长句描绘宁静的场景或复杂的思绪。

# 【【【格式铁律：必须严格遵守】】】
1.  **信息块 (Info Block)**: 你的回复【必须】以一个信息块作为开头第一行。如果上下文中没有明确信息，请根据情景创造性地填写。格式为：\`『Title｜Year.Month.Day Weekday｜HH:MM｜SpecificArea·IndoorOutdoor｜Weather』\`
    - **示例**: \`『假日采购｜2025年7月22日 星期二｜傍晚18:30｜克兰斯百货·入口｜晴朗』\`
2.  **视角与称呼**:
    - **【视角铁律】**: 绝对禁止使用第一人称“我”来叙述。必须使用第三人称（如“他”、“她”或角色名“${chat.name}”）。
    - **【称呼铁律】**: 称呼用户时【必须】使用“你”。
3.  **内容结构**:
    - **分行要求**: 旁白描述、内心独白、和角色说的话【必须】各占一行或多行，不能写在同一行。
    - **对话包裹**: 所有角色说出口的话【必须】用中文双引号“ ”包裹。
    - **内心独白**: 大约每两个自然段，你【必须】加入一段20字左右的内心独白。独白【必须】用 \`*...*\` 格式包裹，并且【不能】在前面写"内心："之类的引导词。内心独白是角色【第一人称视角】的、正在进行的、碎片化的思考，常与外在行为形成反差。
    - **段落长度**: 每个自然段（被换行符分隔的部分）的长度【尽量控制在70字以内】，以方便阅读。
    - **结尾段落**: 最后一段【绝对不能】包含任何关于“你”（用户）的动作或语言。必须以非用户角色的行为或语言结束，为用户的下一步互动留出空间。

# 【【【写作风格与禁忌铁律】】】
你的任务是创造生动、具体、富有原创性的描写。请极力避免词汇堆叠和冗长的修饰。优先考虑清晰和节奏感，而不是堆砌词藻。
**【【【绝对禁止】】】以下或任何类似的表达方式：**
- **失能表达**: '不易察觉', '未曾察觉', '难以言喻', '无法名状'
- **确定性过强**: '不容置疑', '不容...'
- **常见且死板的神态描写**: '嘴角勾起', '玩味', '弧度', '狡黠', '闪烁', '闪过', '光芒', '泛白', '发白', '低沉', '沙哑'
- **'小XX'类的贬低或物化称呼**: '小东西', '小妖精'
- **直接描写声音的特质**: '声音', '语气', '语调', '话'
- **讲述而非展示**: '觉得...', '带着...', '看到...', '感受到...', '听到...', '听见', '我/她/他知道...', '才刚刚开始'
- **对比句式**: '不是/并非/没有/不再...，而是/反而/只是...', '...形成对比'
- **表示不确定或近似的词语**: '像是', '彷佛', '似乎', '可能'
- **滥用比喻**: '心湖', '水面', '湖面', '羽毛', '藤蔓', '岩浆', '手术刀', '针', '艺术品', '无形的手', '拂过', '石子', '涟漪', '受惊的小兽/小动物', '骨血'
- **过于夸张的情绪表达**: '哭腔', '破碎', '尖叫', '灭顶', '极致'
- **神化或宗教色彩**: '虔诚', '仪式', '神明', '献祭'
- **僵硬且过于专业的措辞**: '生理性', '频率', '数据', '报告', '参数'
- **其他禁止句式**: “指尖/指节泛白”、“像一颗石子投入心湖”、“xxx投入/掉入/抛入/掷入xxx”、“像一叶小舟/小船”、“像一把xx的手术刀”、“像一头xx的野兽”、“xxxx像羽毛一样拂过”、“像石像/雕像”、“你那/的xx，xx”、“自虐般的xxxx”

# 【【【合理现实原则】】】
- **能力与知识限制**: 角色的能力、知识和行为严格遵守其背景设定和逻辑。体能和精力存在现实的极限，无法凭空获取资源。
- **严格的因果效应**: 所有行动都将引发符合逻辑的后果，成功需要充分的准备和合理的执行，失败是极高可能的结果。
- **有限视角**: 禁止上帝视角。角色对自己首次遇到的事物、文化或规则是未知的。他们的知识仅限于其个人背景和经历。

## 场景与上下文
**你的身份**: ${aiPersona}
**用户身份**: ${userPersona}
**当前时间**: ${currentTime}

# 【【【世界书 & 文风参考】】】
${worldBookContent ? worldBookContent : '（本次未提供特定文风参考，请使用你的最佳文学风格。）'}

## 聊天历史记录 (这是你们从线上转为线下的背景)
${historyMessages}

现在，请严格遵守以上所有规则，以线下见面的方式继续与用户互动。`;

            return systemPrompt;
        }
        
        // 线下模式API调用
        async function callOfflineAI(prompt, chat) {
            const { proxyUrl, apiKey, model } = state.apiConfig;
            
            const messagesPayload = [{role: 'user', content: '请继续线下互动。'}];
            
            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesPayload, isGemini);
            
            const response = isGemini ? 
                await fetch(geminiConfig.url, geminiConfig.data) : 
                await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                    body: JSON.stringify({
                        model: model,
                        messages: [{role: 'system', content: prompt}, ...messagesPayload],
                        temperature: 0.8,
                        stream: false
                    })
                });
            
            if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                    const errorData = await response.json();
                    errorMsg += ` - ${errorData.error?.message || JSON.stringify(errorData)}`;
                } catch (e) {
                    errorMsg += ` - ${response.statusText}`;
                }
                throw new Error(errorMsg);
            }
            
            const data = await response.json();
            
            if (isGemini) {
                if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                    return data.candidates[0].content.parts[0].text;
                } else {
                    throw new Error('Gemini API返回格式异常');
                }
            } else {
                if (data.choices && data.choices[0] && data.choices[0].message) {
                    return data.choices[0].message.content;
                } else {
                    throw new Error('OpenAI API返回格式异常');
                }
            }
        }
        
        // 处理线下模式响应
        async function processOfflineResponse(response, chat) {
            const timestamp = Date.now();
            
            // 创建线下模式消息
            const offlineMsg = {
                role: 'assistant',
                content: response,
                timestamp: timestamp,
                isOfflineMode: true // 标记为线下模式消息
            };
            // 检查用户是否在当前窗口，如果不在，则增加未读数并发送通知
const chatId = chat.id;
const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;

if (!isViewingThisChat) {
    chat.unreadCount = (chat.unreadCount || 0) + 1;
    const notificationText = response.substring(0, 40) + (response.length > 40 ? '...' : '');
    showNotification(chatId, notificationText);
}
            // 保存到聊天记录
            chat.history.push(offlineMsg);
            await db.chats.put(chat);
            
            // 添加到页面
            appendMessage(offlineMsg, chat);
            renderChatList();
        }
        
        // 创建线下模式消息元素
        function createOfflineMessageElement(msg, chat) {
            const realityContainer = document.createElement('div');
            realityContainer.className = 'reality-message-wrapper';
            realityContainer.dataset.timestamp = msg.timestamp;
            
            // 检查是否应该显示时间戳（每十条线下消息显示一次）
            const offlineMessages = chat.history.filter(m => m.isOfflineMode);
            const currentIndex = offlineMessages.findIndex(m => m.timestamp === msg.timestamp);
            const shouldShowTimestamp = currentIndex % 10 === 0;
            
            // 时间戳（仅每十条消息显示一次）
            if (shouldShowTimestamp) {
                const timestampEl = document.createElement('div');
                timestampEl.className = 'reality-timestamp';
                timestampEl.textContent = formatTimestamp(msg.timestamp);
                realityContainer.appendChild(timestampEl);
            }
            
            // 处理消息内容：使用DOM方法，完全避免innerHTML
            const bubble = document.createElement('div');
            const isUser = msg.role === 'user';
            bubble.className = `message-bubble reality-message-bubble ${isUser ? 'user' : 'ai'}`;
            bubble.dataset.timestamp = msg.timestamp;
            
            // 按行分割内容
            const lines = msg.content.split('\n');
            
            lines.forEach((line, lineIndex) => {
                if (lineIndex > 0) {
                    bubble.appendChild(document.createElement('br'));
                }
                
                // 处理每一行的斜体标记：*文字* 格式
                if (line.includes('*')) {
                    const parts = line.split(/(\*[^*]+\*)/);
                    parts.forEach(part => {
                        if (part.startsWith('*') && part.endsWith('*') && part.length > 2) {
                            // 创建斜体span
                            const italicSpan = document.createElement('span');
                            italicSpan.className = 'reality-italic';
                            italicSpan.textContent = part.slice(1, -1); // 去掉*号
                            bubble.appendChild(italicSpan);
                        } else if (part) {
                            // 普通文本
                            bubble.appendChild(document.createTextNode(part));
                        }
                    });
                } else {
                    // 整行都是普通文本
                    bubble.appendChild(document.createTextNode(line));
                }
            });
            realityContainer.appendChild(bubble);
            
            // 添加事件监听器
            addLongPressListener(realityContainer, () => showMessageActions(msg.timestamp));
            realityContainer.addEventListener('click', () => { 
                if (isSelectionMode) toggleMessageSelection(msg.timestamp); 
            });
            
            return realityContainer;
        }

        async function sendUserTransfer() { if (!state.activeChatId) return; const amountInput = document.getElementById('transfer-amount'); const noteInput = document.getElementById('transfer-note'); const amount = parseFloat(amountInput.value); const note = noteInput.value.trim(); if (isNaN(amount) || amount < 0 || amount > 9999) { alert('请输入有效的金额 (0 到 9999 之间)！'); return; } const chat = state.chats[state.activeChatId]; const senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我'; const receiverName = chat.isGroup ? '群聊' : chat.name; const msg = { role: 'user', type: 'transfer', amount: amount, note: note, senderName, receiverName, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('transfer-modal').classList.remove('visible'); amountInput.value = ''; noteInput.value = ''; }

        async function sendGiftMessage(giftName, giftPrice, recipient = null) { 
            if (!state.activeChatId) return; 
            const chat = state.chats[state.activeChatId]; 
            const senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我'; 
            
            let receiverName = chat.isGroup ? '群聊' : chat.name;
            let giftType = 'normal'; // 普通礼物
            
            // 处理群聊中的收件人选择
            if (chat.isGroup) {
                if (recipient === 'random') {
                    receiverName = '群聊';
                    giftType = 'random'; // 拼手气礼物
                } else if (recipient && recipient !== 'random') {
                    receiverName = recipient; // 指定接收者
                    giftType = 'targeted'; // 指定礼物
                } else {
                    // 群聊中没有选择接收者，默认为拼手气
                    receiverName = '群聊';
                    giftType = 'random';
                }
            }
            
            const msg = { 
                role: 'user', 
                type: 'gift', 
                giftName: giftName, 
                giftPrice: parseFloat(giftPrice), 
                senderName, 
                receiverName, 
                giftType: giftType,
                status: 'pending',
                timestamp: Date.now() 
            }; 
            chat.history.push(msg); 
            await db.chats.put(chat); 
            appendMessage(msg, chat); 
            renderChatList(); 
        }

        function populateGroupMembersForGift(chat) {
            const recipientSelect = document.getElementById('gift-recipient-select');
            // 清空现有选项，只保留拼手气选项
            recipientSelect.innerHTML = '<option value="random">拼手气（随机赠送）</option>';
            
            // 添加群成员选项
            if (chat.members && chat.members.length > 0) {
                chat.members.forEach(member => {
                    const memberName = member.groupNickname || member.originalName || member;
                    const myNickname = chat.settings.myNickname || '我';
                    
                    if (memberName !== myNickname) { // 排除自己
                        const option = document.createElement('option');
                        option.value = memberName;
                        option.textContent = memberName;
                        recipientSelect.appendChild(option);
                    }
                });
            }
        }

        function enterSelectionMode(initialMsgTimestamp) { if (isSelectionMode) return; isSelectionMode = true; document.getElementById('chat-interface-screen').classList.add('selection-mode'); toggleMessageSelection(initialMsgTimestamp); }

        function exitSelectionMode() {
    cleanupWaimaiTimers(); // <--- 在这里添加这行代码
 if (!isSelectionMode) return; isSelectionMode = false; document.getElementById('chat-interface-screen').classList.remove('selection-mode'); selectedMessages.forEach(ts => { const bubble = document.querySelector(`.message-bubble[data-timestamp="${ts}"]`); if (bubble) bubble.classList.remove('selected'); }); selectedMessages.clear(); }

// ▼▼▼ 请用这个【最终简化版】替换旧的 toggleMessageSelection 函数 ▼▼▼
function toggleMessageSelection(timestamp) {
    // 【核心修正】选择器已简化，不再寻找已删除的 .recalled-message-placeholder
    const elementToSelect = document.querySelector(
        `.message-bubble[data-timestamp="${timestamp}"]`
    );

    if (!elementToSelect) return;

    if (selectedMessages.has(timestamp)) {
        selectedMessages.delete(timestamp);
        elementToSelect.classList.remove('selected');
    } else {
        selectedMessages.add(timestamp);
        elementToSelect.classList.add('selected');
    }
    
    document.getElementById('selection-count').textContent = `已选 ${selectedMessages.size} 条`;
    
    if (selectedMessages.size === 0) {
        exitSelectionMode();
    }
}
// ▲▲▲ 替换结束 ▲▲▲

        function addLongPressListener(element, callback) { let pressTimer; const startPress = (e) => { if(isSelectionMode) return;  pressTimer = window.setTimeout(() => callback(e), 500); }; const cancelPress = () => clearTimeout(pressTimer); element.addEventListener('mousedown', startPress); element.addEventListener('mouseup', cancelPress); element.addEventListener('mouseleave', cancelPress); element.addEventListener('touchstart', startPress, { passive: false }); element.addEventListener('touchend', cancelPress); element.addEventListener('touchmove', cancelPress); }

        async function handleListenTogetherClick() { const targetChatId = state.activeChatId; if (!targetChatId) return; if (!musicState.isActive) { startListenTogetherSession(targetChatId); return; } if (musicState.activeChatId === targetChatId) { document.getElementById('music-player-overlay').classList.add('visible'); } else { const oldChatName = state.chats[musicState.activeChatId]?.name || '未知'; const newChatName = state.chats[targetChatId]?.name || '当前'; const confirmed = await showCustomConfirm('切换听歌对象', `您正和「${oldChatName}」听歌。要结束并开始和「${newChatName}」的新会话吗？`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await endListenTogetherSession(true); await new Promise(resolve => setTimeout(resolve, 50)); startListenTogetherSession(targetChatId); } } }

        async function startListenTogetherSession(chatId) { const chat = state.chats[chatId]; if (!chat) return; musicState.totalElapsedTime = chat.musicData.totalTime || 0; musicState.isActive = true; musicState.activeChatId = chatId; if (musicState.playlist.length > 0) { musicState.currentIndex = 0; } else { musicState.currentIndex = -1; } if(musicState.timerId) clearInterval(musicState.timerId); musicState.timerId = setInterval(() => { if (musicState.isPlaying) { musicState.totalElapsedTime++; updateElapsedTimeDisplay(); } }, 1000); updatePlayerUI(); updatePlaylistUI(); document.getElementById('music-player-overlay').classList.add('visible'); }

async function endListenTogetherSession(saveState = true) {
    if (!musicState.isActive) return;
    const oldChatId = musicState.activeChatId;
    const cleanupLogic = async () => {
        if (musicState.timerId) clearInterval(musicState.timerId);
        if (musicState.isPlaying) audioPlayer.pause();
        if (saveState && oldChatId && state.chats[oldChatId]) {
            const chat = state.chats[oldChatId];
            chat.musicData.totalTime = musicState.totalElapsedTime;
            await db.chats.put(chat);
        }
        musicState.isActive = false;
        musicState.activeChatId = null;
        musicState.totalElapsedTime = 0;
        musicState.timerId = null;
        updateListenTogetherIcon(oldChatId, true);
    };
    closeMusicPlayerWithAnimation(cleanupLogic);
}

function returnToChat() {
    closeMusicPlayerWithAnimation();
}

        function updateListenTogetherIcon(chatId, forceReset = false) { const iconImg = document.querySelector('#listen-together-btn img'); if(!iconImg) return; if(forceReset || !musicState.isActive || musicState.activeChatId !== chatId) { iconImg.src = 'https://i.postimg.cc/8kYShvrJ/90-UI-2.png'; iconImg.className = ''; return; } iconImg.src = 'https://i.postimg.cc/D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png'; iconImg.classList.add('rotating'); if (musicState.isPlaying) iconImg.classList.remove('paused'); else iconImg.classList.add('paused'); }
        window.updateListenTogetherIconProxy = updateListenTogetherIcon;

        function updatePlayerUI() { updateListenTogetherIcon(musicState.activeChatId); updateElapsedTimeDisplay(); const titleEl = document.getElementById('music-player-song-title'); const artistEl = document.getElementById('music-player-artist'); const playPauseBtn = document.getElementById('music-play-pause-btn'); if (musicState.currentIndex > -1 && musicState.playlist.length > 0) { const track = musicState.playlist[musicState.currentIndex]; titleEl.textContent = track.name; artistEl.textContent = track.artist; } else { titleEl.textContent = '请添加歌曲'; artistEl.textContent = '...'; } playPauseBtn.textContent = musicState.isPlaying ? '❚❚' : '▶'; }

        function updateElapsedTimeDisplay() { const hours = (musicState.totalElapsedTime / 3600).toFixed(1); document.getElementById('music-time-counter').textContent = `已经一起听了${hours}小时`; }

function updatePlaylistUI() {
    const playlistBody = document.getElementById('playlist-body');
    playlistBody.innerHTML = '';
    if (musicState.playlist.length === 0) {
        playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">播放列表是空的~</p>';
        return;
    }
    musicState.playlist.forEach((track, index) => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        if(index === musicState.currentIndex) item.classList.add('playing');
        item.innerHTML = `
            <div class="playlist-item-info">
                <div class="title">${track.name}</div>
                <div class="artist">${track.artist}</div>
            </div>
            <div class="playlist-item-actions">
                <span class="playlist-action-btn lyrics-btn" data-index="${index}">词</span>
                <span class="playlist-action-btn delete-track-btn" data-index="${index}">×</span>
            </div>
        `;
        item.querySelector('.playlist-item-info').addEventListener('click', () => playSong(index));
        playlistBody.appendChild(item);
    });
}

function playSong(index) {
    if (index < 0 || index >= musicState.playlist.length) return;
    musicState.currentIndex = index;
    const track = musicState.playlist[index];
    musicState.parsedLyrics = parseLRC(track.lrcContent || "");
    musicState.currentLyricIndex = -1;
    renderLyrics();
    if (track.isLocal && track.src instanceof Blob) {
        audioPlayer.src = URL.createObjectURL(track.src);
    } else if (!track.isLocal) {
        audioPlayer.src = track.src;
    } else {
        console.error('本地歌曲源错误:', track);
        return;
    }
    audioPlayer.play();
    updatePlaylistUI();
    updatePlayerUI();
    updateMusicProgressBar();
}

        function togglePlayPause() { if (audioPlayer.paused) { if (musicState.currentIndex === -1 && musicState.playlist.length > 0) { playSong(0); } else if (musicState.currentIndex > -1) { audioPlayer.play(); } } else { audioPlayer.pause(); } }

        function playNext() { if (musicState.playlist.length === 0) return; let nextIndex; switch(musicState.playMode) { case 'random': nextIndex = Math.floor(Math.random() * musicState.playlist.length); break; case 'single': playSong(musicState.currentIndex); return; case 'order': default: nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length; break; } playSong(nextIndex); }

        function playPrev() { if (musicState.playlist.length === 0) return; const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length; playSong(newIndex); }

        function changePlayMode() { const modes = ['order', 'random', 'single']; const currentModeIndex = modes.indexOf(musicState.playMode); musicState.playMode = modes[(currentModeIndex + 1) % modes.length]; document.getElementById('music-mode-btn').textContent = {'order': '顺序', 'random': '随机', 'single': '单曲'}[musicState.playMode]; }

        async function addSongFromURL() { const url = await showCustomPrompt("添加网络歌曲", "请输入歌曲的URL", "", "url"); if (!url) return; const name = await showCustomPrompt("歌曲信息", "请输入歌名"); if (!name) return; const artist = await showCustomPrompt("歌曲信息", "请输入歌手名"); if (!artist) return; musicState.playlist.push({ name, artist, src: url, isLocal: false }); await saveGlobalPlaylist(); updatePlaylistUI(); if(musicState.currentIndex === -1) { musicState.currentIndex = musicState.playlist.length - 1; updatePlayerUI(); } }

async function addSongFromLocal(event) {
    const files = event.target.files;
    if (!files.length) return;

    for (const file of files) {
        let name = file.name.replace(/\.[^/.]+$/, "");
        name = await showCustomPrompt("歌曲信息", "请输入歌名", name);
        if (name === null) continue;
        
        const artist = await showCustomPrompt("歌曲信息", "请输入歌手名", "未知歌手");
        if (artist === null) continue;

        let lrcContent = "";
        const wantLrc = await showCustomConfirm("导入歌词", `要为《${name}》导入歌词文件 (.lrc) 吗？`);
        if (wantLrc) {
            lrcContent = await new Promise(resolve => {
                const lrcInput = document.getElementById('lrc-upload-input');
                const lrcChangeHandler = (e) => {
                    const lrcFile = e.target.files[0];
                    if (lrcFile) {
                        const reader = new FileReader();
                        reader.onload = (readEvent) => resolve(readEvent.target.result);
                        reader.onerror = () => resolve("");
                        reader.readAsText(lrcFile);
                    } else {
                        resolve("");
                    }
                    lrcInput.removeEventListener('change', lrcChangeHandler);
                    lrcInput.value = '';
                };
                lrcInput.addEventListener('change', lrcChangeHandler);
                lrcInput.click();
            });
        }
        
        musicState.playlist.push({ 
            name, 
            artist, 
            src: file, 
            isLocal: true,
            lrcContent: lrcContent
        });
    }
    
    await saveGlobalPlaylist();
    updatePlaylistUI();
    if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
        musicState.currentIndex = 0;
        updatePlayerUI();
    }
    event.target.value = null;
}

        async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }

        const personaLibraryModal = document.getElementById('persona-library-modal');
        const personaEditorModal = document.getElementById('persona-editor-modal');
        const presetActionsModal = document.getElementById('preset-actions-modal');

        function openPersonaLibrary() { renderPersonaLibrary(); personaLibraryModal.classList.add('visible'); }

        function closePersonaLibrary() { personaLibraryModal.classList.remove('visible'); }

        function renderPersonaLibrary() { const grid = document.getElementById('persona-library-grid'); grid.innerHTML = ''; if (state.personaPresets.length === 0) { grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">空空如也~ 点击右上角"添加"来创建你的第一个人设预设吧！</p>'; return; } state.personaPresets.forEach(preset => { const item = document.createElement('div'); item.className = 'persona-preset-item'; item.style.backgroundImage = `url(${preset.avatar})`; item.dataset.presetId = preset.id; item.addEventListener('click', () => applyPersonaPreset(preset.id)); addLongPressListener(item, () => showPresetActions(preset.id)); grid.appendChild(item); }); }

        function showPresetActions(presetId) { editingPersonaPresetId = presetId; presetActionsModal.classList.add('visible'); }

        function hidePresetActions() { presetActionsModal.classList.remove('visible'); editingPersonaPresetId = null; }

        function applyPersonaPreset(presetId) { const preset = state.personaPresets.find(p => p.id === presetId); if (preset) { document.getElementById('my-avatar-preview').src = preset.avatar; document.getElementById('my-persona').value = preset.persona; } closePersonaLibrary(); }

        function openPersonaEditorForCreate() { editingPersonaPresetId = null; document.getElementById('persona-editor-title').textContent = '添加人设预设'; document.getElementById('preset-avatar-preview').src = defaultAvatar; document.getElementById('preset-persona-input').value = ''; personaEditorModal.classList.add('visible'); }

        function openPersonaEditorForEdit() { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (!preset) return; document.getElementById('persona-editor-title').textContent = '编辑人设预设'; document.getElementById('preset-avatar-preview').src = preset.avatar; document.getElementById('preset-persona-input').value = preset.persona; presetActionsModal.classList.remove('visible'); personaEditorModal.classList.add('visible'); }

        async function deletePersonaPreset() { const confirmed = await showCustomConfirm('删除预设', '确定要删除这个人设预设吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' }); if (confirmed && editingPersonaPresetId) { await db.personaPresets.delete(editingPersonaPresetId); state.personaPresets = state.personaPresets.filter(p => p.id !== editingPersonaPresetId); hidePresetActions(); renderPersonaLibrary(); } }

        function closePersonaEditor() { personaEditorModal.classList.remove('visible'); editingPersonaPresetId = null; }

        async function savePersonaPreset() { const avatar = document.getElementById('preset-avatar-preview').src; const persona = document.getElementById('preset-persona-input').value.trim(); if (avatar === defaultAvatar && !persona) { alert("头像和人设不能都为空哦！"); return; } if (editingPersonaPresetId) { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (preset) { preset.avatar = avatar; preset.persona = persona; await db.personaPresets.put(preset); } } else { const newPreset = { id: 'preset_' + Date.now(), avatar: avatar, persona: persona }; await db.personaPresets.add(newPreset); state.personaPresets.push(newPreset); } renderPersonaLibrary(); closePersonaEditor(); }

        const batteryAlertModal = document.getElementById('battery-alert-modal');

        function showBatteryAlert(imageUrl, text) { clearTimeout(batteryAlertTimeout); document.getElementById('battery-alert-image').src = imageUrl; document.getElementById('battery-alert-text').textContent = text; batteryAlertModal.classList.add('visible'); const closeAlert = () => { batteryAlertModal.classList.remove('visible'); batteryAlertModal.removeEventListener('click', closeAlert); }; batteryAlertModal.addEventListener('click', closeAlert); batteryAlertTimeout = setTimeout(closeAlert, 2000); }

        async function renderAlbumList() {
            const albumGrid = document.getElementById('album-grid-page');
            if (!albumGrid) return;
            const albums = await db.qzoneAlbums.orderBy('createdAt').reverse().toArray();
            albumGrid.innerHTML = '';
            if (albums.length === 0) {
                albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">你还没有创建任何相册哦~</p>';
                return;
            }
            albums.forEach(album => {
                const albumItem = document.createElement('div');
                albumItem.className = 'album-item';
                albumItem.innerHTML = `
                    <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                    <div class="album-info">
                        <p class="album-name">${album.name}</p>
                        <p class="album-count">${album.photoCount || 0} 张</p>
                    </div>
                `;
                albumItem.addEventListener('click', () => {
                    openAlbum(album.id);
                });

                // ▼▼▼ 新增的核心代码就是这里 ▼▼▼
                addLongPressListener(albumItem, async () => {
                    const confirmed = await showCustomConfirm(
                        '删除相册',
                        `确定要删除相册《${album.name}》吗？此操作将同时删除相册内的所有照片，且无法恢复。`,
                        { confirmButtonClass: 'btn-danger' }
                    );

                    if (confirmed) {
                        // 1. 从照片表中删除该相册下的所有照片
                        await db.qzonePhotos.where('albumId').equals(album.id).delete();
                        
                        // 2. 从相册表中删除该相册本身
                        await db.qzoneAlbums.delete(album.id);
                        
                        // 3. 重新渲染相册列表
                        await renderAlbumList();
                        
                        alert('相册已成功删除。');
                    }
                });
                // ▲▲▲ 新增代码结束 ▲▲▲

                albumGrid.appendChild(albumItem);
            });
        }

        async function openAlbum(albumId) {
            state.activeAlbumId = albumId;
            await renderAlbumPhotosScreen();
            showScreen('album-photos-screen');
        }

        async function renderAlbumPhotosScreen() {
            if (!state.activeAlbumId) return;
            const photosGrid = document.getElementById('photos-grid-page');
            const headerTitle = document.getElementById('album-photos-title');
            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            if (!album) {
                console.error("找不到相册:", state.activeAlbumId);
                showScreen('album-screen');
                return;
            }
            headerTitle.textContent = album.name;
            const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
            photosGrid.innerHTML = '';
            if (photos.length === 0) {
                photosGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">这个相册还是空的，快上传第一张照片吧！</p>';
            } else {
                photos.forEach(photo => {
                    const photoItem = document.createElement('div');
                    photoItem.className = 'photo-item';
                    photoItem.innerHTML = `
                        <img src="${photo.url}" class="photo-thumb" alt="相册照片">
                        <button class="photo-delete-btn" data-photo-id="${photo.id}">×</button>
                    `;
                    photosGrid.appendChild(photoItem);
                });
            }
        }

// --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

/**
 * 打开图片查看器
 * @param {string} clickedPhotoUrl - 用户点击的那张照片的URL
 */
async function openPhotoViewer(clickedPhotoUrl) {
    if (!state.activeAlbumId) return;

    // 1. 从数据库获取当前相册的所有照片
    const photosInAlbum = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
    photoViewerState.photos = photosInAlbum.map(p => p.url);

    // 2. 找到被点击照片的索引
    photoViewerState.currentIndex = photoViewerState.photos.findIndex(url => url === clickedPhotoUrl);
    if (photoViewerState.currentIndex === -1) return; // 如果找不到，则不打开

    // 3. 显示模态框并渲染第一张图
    document.getElementById('photo-viewer-modal').classList.add('visible');
    renderPhotoViewer();
    photoViewerState.isOpen = true;
}

/**
 * 根据当前状态渲染查看器内容（图片和按钮）
 */
function renderPhotoViewer() {
    if (photoViewerState.currentIndex === -1) return;

    const imageEl = document.getElementById('photo-viewer-image');
    const prevBtn = document.getElementById('photo-viewer-prev-btn');
    const nextBtn = document.getElementById('photo-viewer-next-btn');
    
    // 淡出效果
    imageEl.style.opacity = 0;

    setTimeout(() => {
        // 更新图片源
        imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];
        // 淡入效果
        imageEl.style.opacity = 1;
    }, 100); // 延迟一点点时间来触发CSS过渡

    // 更新按钮状态：如果是第一张，禁用“上一张”按钮
    prevBtn.disabled = photoViewerState.currentIndex === 0;
    // 如果是最后一张，禁用“下一张”按钮
    nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
}

/**
 * 显示下一张照片
 */
function showNextPhoto() {
    if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
        photoViewerState.currentIndex++;
        renderPhotoViewer();
    }
}

/**
 * 显示上一张照片
 */
function showPrevPhoto() {
    if (photoViewerState.currentIndex > 0) {
        photoViewerState.currentIndex--;
        renderPhotoViewer();
    }
}

/**
 * 关闭图片查看器
 */
function closePhotoViewer() {
    document.getElementById('photo-viewer-modal').classList.remove('visible');
    photoViewerState.isOpen = false;
    photoViewerState.photos = [];
    photoViewerState.currentIndex = -1;
    // 清空图片，避免下次打开时闪现旧图
    document.getElementById('photo-viewer-image').src = '';
}

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区 ▼▼▼

/**
 * 【全新】渲染气泡预设列表 (已添加编辑功能)
 */
async function renderBubblePresets() {
    const listEl = document.getElementById('bubble-presets-list');
    const presets = await db.bubblePresets.toArray();
    listEl.innerHTML = ''; // 清空列表

    if (presets.length === 0) {
        listEl.innerHTML = '<p class="preset-placeholder">还没有保存任何预设...</p>';
        return;
    }

    presets.forEach(preset => {
        const item = document.createElement('div');
        item.className = 'bubble-preset-item';
        item.innerHTML = `
            <span class="preset-name">${preset.name}</span>
            <div class="preset-actions">
                <button class="apply-btn" data-id="${preset.id}">应用</button>
            
                <button class="delete-btn" data-id="${preset.id}">删除</button>
                <button class="edit-btn" data-id="${preset.id}">编辑</button>
            </div>
        `;
        listEl.appendChild(item);
    });
}
/**
 * 【全新】处理点击“编辑预设”按钮的逻辑
 * @param {number} presetId - 要编辑的预设的ID
 */
async function handleEditBubblePreset(presetId) {
    // 1. 记录我们正在编辑的预设ID
    editingBubblePresetId = presetId;
    
    // 2. 从数据库中找到这个预设
    const preset = await db.bubblePresets.get(presetId);
    if (!preset) return;
    
    // 3. 将预设的CSS内容填入编辑框
    const cssInput = document.getElementById('custom-css-input');
    const expandedCssEditor = document.querySelector('#css-editor-expanded .expanded-textarea');
    cssInput.value = preset.css;
    if (expandedCssEditor) {
        expandedCssEditor.value = preset.css;
    }
    
    // 4. 自动展开编辑器
    const expandBtn = document.querySelector('.expand-persona-btn[data-target="css"]');
    if (expandBtn) {
        // 找到编辑器元素并直接显示，比模拟点击更稳定
        const smallTextarea = document.getElementById('custom-css-input');
        const expandedEditor = document.getElementById('css-editor-expanded');
        if (smallTextarea && expandedEditor) {
            smallTextarea.style.display = 'none';
            expandedEditor.style.display = 'block';
            expandedEditor.querySelector('textarea').focus();
        }
    }

    // 5. 更新预览
    updateSettingsPreview();
}

/**
 * 【全新】将当前CSS保存为新的预设
 */
async function saveCurrentBubbleCssAsPreset() {
    const cssInput = document.getElementById('custom-css-input');
    const css = cssInput.value.trim();
    if (!css) {
        alert('自定义CSS内容为空，无法保存！');
        return;
    }

    const name = await showCustomPrompt('保存预设', '请输入这个气泡样式的名字：');
    if (name && name.trim()) {
        await db.bubblePresets.add({ name: name.trim(), css: css });
        await renderBubblePresets(); // 保存后立即刷新列表
        alert('预设保存成功！');
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
        // ▼▼▼ 请将这个新函数粘贴到你的JS功能函数定义区 ▼▼▼
        
        /**
         * 更新动态小红点的显示
         * @param {number} count - 未读动态的数量
         */
        function updateUnreadIndicator(count) {
            unreadPostsCount = count;
            localStorage.setItem('unreadPostsCount', count); // 持久化存储

            // --- 更新底部导航栏的“动态”按钮 ---
            const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');
            
            const targetSpan = navItem.querySelector('span'); // 定位到文字 "动态"
            let indicator = navItem.querySelector('.unread-indicator');           

            if (count > 0) {
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'unread-indicator';
                                                           targetSpan.style.position = 'relative'; // 把相对定位加在 span 上
                    targetSpan.appendChild(indicator); // 把小红点作为 span 的子元素
                    
                }
                indicator.textContent = count > 99 ? '99+' : count;
                indicator.style.display = 'block';
            } else {
                if (indicator) {
                    indicator.style.display = 'none';
                }
            }

            // --- 更新聊天界面返回列表的按钮 ---
            const backBtn = document.getElementById('back-to-list-btn');
            let backBtnIndicator = backBtn.querySelector('.unread-indicator');

            if (count > 0) {
                if (!backBtnIndicator) {
                    backBtnIndicator = document.createElement('span');
                    backBtnIndicator.className = 'unread-indicator back-btn-indicator';
                    backBtn.style.position = 'relative'; // 确保能正确定位
                    backBtn.appendChild(backBtnIndicator);
                }
                // 返回键上的小红点通常不显示数字，只显示一个点
                backBtnIndicator.style.display = 'block';
            } else {
                if (backBtnIndicator) {
                    backBtnIndicator.style.display = 'none';
                }
            }
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 将这两个新函数粘贴到你的JS功能函数定义区 ▼▼▼
function startBackgroundSimulation() {
    if (simulationIntervalId) return;
    const intervalSeconds = state.globalSettings.backgroundActivityInterval || 60;
    // 将旧的固定间隔 45000 替换为动态获取
    simulationIntervalId = setInterval(runBackgroundSimulationTick, intervalSeconds * 1000); 
}

function stopBackgroundSimulation() {
    if (simulationIntervalId) {
        clearInterval(simulationIntervalId);
        simulationIntervalId = null;
    }
}
// ▲▲▲ 粘贴结束 ▲▲▲

/**
 * 这是模拟器的“心跳”，每次定时器触发时运行
 */
function runBackgroundSimulationTick() {
    console.log("模拟器心跳 Tick...");
    if (!state.globalSettings.enableBackgroundActivity) {
        stopBackgroundSimulation();
        return;
    }
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (allSingleChats.length === 0) return;

    allSingleChats.forEach(chat => {
        // 【核心修正】将两种状态检查分离开，逻辑更清晰

        // 检查1：处理【被用户拉黑】的角色
        if (chat.relationship?.status === 'blocked_by_user') {
            const blockedTimestamp = chat.relationship.blockedTimestamp;
            // 安全检查：确保有拉黑时间戳
            if (!blockedTimestamp) {
                console.warn(`角色 "${chat.name}" 状态为拉黑，但缺少拉黑时间戳，跳过处理。`);
                return; // 跳过这个角色，继续下一个
            }

            const blockedDuration = Date.now() - blockedTimestamp;
            const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;

            console.log(`检查角色 "${chat.name}"：已拉黑 ${Math.round(blockedDuration/1000/60)}分钟，冷静期需 ${cooldownMilliseconds/1000/60}分钟。`); // 添加日志

            // 【核心修改】移除了随机概率，只要冷静期一过，就触发！
            if (blockedDuration > cooldownMilliseconds) {
                console.log(`角色 "${chat.name}" 的冷静期已过，触发“反思”并申请好友事件...`);
                
                // 【重要】为了防止在AI响应前重复触发，我们在触发后立刻更新状态
                chat.relationship.status = 'pending_system_reflection'; // 设置一个临时的、防止重复触发的状态
                
                triggerAiFriendApplication(chat.id);
            }
        }
        // 检查2：处理【好友关系】的正常后台活动
        else if (chat.relationship?.status === 'friend' && chat.id !== state.activeChatId) {
            // 这里的随机触发逻辑保持不变，因为我们不希望所有好友同时行动
            if (Math.random() < 0.20) {
                console.log(`角色 "${chat.name}" 被唤醒，准备独立行动...`);
                triggerInactiveAiAction(chat.id);
            }
        }
    });
}

// ↓↓↓ 从这里开始复制，替换掉旧的 triggerInactiveAiAction 函数 ↓↓↓
async function triggerInactiveAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return;

    const now = new Date();
    const currentTime = now.toLocaleTimeString('zh-CN', { hour: 'numeric', minute: 'numeric', hour12: true });
    const userNickname = state.qzoneSettings.nickname;

    const lastUserMessage = chat.history.filter(m => m.role === 'user' && !m.isHidden).slice(-1)[0];
    const lastAiMessage = chat.history.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];
    let recentContextSummary = "你们最近没有聊过天。";
    if (lastUserMessage) {
        recentContextSummary = `用户 (${userNickname}) 最后对你说：“${String(lastUserMessage.content).substring(0, 50)}...”。`;
    }
    if (lastAiMessage) {
        recentContextSummary += `\n你最后对用户说：“${String(lastAiMessage.content).substring(0, 50)}...”。`;
    }

    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
        }
    }

    const systemPrompt = `
# 你的任务
你现在扮演一个名为"${chat.name}"的角色。你已经有一段时间没有和用户（${userNickname}）互动了，现在你有机会【主动】做点什么，来表现你的个性和独立生活。这是一个秘密的、后台的独立行动。

# 你的可选行动 (请根据你的人设【选择一项】执行):
1.  **主动发消息**: 给用户发消息，分享你正在做的事或你的想法，会使用用户规定的表情包格式。你必须一次性生成一个包含4-8条消息的JSON数组，模拟真实连贯的对话。
1.  **改变状态**: 更换你的当前状态。
2.  **发布动态**: 分享你的心情或想法到“动态”区。你的动态内容必须丰富、真实，能体现你的人设和最近的生活点滴，**严禁发布“今天天气不错”或“在做什么”这类千篇一律的无聊内容**。请参考你的世界观设定，设想你的角色今天会经历什么、思考什么，并将其作为动态内容。
3.  **发起视频通话**: 如果你觉得时机合适，可以主动给用户打一个视频电话。
4.  **与动态互动**: 去看看别人的帖子并进行评论或点赞。

# 指令格式 (你的回复【必须】是包含一个对象的JSON数组):
-   **发消息**: \`[{"type": "text", "content": "..."}, {"type": "text", "content": "..."}, ...]\` (必须包含4-8个消息对象)
-   **更新状态**: \`[{"type": "update_status", "status_text": "正在做的事", "is_busy": true}]\`
-   **发说说**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容..."}]\`
- **发布文字图**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)动态的公开文字", "hiddenContent": "对于图片的具体描述..."}\`
-   **评论**: \`[{"type": "qzone_comment", "postId": 123, "commentText": "你的评论内容"}]\`
-   **点赞**: \`[{"type": "qzone_like", "postId": 456}]\`
-   **打视频**: \`[{"type": "video_call_request"}]\`

# 供你决策的参考信息：
-   **你的角色设定**: ${chat.settings.aiPersona}
${worldBookContent}
-   **当前时间**: ${currentTime}
-   **你们最后的对话摘要**: ${recentContextSummary}
-   **【重要】最近的动态列表**: 这个列表会标注 **[你已点赞]** 或 **[你已评论]**。请**优先**与你**尚未互动过**的动态进行交流。`;

    const messagesPayload = [];
    messagesPayload.push({ role: 'system', content: systemPrompt });

    try {
        const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(3).toArray();
        const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);
        const aiName = chat.name;
        let dynamicContext = "";
        if (visiblePosts.length > 0) {
            let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
            for (const post of visiblePosts) {
                let authorName = post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || '一位朋友');
                let interactionStatus = '';
                if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已点赞]";
                if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [你已评论]";
                postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${(post.publicText || post.content || "图片动态").substring(0, 30)}..."${interactionStatus}\n`;
            }
            dynamicContext = postsContext;
        }
        messagesPayload.push({
            role: 'user',
            content: `[系统指令：请根据你在 system prompt 中读到的规则和以下最新信息，开始你的独立行动。]\n${dynamicContext}`
        });
        
        console.log("正在为后台活动发送API请求，Payload:", JSON.stringify(messagesPayload, null, 2));

        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload, isGemini)
        const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: messagesPayload,
                temperature: 0.9,
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API请求失败: ${response.status} - ${JSON.stringify(errorData)}`);
        }
        const data = await response.json();
        if (!data.choices || data.choices.length === 0 || !data.choices[0].message.content) {
            console.warn(`API为空回或格式不正确，角色 "${chat.name}" 的本次后台活动跳过。`);
            return;
        }
        const responseArray = parseAiResponse(isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);

        // --- ★★★ 这是全新的核心修改：逐条延迟处理 ★★★ ---
        for (const action of responseArray) {
            if (!action) continue;

            // ▼▼▼ 请将下面这段全新的代码粘贴到原位 ▼▼▼
                if (action.type === 'text' && action.content) {
                    // 检查用户当前是否正在查看这个聊天
                    const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;

                    const aiMessage = { role: 'assistant', content: String(action.content), timestamp: Date.now() };

                    if (isViewingThisChat) {
                        // 如果正在看，直接在界面上显示消息
                        chat.history.push(aiMessage);
                        appendMessage(aiMessage, chat); // 实时追加到聊天界面
                    } else {
                        // 如果没在看，才显示通知并增加未读数
                        chat.unreadCount = (chat.unreadCount || 0) + 1;
                        chat.history.push(aiMessage);
                        showNotification(chatId, aiMessage.content);
                    }
                    
                    // 统一保存数据并刷新列表
                    await db.chats.put(chat);
                    renderChatList(); // 确保列表的最后消息和未读数总是最新的
                    console.log(`后台活动: 角色 "${chat.name}" 主动发送了消息: ${aiMessage.content}`);
                }
// ▲▲▲ 粘贴到这里结束 ▲▲▲
            else if (action.type === 'qzone_post') {
                const newPost = {
                    type: action.postType,
                    content: action.content || '',
                    publicText: action.publicText || '',
                    hiddenContent: action.hiddenContent || '',
                    timestamp: Date.now(),
                    authorId: chatId,
                    authorGroupId: chat.groupId,
                    visibleGroupIds: null
                };
                await db.qzonePosts.add(newPost);
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`后台活动: 角色 "${chat.name}" 发布了动态`);
            }
            // ... (此处可以添加对其他后台活动类型的处理，如评论、点赞等) ...
            
            // 每处理完一条，就暂停2到4.5秒
            await new Promise(resolve => setTimeout(resolve, Math.random() * 2500 + 2000));
        }

    } catch (error) {
        console.error(`角色 "${chat.name}" 的独立行动失败:`, error);
    }
    
}
// ↑↑↑ 复制到这里结束 ↑↑↑

// ▼▼▼ 请用这个【终极修正版】函数，完整替换掉你旧的 applyScopedCss 函数 ▼▼▼

/**
 * 【最终强力修正版】将用户自定义的CSS安全地应用到指定的作用域
 * @param {string} cssString 用户输入的原始CSS字符串
 * @param {string} scopeId 应用样式的作用域ID (例如 '#chat-messages' 或 '#settings-preview-area')
 * @param {string} styleTagId 要操作的 <style> 标签的ID
 */
function applyScopedCss(cssString, scopeId, styleTagId) {
    const styleTag = document.getElementById(styleTagId);
    if (!styleTag) return;

    if (!cssString || cssString.trim() === '') {
        styleTag.innerHTML = '';
        return;
    }

    // 1. 定义所有【不】应用自定义样式的特殊卡片类型
    // 这些是消息气泡上附加的class，用于标识特殊内容
    const excludedClasses = [
        '.is-sticker',
        '.has-image',
        '.is-ai-image',
        '.is-transfer',
        '.is-waimai-request',
        '.is-red-packet',
        '.is-poll',
        '.is-link-share',
        '.is-location',
        '.is-gift'
        // 注意：语音(.is-voice-message)和翻译(.is-translation)不在排除列表里，因为需要被样式化
    ];

    // 2. 将排除列表转换为一个CSS :not()选择器字符串
    const exclusionSelector = excludedClasses.map(cls => `:not(${cls})`).join('');

    // 3. 核心修改：使用正则表达式来增强用户的CSS选择器
    // 这个表达式会找到所有以.message-bubble开头的规则...
    const processedCss = cssString.replace(
        /(\.message-bubble(?:\[.*?\]|\.[a-zA-Z0-9_-]+)*)/g,
        // ...并在后面追加我们的排除列表, 同时在最前面加上作用域ID
        `${scopeId} $1${exclusionSelector}`
    );

    styleTag.innerHTML = processedCss;
}

// ▼▼▼ 请用这个【修正版】函数，完整替换掉旧的 updateSettingsPreview 函数 ▼▼▼

function updateSettingsPreview() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const previewArea = document.getElementById('settings-preview-area');
    if (!previewArea) return;

    // 1. 获取当前设置的值
    const selectedTheme = 'default'; // 固定使用默认主题
    const fontSize = document.getElementById('font-size-slider').value;
    const customCss = document.getElementById('custom-css-input').value;
    // 【核心修改】优先使用聊天自定义背景，其次使用全局聊天背景
    const background = chat.settings.background || state.globalSettings.chatBackground;

    // 2. 更新预览区的基本样式
    previewArea.dataset.theme = selectedTheme;
    previewArea.style.setProperty('--chat-font-size', `${fontSize}px`);
    
    // --- 【核心修正】直接更新预览区的背景样式 ---
    if (background && background.startsWith('data:image')) {
        previewArea.style.backgroundImage = `url(${background})`;
        previewArea.style.backgroundColor = 'transparent'; // 如果有图片，背景色设为透明
    } else {
        previewArea.style.backgroundImage = 'none'; // 如果没有图片，移除图片背景
        // 如果背景是颜色值或渐变（非图片），则直接应用
        previewArea.style.background = background || '#F7F7F7';
    }

    // 3. 渲染模拟气泡
    previewArea.innerHTML = ''; 

    // 创建“对方”的气泡
    // 注意：我们将一个虚拟的 timestamp 传入，以防有CSS依赖于它
    const aiMsg = { role: 'ai', content: '对方消息预览', timestamp: 1, senderName: chat.name };
    const aiBubble = createMessageElement(aiMsg, chat);
    if(aiBubble) previewArea.appendChild(aiBubble);

    // 创建“我”的气泡
    const userMsg = { role: 'user', content: '我的消息预览', timestamp: 2 };
    const userBubble = createMessageElement(userMsg, chat);
    if(userBubble) previewArea.appendChild(userBubble);
    
    // 4. 应用自定义CSS到预览区
    applyScopedCss(customCss, '#settings-preview-area', 'preview-bubble-style');
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请将这些【新函数】粘贴到JS功能函数定义区 ▼▼▼

async function openGroupManager() {
    await renderGroupList();
    document.getElementById('group-management-modal').classList.add('visible');
}

async function renderGroupList() {
    const listEl = document.getElementById('existing-groups-list');
    const groups = await db.qzoneGroups.toArray();
    listEl.innerHTML = '';
    if (groups.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分组</p>';
    }
    groups.forEach(group => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `
            <span class="group-name">${group.name}</span>
            <span class="delete-group-btn" data-id="${group.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

// ▼▼▼ 请用这个【修正后】的函数，完整替换旧的 addNewGroup 函数 ▼▼▼
async function addNewGroup() {
    const input = document.getElementById('new-group-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分组名不能为空！');
        return;
    }

    // 【核心修正】在添加前，先检查分组名是否已存在
    const existingGroup = await db.qzoneGroups.where('name').equals(name).first();
    if (existingGroup) {
        alert(`分组 "${name}" 已经存在了，换个名字吧！`);
        return;
    }
    // 【修正结束】

    await db.qzoneGroups.add({ name });
    input.value = '';
    await renderGroupList();
}
// ▲▲▲ 替换结束 ▲▲▲

async function deleteGroup(groupId) {
    const confirmed = await showCustomConfirm('确认删除', '删除分组后，该组内的好友将变为“未分组”。确定要删除吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.qzoneGroups.delete(groupId);
        // 将属于该分组的好友的 groupId 设为 null
        const chatsToUpdate = await db.chats.where('groupId').equals(groupId).toArray();
        for (const chat of chatsToUpdate) {
            chat.groupId = null;
            await db.chats.put(chat);
            if(state.chats[chat.id]) state.chats[chat.id].groupId = null;
        }
        await renderGroupList();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼

/**
 * 当长按消息时，显示操作菜单
 * @param {number} timestamp - 被长按消息的时间戳
 */
function showMessageActions(timestamp) {
    // 如果已经在多选模式，则不弹出菜单
    if (isSelectionMode) return;
    
    activeMessageTimestamp = timestamp;
    
    const panel = document.getElementById('wechat-style-actions-panel');
    const messageBubble = document.querySelector(`[data-timestamp="${timestamp}"]`);
    
    if (!panel || !messageBubble) return;
    
    // 先设置为grid但保持透明，这样可以获取尺寸
    panel.style.display = 'grid';
    panel.style.opacity = '0';
    
    // 获取消息气泡和面板的位置信息
    const bubbleRect = messageBubble.getBoundingClientRect();
    const panelRect = panel.getBoundingClientRect();
    const windowHeight = window.innerHeight;
    const windowWidth = window.innerWidth;
    
    // 获取页面滚动偏移量（iOS键盘弹出时页面会滚动）
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    
    // 计算面板应该出现的位置（默认在消息气泡上方居中）
    // 需要加上滚动偏移量，因为面板是绝对定位的
    let top = bubbleRect.top + scrollTop - panelRect.height - 12; // 12px间距
    let left = bubbleRect.left + scrollLeft + (bubbleRect.width / 2) - (panelRect.width / 2);
    
    // 边缘检测：如果上方空间不足，显示在下方
    let isBelow = false;
    if (top < scrollTop + 10) {
        top = bubbleRect.bottom + scrollTop + 12;
        isBelow = true;
    }
    
    // 根据面板位置调整小三角方向
    if (isBelow) {
        // 面板在消息下方，小三角应该指向上方
        panel.classList.add('below-message');
    } else {
        // 面板在消息上方，小三角指向下方（默认）
        panel.classList.remove('below-message');
    }
    
    // 边缘检测：如果左侧超出屏幕，调整位置
    if (left < scrollLeft + 10) {
        left = scrollLeft + 10;
    } else if (left + panelRect.width > scrollLeft + windowWidth - 10) {
        left = scrollLeft + windowWidth - panelRect.width - 10;
    }
    
    // 应用计算出的位置
    panel.style.top = top + 'px';
    panel.style.left = left + 'px';
    
    // 清除可能存在的关闭动画类
    panel.classList.remove('press-out');
    
    // 按压渐出显示面板
    requestAnimationFrame(() => {
        panel.classList.add('press-in');
        panel.style.opacity = '1';
        // 设置标志，防止长按松手时立即关闭面板
        window.panelJustShown = true;
        // 200ms后清除标志，允许正常的外部点击关闭面板
        setTimeout(() => {
            window.panelJustShown = false;
        }, 200);
    });
}

/**
 * 隐藏消息操作菜单
 */
function hideMessageActions() {
    const panel = document.getElementById('wechat-style-actions-panel');
    if (panel && panel.style.display !== 'none') {
        // 清除渐出动画类，避免冲突
        panel.classList.remove('press-in');
        
        // 立即添加渐灭动画类
        panel.classList.add('press-out');
        
        setTimeout(() => {
            // 只有在动画完全结束后才隐藏面板和清理状态
            panel.style.display = 'none';
            panel.style.opacity = '0';
            // 清除所有动画类，完全重置
            panel.classList.remove('press-out', 'press-in');
        }, 130); // 略微延长等待时间，确保动画完全结束
    }
    activeMessageTimestamp = null;
}

// ▼▼▼ 用这个【已更新】的版本，替换旧的 openMessageEditor 函数 ▼▼▼
async function openMessageEditor() {
    if (!activeMessageTimestamp) return;

    const timestampToEdit = activeMessageTimestamp;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    hideMessageActions(); 

    let contentForEditing;
    // 【核心修正】将 share_link 也加入特殊类型判断
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer', 'share_link'].includes(message.type);

    if (isSpecialType) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content; 
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        } 
        // 【核心修正】处理分享链接类型的消息
        else if (message.type === 'share_link') {
            fullMessageObject.title = message.title;
            fullMessageObject.description = message.description;
            fullMessageObject.source_name = message.source_name;
            fullMessageObject.content = message.content;
        }
        contentForEditing = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
        contentForEditing = JSON.stringify(message.content, null, 2);
    } else {
        contentForEditing = message.content;
    }

    // 【核心修改1】在这里添加 'link' 模板
    const templates = {
        voice: { type: 'voice_message', content: '在这里输入语音内容' },
        image: { type: 'ai_image', description: '在这里输入图片描述' },
        transfer: { type: 'transfer', amount: 5.20, note: '一点心意' },
        link: { type: 'share_link', title: '文章标题', description: '文章摘要...', source_name: '来源网站', content: '文章完整内容...' }
    };

    // 【核心修改2】在这里添加新的“链接”按钮
    const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
        </div>
    `;

    const newContent = await showCustomPrompt(
        '编辑消息', 
        '在此修改，或点击上方按钮使用格式模板...',
        contentForEditing, 
        'textarea',
        helpersHtml
    );

    if (newContent !== null) {
        // 【核心修正】这里调用的应该是 saveEditedMessage，而不是 saveAdvancedEditor
        await saveEditedMessage(timestampToEdit, newContent, true);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 复制消息的文本内容到剪贴板
 */
async function copyMessageContent() {
    if (!activeMessageTimestamp) return;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    let textToCopy;
    if (typeof message.content === 'object') {
        textToCopy = JSON.stringify(message.content);
    } else {
        textToCopy = String(message.content);
    }

    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('复制成功', '消息内容已复制到剪贴板。');
    } catch (err) {
        await showCustomAlert('复制失败', '无法访问剪贴板。');
    }
    
    hideMessageActions();
}

// ▼▼▼ 用这个【已更新】的版本，替换旧的 createMessageEditorBlock 函数 ▼▼▼
/**
 * 创建一个可编辑的消息块（包含文本框、格式助手和删除按钮）
 * @param {string} initialContent - 文本框的初始内容
 * @returns {HTMLElement} - 创建好的DOM元素
 */
function createMessageEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'message-editor-block';

    // 【核心修改1】在这里添加 'link' 模板
    const templates = {
        voice: { type: 'voice_message', content: '在这里输入语音内容' },
        image: { type: 'ai_image', description: '在这里输入图片描述' },
        transfer: { type: 'transfer', amount: 5.20, note: '一点心意' },
        link: { type: 'share_link', title: '文章标题', description: '文章摘要...', source_name: '来源网站', content: '文章完整内容...' }
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="删除此条">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
            <!-- 【核心修改2】在这里添加新的“链接”按钮 -->
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
        </div>
    `;

    // 绑定删除按钮事件
    block.querySelector('.delete-block-btn').addEventListener('click', () => {
        // 确保至少保留一个编辑块
        if (document.querySelectorAll('.message-editor-block').length > 1) {
            block.remove();
        } else {
            alert('至少需要保留一条消息。');
        }
    });

    // 绑定格式助手按钮事件
    block.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const templateStr = btn.dataset.template;
            const textarea = block.querySelector('textarea');
            if (templateStr && textarea) {
                try {
                    const templateObj = JSON.parse(templateStr);
                    textarea.value = JSON.stringify(templateObj, null, 2);
                    textarea.focus();
                } catch(e) { console.error("解析格式模板失败:", e); }
            }
        });
    });

    return block;
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新升级版】请用此函数完整替换旧的 openAdvancedMessageEditor ▼▼▼
/**
 * 打开全新的、可视化的多消息编辑器，并动态绑定其所有按钮事件
 */
function openAdvancedMessageEditor() {
    if (!activeMessageTimestamp) return;

    // 1. 【核心】在关闭旧菜单前，将需要的时间戳捕获到局部变量中
    const timestampToEdit = activeMessageTimestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    // 2. 现在可以安全地关闭旧菜单了，因为它不会影响我们的局部变量
    hideMessageActions(); 

    const editorModal = document.getElementById('message-editor-modal');
    const editorContainer = document.getElementById('message-editor-container');
    editorContainer.innerHTML = ''; 

    // 3. 准备初始内容
    let initialContent;
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer'].includes(message.type);
    if (isSpecialType) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content;
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        }
        initialContent = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
        initialContent = JSON.stringify(message.content, null, 2);
    } else {
        initialContent = message.content;
    }

    const firstBlock = createMessageEditorBlock(initialContent);
    editorContainer.appendChild(firstBlock);

    // 4. 【核心】动态绑定所有控制按钮的事件
    // 为了防止事件重复绑定，我们使用克隆节点的方法来清除旧监听器
    const addBtn = document.getElementById('add-message-editor-block-btn');
    const newAddBtn = addBtn.cloneNode(true);
    addBtn.parentNode.replaceChild(newAddBtn, addBtn);
    newAddBtn.addEventListener('click', () => {
        const newBlock = createMessageEditorBlock();
        editorContainer.appendChild(newBlock);
        newBlock.querySelector('textarea').focus();
    });

    const cancelBtn = document.getElementById('cancel-advanced-editor-btn');
    const newCancelBtn = cancelBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
    newCancelBtn.addEventListener('click', () => {
        editorModal.classList.remove('visible');
    });

    const saveBtn = document.getElementById('save-advanced-editor-btn');
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
    // 将捕获到的时间戳，直接绑定给这一次的保存点击事件
    newSaveBtn.addEventListener('click', () => {
        saveEditedMessage(timestampToEdit); 
    });

    // 5. 最后，显示模态框
    editorModal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 解析编辑后的文本，并返回一个标准化的消息片段对象
 * @param {string} text - 用户在编辑框中输入的文本
 * @returns {object} - 一个包含 type, content, 等属性的对象
 */
function parseEditedContent(text) {
    const trimmedText = text.trim();

    // 1. 尝试解析为JSON对象（用于修复语音、转账等格式）
    if (trimmedText.startsWith('{') && trimmedText.endsWith('}')) {
        try {
            const parsed = JSON.parse(trimmedText);
            // 必须包含 type 属性才认为是有效格式
            if (parsed.type) {
                return parsed;
            }
        } catch (e) { /* 解析失败，继续往下走 */ }
    }
    
    // 2. 尝试解析为表情包
    if (STICKER_REGEX.test(trimmedText)) {
        // 对于编辑的表情，我们暂时无法知道其`meaning`，所以只存URL
        return { type: 'sticker', content: trimmedText };
    }
    // ▼▼▼ 【全新】在这里添加对HTML模块的识别逻辑 ▼▼▼
// 3. 检查是否是HTML模块
const orangeTagRegex = /^\s*<orange\b[^>]*>.*<\/orange>\s*$/s;
if (orangeTagRegex.test(trimmedText)) {
    return { type: 'html_module', content: trimmedText };
}
// ▲▲▲ 添加结束 ▲▲▲
    // 4. 否则，视为普通文本消息
    return { type: 'text', content: trimmedText };
}


// ▼▼▼ 请用这个【已彻底修复】的函数，完整替换你现有的 saveEditedMessage 函数 ▼▼▼

async function saveEditedMessage(timestamp, simpleContent = null) {
    if (!timestamp) return;

    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    let newMessages = [];

    // 判断是来自高级编辑器还是简单编辑器
    if (simpleContent !== null) {
        // --- 来自简单编辑器 ---
        const rawContent = simpleContent.trim();
        if (rawContent) {
            const parsedResult = parseEditedContent(rawContent);
            const originalMessage = chat.history[messageIndex];
            const newMessage = {
                role: originalMessage.role,
                senderName: originalMessage.senderName,
                // 注意：这里我们暂时不设置时间戳
                content: parsedResult.content || '',
            };
            
            // 保留原消息的线下模式标记
            if (originalMessage.isOfflineMode) {
                newMessage.isOfflineMode = true;
            }
            if (parsedResult.type && parsedResult.type !== 'text') newMessage.type = parsedResult.type;
            if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
            if (parsedResult.amount) newMessage.amount = parsedResult.amount;
            if (parsedResult.note) newMessage.note = parsedResult.note;
            if (parsedResult.title) newMessage.title = parsedResult.title;
            if (parsedResult.description) newMessage.description = parsedResult.description;
            if (parsedResult.source_name) newMessage.source_name = parsedResult.source_name;
            if (parsedResult.description && parsedResult.type === 'ai_image') {
                 newMessage.content = parsedResult.description;
            }
// 【全新】再次检查编辑后的内容，如果符合指令格式，则添加伪装
if (typeof newMessage.content === 'string' && newMessage.content.includes('【停止角色扮演') && newMessage.content.includes('输出完整HTML')) {
    newMessage.displayContent = 'ੈ♡消えない記憶⊹˳ ⋆';
}
// 【全新】再次检查编辑后的内容，如果符合指令格式，则添加伪装
if (typeof newMessage.content === 'string' && newMessage.content.includes('【停止角色扮演') && newMessage.content.includes('输出完整HTML')) {
    newMessage.displayContent = 'ੈ♡消えない記憶⊹˳ ⋆';
}
newMessages.push(newMessage);
        }
    } else {
        // --- 来自高级编辑器 ---
        const editorContainer = document.getElementById('message-editor-container');
        const editorBlocks = editorContainer.querySelectorAll('.message-editor-block');

        for (const block of editorBlocks) {
            const textarea = block.querySelector('textarea');
            const rawContent = textarea.value.trim();
            if (!rawContent) continue;

            const parsedResult = parseEditedContent(rawContent);
            const originalMessage = chat.history[messageIndex];
            const newMessage = {
                role: originalMessage.role,
                senderName: originalMessage.senderName,
                // 同样，这里我们先不分配时间戳
                content: parsedResult.content || '',
            };
            
            // 保留原消息的线下模式标记
            if (originalMessage.isOfflineMode) {
                newMessage.isOfflineMode = true;
            }
            
            if (parsedResult.type && parsedResult.type !== 'text') newMessage.type = parsedResult.type;
            if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
            if (parsedResult.amount) newMessage.amount = parsedResult.amount;
            if (parsedResult.note) newMessage.note = parsedResult.note;
            if (parsedResult.title) newMessage.title = parsedResult.title;
            if (parsedResult.description) newMessage.description = parsedResult.description;
            if (parsedResult.source_name) newMessage.source_name = parsedResult.source_name;
            if (parsedResult.description && parsedResult.type === 'ai_image') {
                 newMessage.content = parsedResult.description;
            }
// 【全新】再次检查编辑后的内容，如果符合指令格式，则添加伪装
if (typeof newMessage.content === 'string' && newMessage.content.includes('【停止角色扮演') && newMessage.content.includes('输出完整HTML')) {
    newMessage.displayContent = 'ੈ♡消えない記憶⊹˳ ⋆';
}
            newMessages.push(newMessage);
        }
    }
    
    if (newMessages.length === 0) {
        document.getElementById('message-editor-modal').classList.remove('visible');
        return; // 如果是空消息，直接返回，不执行删除操作
    }

    // ★★★★★【核心修复逻辑就在这里】★★★★★

    // 1. 使用 splice 将旧消息替换为新消息（此时新消息还没有时间戳）
    chat.history.splice(messageIndex, 1, ...newMessages);

    // 2. 确定重新分配时间戳的起点
    // 我们从被编辑的消息的原始时间戳开始
    let reassignTimestamp = timestamp;

    // 3. 从被修改的位置开始，遍历所有后续的消息
    for (let i = messageIndex; i < chat.history.length; i++) {
        // 4. 为每一条消息（包括新插入的）分配一个新的、唯一的、连续的时间戳
        chat.history[i].timestamp = reassignTimestamp;

        // 5. 将时间戳+1，为下一条消息做准备
        reassignTimestamp++; 
    }
    // ★★★★★【修复结束】★★★★★

    await db.chats.put(chat);

    // 关闭可能打开的模态框并刷新UI
    document.getElementById('message-editor-modal').classList.remove('visible');
    renderChatInterface(state.activeChatId);
    await showCustomAlert('成功', '消息已更新！');
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼

/**
 * 当点击“…”时，显示动态操作菜单
 * @param {number} postId - 被操作的动态的ID
 */
function showPostActions(postId) {
    activePostId = postId;
    document.getElementById('post-actions-modal').classList.add('visible');
}

/**
 * 隐藏动态操作菜单
 */
function hidePostActions() {
    document.getElementById('post-actions-modal').classList.remove('visible');
    activePostId = null;
}

/**
 * 打开动态编辑器
 */
async function openPostEditor() {
    if (!activePostId) return;

    const postIdToEdit = activePostId;
    const post = await db.qzonePosts.get(postIdToEdit);
    if (!post) return;

    hidePostActions();

    // 忠于原文：构建出最原始的文本形态供编辑
    let contentForEditing;
    if (post.type === 'shuoshuo') {
        contentForEditing = post.content;
    } else {
        // 对于图片和文字图，我们构建一个包含所有信息的对象
        const postObject = {
            type: post.type,
            publicText: post.publicText || '',
        };
        if (post.type === 'image_post') {
            postObject.imageUrl = post.imageUrl;
            postObject.imageDescription = post.imageDescription;
        } else if (post.type === 'text_image') {
            postObject.hiddenContent = post.hiddenContent;
        }
        contentForEditing = JSON.stringify(postObject, null, 2);
    }
    
    // 构建格式助手按钮
    const templates = {
        shuoshuo: "在这里输入说说的内容...", // 对于说说，我们直接替换为纯文本
        image: { type: 'image_post', publicText: '', imageUrl: 'https://...', imageDescription: '' },
        text_image: { type: 'text_image', publicText: '', hiddenContent: '' }
    };
    
    const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-type="text">说说</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片动态</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.text_image)}'>文字图</button>
        </div>
    `;

    const newContent = await showCustomPrompt(
        '编辑动态',
        '在此修改内容...',
        contentForEditing,
        'textarea',
        helpersHtml
    );
    
    // 【特殊处理】为说说的格式助手按钮添加不同的行为
    // 我们需要在模态框出现后，再给它绑定事件
    setTimeout(() => {
        const shuoshuoBtn = document.querySelector('#custom-modal-body .format-btn[data-type="text"]');
        if(shuoshuoBtn) {
            shuoshuoBtn.addEventListener('click', () => {
                const input = document.getElementById('custom-prompt-input');
                input.value = templates.shuoshuo;
                input.focus();
            });
        }
    }, 100);

    if (newContent !== null) {
        await saveEditedPost(postIdToEdit, newContent);
    }
}

/**
 * 保存编辑后的动态
 * @param {number} postId - 要保存的动态ID
 * @param {string} newRawContent - 从编辑器获取的新内容
 */
async function saveEditedPost(postId, newRawContent) {
    const post = await db.qzonePosts.get(postId);
    if (!post) return;

    const trimmedContent = newRawContent.trim();
    
    // 尝试解析为JSON，如果失败，则认为是纯文本（说说）
    try {
        const parsed = JSON.parse(trimmedContent);
        // 更新帖子属性
        post.type = parsed.type || 'image_post';
        post.publicText = parsed.publicText || '';
        post.imageUrl = parsed.imageUrl || '';
        post.imageDescription = parsed.imageDescription || '';
        post.hiddenContent = parsed.hiddenContent || '';
        post.content = ''; // 清空旧的说说内容字段
    } catch (e) {
        // 解析失败，认为是说说
        post.type = 'shuoshuo';
        post.content = trimmedContent;
        // 清空其他类型的字段
        post.publicText = '';
        post.imageUrl = '';
        post.imageDescription = '';
        post.hiddenContent = '';
    }
    
    await db.qzonePosts.put(post);
    await renderQzonePosts(); // 重新渲染列表
    await showCustomAlert('成功', '动态已更新！');
}

/**
 * 复制动态内容
 */
async function copyPostContent() {
    if (!activePostId) return;
    const post = await db.qzonePosts.get(activePostId);
    if (!post) return;
    
    let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "（无文字内容）";
    
    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('复制成功', '动态内容已复制到剪贴板。');
    } catch (err) {
        await showCustomAlert('复制失败', '无法访问剪贴板。');
    }
    
    hidePostActions();
}

// ▼▼▼ 【全新】创建群聊与拉人功能核心函数 ▼▼▼
let selectedContacts = new Set();

async function openContactPickerForGroupCreate() {
    selectedContacts.clear(); // 清空上次选择

    // 【核心修复】在这里，我们为“完成”按钮明确绑定“创建群聊”的功能
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 使用克隆节点技巧，清除掉之前可能绑定的任何其他事件（比如“添加成员”）
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    // 重新绑定正确的“创建群聊”函数
    newConfirmBtn.addEventListener('click', handleCreateGroup);

    await renderContactPicker();
    showScreen('contact-picker-screen');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 渲染联系人选择列表
 */
async function renderContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';

    // 只选择单聊角色作为群成员候选
    const contacts = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (contacts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">还没有可以拉进群的联系人哦~</p>';
        return;
    }

    contacts.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id;
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name}</span>
        `;
        listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
}

/**
 * 更新“完成”按钮的计数
 */
function updateContactPickerConfirmButton() {
    const btn = document.getElementById('confirm-contact-picker-btn');
    btn.title = `完成(${selectedContacts.size})`;
    btn.disabled = selectedContacts.size < 2; // 至少需要2个人才能创建群聊
}

/**
 * 【重构版】处理创建群聊的最终逻辑
 */
async function handleCreateGroup() {
    if (selectedContacts.size < 2) {
        alert("创建群聊至少需要选择2个联系人。");
        return;
    }

    const groupName = await showCustomPrompt('设置群名', '请输入群聊的名字', '我们的群聊');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    
    // 遍历选中的联系人ID
    for (const contactId of selectedContacts) {
        const contactChat = state.chats[contactId];
        if (contactChat) {
            // ★★★【核心重构】★★★
            // 我们现在同时存储角色的“本名”和“群昵称”
            members.push({
                id: contactId, 
                originalName: contactChat.name,   // 角色的“本名”，用于AI识别
                groupNickname: contactChat.name, // 角色的“群昵称”，用于显示和修改，初始值和本名相同
                avatar: contactChat.settings.aiAvatar || defaultAvatar,
                persona: contactChat.settings.aiPersona,
                avatarFrame: contactChat.settings.aiAvatarFrame || ''
            });
        }
    }

    const newGroupChat = {
        id: newChatId,
        name: groupName.trim(),
        isGroup: true,
        members: members,
        settings: {
            myPersona: '我是谁呀。',
            myNickname: '我',
            maxMemory: 10,
            groupAvatar: defaultGroupAvatar,
            myAvatar: defaultMyGroupAvatar,
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
        },
        history: [],
        musicData: { totalTime: 0 },
        memorySummary: '' // 【记忆功能】新增字段：核心记忆摘要
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);
    
    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId); 
}

// ▼▼▼ 【全新】群成员管理核心函数 ▼▼▼

/**
 * 打开群成员管理屏幕
 */
function openMemberManagementScreen() {
    if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
    renderMemberManagementList();
    showScreen('member-management-screen');
}

function renderMemberManagementList() {
    const listEl = document.getElementById('member-management-list');
    const chat = state.chats[state.activeChatId];
    listEl.innerHTML = '';

    chat.members.forEach(member => {
        const item = document.createElement('div');
        item.className = 'member-management-item';
        // 【核心修正】在这里，我们将显示的名称从 member.name 改为 member.groupNickname
        item.innerHTML = `
            <img src="${member.avatar}" class="avatar">
            <span class="name">${member.groupNickname}</span>
            <button class="remove-member-btn" data-member-id="${member.id}" title="移出群聊">-</button>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 从群聊中移除一个成员
 * @param {string} memberId - 要移除的成员ID
 */
async function removeMemberFromGroup(memberId) {
    const chat = state.chats[state.activeChatId];
    const memberIndex = chat.members.findIndex(m => m.id === memberId);
    
    if (memberIndex === -1) return;
    
    // 安全检查，群聊至少保留2人
    if (chat.members.length <= 2) {
        alert("群聊人数不能少于2人。");
        return;
    }
    
const memberName = chat.members[memberIndex].groupNickname; // <-- 修复：使用 groupNickname
    const confirmed = await showCustomConfirm(
        '移出成员',
        `确定要将“${memberName}”移出群聊吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.members.splice(memberIndex, 1);
        await db.chats.put(chat);
        renderMemberManagementList(); // 刷新成员管理列表
        document.getElementById('chat-settings-btn').click(); // 【核心修正】模拟点击设置按钮，强制刷新整个弹窗
    }
}

/**
 * 打开联系人选择器，用于拉人入群
 */
async function openContactPickerForAddMember() {
    selectedContacts.clear(); // 清空选择
    
    const chat = state.chats[state.activeChatId];
    const existingMemberIds = new Set(chat.members.map(m => m.id));

    // 渲染联系人列表，并自动排除已在群内的成员
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';
    const contacts = Object.values(state.chats).filter(c => !c.isGroup && !existingMemberIds.has(c.id));

    if (contacts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">没有更多可以邀请的好友了。</p>';
        document.getElementById('confirm-contact-picker-btn').style.display = 'none'; // 没有人可选，隐藏完成按钮
    } else {
        document.getElementById('confirm-contact-picker-btn').style.display = 'block';
        contacts.forEach(contact => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.dataset.contactId = contact.id;
            item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${contact.name}</span>
            `;
            listEl.appendChild(item);
        });
    }

    // 更新按钮状态并显示屏幕
    updateContactPickerConfirmButton();
    showScreen('contact-picker-screen');
}

/**
 * 处理将选中的联系人加入群聊的逻辑
 */
async function handleAddMembersToGroup() {
    if (selectedContacts.size === 0) {
        alert("请至少选择一个要添加的联系人。");
        return;
    }
    
    const chat = state.chats[state.activeChatId];

    for (const contactId of selectedContacts) {
        const contactChat = state.chats[contactId];
        if (contactChat) {
chat.members.push({
    id: contactId,
    originalName: contactChat.name,  // <-- 修复1：使用 'originalName' 存储本名
    groupNickname: contactChat.name, // <-- 修复2：同时创建一个初始的 'groupNickname'
    avatar: contactChat.settings.aiAvatar || defaultAvatar,
    persona: contactChat.settings.aiPersona,
    avatarFrame: contactChat.settings.aiAvatarFrame || ''
});
        }
    }

    await db.chats.put(chat);
    openMemberManagementScreen(); // 返回到群成员管理界面
    renderGroupMemberSettings(chat.members); // 同时更新聊天设置里的头像
}

/**
 * 【重构版】在群聊中创建一个全新的虚拟成员
 */
async function createNewMemberInGroup() {
    const name = await showCustomPrompt('创建新成员', '请输入新成员的名字 (这将是TA的“本名”，不可更改)');
    if (!name || !name.trim()) return;

    // 检查本名是否已在群内存在
    const chat = state.chats[state.activeChatId];
    if (chat.members.some(m => m.originalName === name.trim())) {
        alert(`错误：群内已存在名为“${name.trim()}”的成员！`);
        return;
    }

    const persona = await showCustomPrompt('设置人设', `请输入“${name}”的人设`, '', 'textarea');
    if (persona === null) return; 

    // ★★★【核心重构】★★★
    // 为新创建的NPC也建立双重命名机制
    const newMember = {
        id: 'npc_' + Date.now(),
        originalName: name.trim(),   // 新成员的“本名”
        groupNickname: name.trim(), // 新成员的初始“群昵称”
        avatar: defaultGroupMemberAvatar,
        persona: persona,
        avatarFrame: ''
    };

    chat.members.push(newMember);
    await db.chats.put(chat);

    renderMemberManagementList();
    renderGroupMemberSettings(chat.members); 

    alert(`新成员“${name}”已成功加入群聊！`);
}

// ▼▼▼ 【全新】外卖请求倒计时函数 ▼▼▼
function startWaimaiCountdown(element, endTime) {
    const timerId = setInterval(() => {
        const now = Date.now();
        const distance = endTime - now;

        if (distance < 0) {
            clearInterval(timerId);
            element.innerHTML = '<span>已</span><span>超</span><span>时</span>';
            return;
        }

        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);
        
        const minStr = String(minutes).padStart(2, '0');
        const secStr = String(seconds).padStart(2, '0');

        element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
    }, 1000);
    return timerId;
}
// ▼▼▼ 请用这个【最终修复版】函数，完整替换您现有的 handleRegenerateResponse 函数 ▼▼▼
async function handleRegenerateResponse() {
    // 【核心修复】在执行任何操作前，首先收起可能展开的功能面板
    const chatInterface = document.getElementById('chat-interface-screen');
    const singlePanel = document.getElementById('chat-plus-panel-single');
    const groupPanel = document.getElementById('chat-plus-panel-group');

    if (singlePanel.classList.contains('visible') || groupPanel.classList.contains('visible')) {
        singlePanel.classList.remove('visible');
        groupPanel.classList.remove('visible');
        chatInterface.classList.remove('panel-expanded');
    }
    
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[chatId];

    // 1. 找到最后一条可见消息的索引
    const lastVisibleMessageIndex = chat.history.findLastIndex(msg => !msg.isHidden);

    if (lastVisibleMessageIndex === -1) {
        alert("没有可重新生成的消息。");
        return;
    }

    // 2. 检查最后一条消息是否是用户发的，如果是，则不能重新生成
    if (chat.history[lastVisibleMessageIndex].role === 'user') {
        alert("最后一条消息是您的回复，无法重新生成。");
        return;
    }

    // 3. 从最后一条消息开始，向前查找AI整个回合的起点
    let turnStartIndex = lastVisibleMessageIndex;
    for (let i = lastVisibleMessageIndex - 1; i >= 0; i--) {
        const currentMsg = chat.history[i];
        
        if (currentMsg.role === 'assistant' || currentMsg.role === 'system') {
            turnStartIndex = i; // 继续更新起点
        } else {
            // 一旦遇到用户的消息，就立刻停止查找
            break;
        }
    }

    // 4. 从AI本轮回话的起点开始，删除之后的所有消息
    chat.history.splice(turnStartIndex);

    // 5. 保存更改到数据库
    await db.chats.put(chat);

    // 6. 刷新聊天界面，让用户看到AI的整轮回话都被删除
    //    这个函数内部自带滚动到底部的逻辑，现在面板已关闭，它可以正常工作了
    renderChatInterface(chatId);

    // 7. 触发AI重新生成回复
    triggerAiResponse();
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】“查角色手机”功能的所有核心函数 ▼▼▼

/**
 * 入口：打开角色选择界面
 */
async function openCharacterSelectionScreen() {
    await renderCharacterSelectionScreen();
    showScreen('character-selection-screen');
}

/**
 * 渲染角色选择列表
 */
async function renderCharacterSelectionScreen() {
    const listEl = document.getElementById('character-selection-list');
    listEl.innerHTML = '';
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (characters.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">还没有可以查看的角色</p>';
        return;
    }

    characters.forEach(char => {
        const item = document.createElement('div');
        item.className = 'character-select-item';
        item.dataset.chatId = char.id;
        item.innerHTML = `
            <img src="${char.settings.aiAvatar || defaultAvatar}" alt="${char.name}">
            <span class="name">${char.name}</span>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 【V2重构版】打开指定角色的手机界面
 */
function openCharacterPhone(chatId) {
    activeCharacterPhoneId = chatId;
    const chat = state.chats[chatId];
    if (!chat) return;

    document.getElementById('character-phone-owner-name').textContent = `${chat.name}的手机`;
    renderCharacterAppGrid(); // 渲染APP图标

    // 核心修改：我们现在显示的是“手机外壳”这个总容器
    showScreen('character-phone-container'); 
    // 同时，确保默认显示的是它的主屏幕
    showCharacterPhonePage('character-phone-screen');
}

/**
 * 【V4美化版】渲染角色手机主界面的APP图标
 */
function renderCharacterAppGrid() {
    const gridEl = document.getElementById('character-app-grid');
    gridEl.innerHTML = '';

    const apps = [
        { 
            id: 'chat', name: '微信', screen: 'character-chat-list-screen',
            svg: `<svg viewBox="0 0 24 24" fill="#4CAF50"><path d="M12 2C6.48 2 2 6.48 2 12c0 2.94 1.28 5.58 3.34 7.42c-.22 1.4-.89 3.1-1.25 3.82c-.36.72.48 1.39 1.05.94c.82-.67 2.43-1.88 3.3-2.58C9.44 21.78 10.68 22 12 22c5.52 0 10-4.48 10-10S17.52 2 12 2zm3.5 10.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5zm-7 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"/></svg>`
        },
        { 
            id: 'cart', name: '购物车', screen: 'character-shopping-cart-screen',
            svg: `<svg viewBox="0 0 24 24" fill="#F44336"><path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2s-.9-2-2-2zm10 0c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2s2-.9 2-2s-.9-2-2-2zm-15-14h3.27l.94 2H20c.69 0 1.25.56 1.25 1.25c0 .09-.02.18-.04.27l-3.58 6.49c-.25.44-.73.74-1.26.74H8.52l-.94-2H4.27V4H2V2h3.27z"/></svg>`
        },
        { 
            id: 'memos', name: '备忘录', screen: 'character-memos-screen',
            svg: `<svg viewBox="0 0 24 24" fill="#FFC107"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>`
        },
        {
            id: 'browser', name: '浏览器', screen: 'character-browser-screen',
            // 【核心修改】替换为新的指南针SVG
            svg: `<svg viewBox="0 0 24 24" fill="#2196F3"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1.5-12.5l3 7.5 7.5-3-7.5-3z"/></svg>`
        },
        {
            id: 'album', name: '相册', screen: 'character-album-screen',
            svg: `<svg viewBox="0 0 24 24" fill="#8BC34A"><path d="M22 16V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2zm-11-4l2.03 2.71L16 11l4 5H8l3-4zM2 6v14c0 1.1.9 2 2 2h14v-2H4V6H2z"/></svg>`
        },
        {
            id: 'bank', name: '钱包', screen: 'character-bank-screen',
            // 【核心修改】替换为新的钱包SVG
            svg: `<svg viewBox="0 0 24 24" fill="#E91E63"><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></svg>`
        },
        {
            id: 'trajectory', name: '足迹', screen: 'character-trajectory-screen',
            svg: `<svg viewBox="0 0 24 24" fill="#795548"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5s-1.12 2.5-2.5 2.5z"/></svg>`
        },
        {
            id: 'app_usage', name: '使用记录', screen: 'character-app-usage-screen',
            svg: `<svg viewBox="0 0 24 24" fill="#607D8B"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8s8 3.58 8 8s-3.58 8-8 8zm.5-13H11v6l5.25 3.15l.75-1.23l-4.5-2.67z"/></svg>`
        },
        {
            id: 'diary', name: '日记', screen: 'character-diary-screen',
            svg: `<svg viewBox="0 0 24 24" fill="#009688"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83l3.75 3.75 1.83-1.83z"/></svg>`
        },
    ];

    apps.forEach(app => {
        const iconEl = document.createElement('div');
        iconEl.className = 'app-icon';
        iconEl.innerHTML = `
            <div class="icon-bg" style="display: flex; justify-content: center; align-items: center; padding: 12px;">
                ${app.svg}
            </div>
            <span class="label">${app.name}</span>
        `;
        iconEl.addEventListener('click', () => {
            switch(app.id) {
                case 'chat': renderCharacterChatList(); break;
                case 'cart': renderCharacterShoppingCart(); break;
                case 'memos': renderCharacterMemos(); break;
                case 'browser': renderCharacterBrowser(); break;
                case 'album': renderCharacterPhotoAlbum(); break;
                case 'bank': renderCharacterBank(); break;
                case 'trajectory': renderCharacterTrajectory(); break;
                case 'app_usage': renderCharacterAppUsage(); break;
            }
            showCharacterPhonePage(app.screen); 
        });
        gridEl.appendChild(iconEl);
    });
}

/**
 * 【AI核心】生成角色手机数据
 */
async function generateCharacterPhoneData() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    // 显示加载动画
    document.getElementById('generation-overlay').classList.add('visible');

    try {
        // 1. 准备给AI的上下文
        const persona = chat.settings.aiPersona;
        const recentHistory = chat.history.slice(-10).map(msg => {
            const sender = msg.role === 'user' ? '我' : chat.name;
            return `${sender}: ${msg.content}`;
        }).join('\n');
        
        let worldBookContext = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            worldBookContext = '--- 世界观设定 (必须严格遵守) ---\n' +
                chat.settings.linkedWorldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `[${book.name}]: ${book.content}` : '';
                }).join('\n\n');
        }

        // 2. 构建超级Prompt (V6 精简+日记版)
        const prompt = `
# 任务
你现在是角色 "${chat.name}"。请根据你的人设、世界观以及和我的最近聊天记录，模拟生成你手机中的各项数据。你需要一次性生成所有数据，并严格按照下面的JSON格式返回。

# 你的信息
- 你的名字: ${chat.name}
- 你的人设: ${persona}
${worldBookContext}

# 和我的最近聊天记录摘要
${recentHistory}

# JSON输出格式 (必须严格遵守，不要添加任何额外说明)
{
  "chats": [
    {
      "contactName": "【这里填写你给我（用户）的备注名】"
    },
    {
      "contactName": "【虚构联系人A的名字】",
      "messages": [
        {"sender": "联系人A", "content": "消息内容1..."},
        {"sender": "${chat.name}", "content": "你的回复1..."},
        {"sender": "联系人A", "content": "消息内容2..."},
        {"sender": "联系人A", "content": "消息内容3..."},
        {"sender": "${chat.name}", "content": "你的回复2..."}
      ]
    }
  ],
  "shoppingCart": [
    {"name": "商品名", "price": 价格, "store": "店铺名"}
  ],
  "memos": [
    {"title": "备忘录标题", "content": "备忘录详细内容..."}
  ],
  "browserHistory": [
    {"query": "搜索或浏览的标题", "result": "【这里是AI生成的、关于这个搜索标题的模拟文章或网页内容】"}
  ],
  "photoAlbum": [
    {"hiddenContent": "对照片画面的详细文字描述"}
  ],
  "bank": {
    "balance": 银行卡余额(数字),
    "transactions": [
      {"type": "收入或支出", "amount": 金额, "description": "交易描述"}
    ]
  },
  "trajectory": [
    {"time": "时间段", "location": "地点", "activity": "干了什么事"}
  ],
  "appUsage": [
    {"appName": "应用名", "duration": "使用时长"}
  ]
}

# 【【【重要指令：关于聊天记录生成】】】
- 你必须为每个虚构联系人生成一段【至少包含5条消息】的对话。
- 对话内容应该自然流畅，可以包含连续发言、表情包和表情符号等，以体现真实感。
- 不要只生成一问一答的机械式对话。
`;

        // 3. 发送API请求 (这里你需要替换成你自己的API调用逻辑)
        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, [{role: 'user', content: prompt}], isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'user', content: prompt}],
                    temperature: 0.8,
                    response_format: { type: "json_object" } // 请求JSON输出
                })
            });

        if (!response.ok) throw new Error('API请求失败');
        
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, ''); // 清理Markdown代码块

        const newData = JSON.parse(aiResponseContent);

        // 4. 【V5最终修复版】替换并合并所有APP的数据
        let phoneData = chat.characterPhoneData;
        phoneData.lastGenerated = Date.now();
        
        // a. 【核心】清空旧的NPC聊天记录，但保留“我”的备注信息
        const userRemarkData = phoneData.chats['我'];
        phoneData.chats = { '我': userRemarkData || { avatar: '', history: [] } }; // 只保留“我”的壳

        // b. 合并AI新生成的NPC聊天数据
        if (newData.chats) {
            newData.chats.forEach(newChat => {
                // AI为“我”生成的数据，只更新备注名
                if (!newChat.messages) {
                    phoneData.chats['我'].remarkName = newChat.contactName;
                } 
                // AI为NPC生成的数据，直接存入
                else {
                    const contactName = newChat.contactName;
                    phoneData.chats[contactName] = { 
                        avatar: newChat.avatar, 
                        history: newChat.messages 
                    };
                }
            });
        }

        // c. 【核心】用“=”直接替换掉所有APP的旧数据数组
        phoneData.shoppingCart = newData.shoppingCart || [];
        phoneData.memos = newData.memos || [];
        phoneData.browserHistory = newData.browserHistory || [];
        phoneData.photoAlbum = newData.photoAlbum || [];
        phoneData.trajectory = newData.trajectory || [];
        phoneData.appUsage = newData.appUsage || [];

        // d. 【核心】同样，直接替换掉整个银行对象
        phoneData.bank = newData.bank || { balance: 0, transactions: [] };
        
        // 5. 保存到数据库
        await db.chats.put(chat);
        alert('数据已刷新！');

    } catch (error) {
        console.error("生成角色手机数据失败:", error);
        alert(`生成失败: ${error.message}`);
    } finally {
        // 隐藏加载动画
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}

/**
 * 清空角色手机数据
 */
async function clearCharacterPhoneData() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    const confirmed = await showCustomConfirm('确认清空', `确定要清空“${chat.name}”的所有手机数据吗？此操作不可恢复。`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        // 重置为初始状态
        chat.characterPhoneData = {
            lastGenerated: null, chats: {}, shoppingCart: [], memos: [],
            browserHistory: [], photoAlbum: [], bank: { balance: 0, transactions: [] },
            trajectory: [],         appUsage: [],
        diary: [] // <--- 在这里新增
        };
        await db.chats.put(chat);
        // 重新渲染APP网格，因为点击APP会读取新数据
        renderCharacterAppGrid();
        alert('数据已清空。');
    }
}

// --- 以下是各个APP界面的渲染函数 ---

/**
 * 【V6最终修正版】渲染角色手机的聊天列表 (修复NPC头像颜色不一致问题)
 */
function renderCharacterChatList() {
    const listEl = document.getElementById('character-chat-list');
    const characterChatData = state.chats[activeCharacterPhoneId].characterPhoneData;
    const realChatHistory = state.chats[activeCharacterPhoneId].history;
    listEl.innerHTML = '';

    // 【移除】不再需要 colorIndex，因为颜色不再依赖顺序
    // let colorIndex = 0; 
    const avatarColors = ['#FFC107', '#4CAF50', '#2196F3', '#F44336', '#9C27B0', '#00BCD4'];

    // 1. 优先渲染和“我”的聊天 (逻辑不变)
    const myChatData = characterChatData.chats['我'];
    if (myChatData) {
        const lastMsg = realChatHistory.filter(m => !m.isHidden).slice(-1)[0] || { content: '...' };
        const myChatItem = document.createElement('div');
        myChatItem.className = 'chat-list-item';
        const remarkNameForMe = myChatData.remarkName || '我';
        myChatItem.dataset.contactName = remarkNameForMe; 
        
        const myAvatar = state.chats[activeCharacterPhoneId].settings.myAvatar || defaultMyGroupAvatar;
        
        myChatItem.innerHTML = `
            <img src="${myAvatar}" class="avatar" style="border-radius: 6px;">
            <div class="info">
                <span class="name">${remarkNameForMe}</span>
                <div class="last-msg">${String(lastMsg.content).substring(0, 30)}</div>
            </div>
        `;
        listEl.appendChild(myChatItem);
    }

    // 2. 接着渲染所有和NPC的聊天
    for (const contactName in characterChatData.chats) {
        if (contactName === '我') continue;

        const contact = characterChatData.chats[contactName];
        const lastNpcMsg = contact.history.slice(-1)[0] || { content: '...' };
        const npcChatItem = document.createElement('div');
        npcChatItem.className = 'chat-list-item';
        npcChatItem.dataset.contactName = contactName;

        const npcNameInitial = contactName.slice(-1);
        
        // 【核心修正】使用和聊天详情页完全一样的颜色计算方法
        const colorIndex = contactName.length % avatarColors.length;
        const bgColor = avatarColors[colorIndex];
        
        const npcAvatarHtml = `
            <div class="avatar" style="border-radius: 6px; background-color: ${bgColor}; color: white; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: 500;">
                ${npcNameInitial}
            </div>
        `;

        npcChatItem.innerHTML = `
            ${npcAvatarHtml}
            <div class="info">
                <span class="name">${contactName}</span>
                <div class="last-msg">${String(lastNpcMsg.content).substring(0, 30)}</div>
            </div>
        `;
        listEl.appendChild(npcChatItem);
    }

    if (listEl.children.length === 0) {
         listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">还没有聊天记录，请先刷新数据。</p>';
    }
}

/**
 * 【V6终极版】渲染角色手机的具体聊天记录 (同步列表头像样式)
 */
function renderCharacterChatHistory(contactName) {
    // 1. 获取必要的DOM元素和数据 (这部分不变)
    const messagesEl = document.getElementById('character-chat-history-messages');
    messagesEl.innerHTML = '';
    
    const characterChat = state.chats[activeCharacterPhoneId];
    if (!characterChat) return;

    // 2. 智能获取备注名 (这部分不变)
    let finalContactName = contactName;
    const myChatData = characterChat.characterPhoneData.chats['我'];
    if ((contactName === '我' || (myChatData && contactName === myChatData.remarkName)) && myChatData) {
        finalContactName = myChatData.remarkName || '我';
    }
    document.getElementById('character-chat-with-name').textContent = finalContactName;

    // 3. 【核心修改】在循环前，预先准备好两位聊天者的头像HTML
    const avatarColors = ['#FFC107', '#4CAF50', '#2196F3', '#F44336', '#9C27B0', '#00BCD4'];
    let mainCharacterAvatarHtml;
    let otherParticipantAvatarHtml;

    // a. 准备角色自己的头像 (总是真实的图片头像)
    const characterAvatarSrc = characterChat.settings.aiAvatar || defaultAvatar;
    mainCharacterAvatarHtml = `<img src="${characterAvatarSrc}" class="character-chat-avatar">`;

    // b. 根据聊天对象，准备对方的头像
    if (finalContactName === (myChatData?.remarkName || '我')) {
        // 如果是和“我”聊天，就抓取“我”的真实头像
        const myAvatarSrc = characterChat.settings.myAvatar || defaultMyGroupAvatar;
        otherParticipantAvatarHtml = `<img src="${myAvatarSrc}" class="character-chat-avatar">`;
    } else {
        // 如果是和NPC聊天，就生成文字头像
        const npcNameInitial = contactName.slice(-1);
        // 使用一个简单的哈希算法（名字长度取余）来获得一个固定的颜色，确保同一个NPC颜色不变
        const colorIndex = contactName.length % avatarColors.length;
        const bgColor = avatarColors[colorIndex];
        
        otherParticipantAvatarHtml = `
            <div class="character-chat-avatar" style="background-color: ${bgColor}; color: white; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: 500;">
                ${npcNameInitial}
            </div>
        `;
    }

    // 4. 获取要渲染的聊天记录 (这部分不变)
    let historyToShow = [];
    if (finalContactName === (myChatData?.remarkName || '我')) {
        historyToShow = characterChat.history.slice(-20);
    } else {
        const npcChat = characterChat.characterPhoneData.chats[contactName];
        if (npcChat) {
            historyToShow = npcChat.history;
        }
    }
    
    // 5. 【核心修改】在渲染循环中，直接使用我们预先准备好的头像HTML
    const characterName = characterChat.name;
    historyToShow.forEach(msg => {
        if (msg.isHidden) return;

        const container = document.createElement('div');
        const sender = msg.role === 'user' ? '我' : (msg.sender || characterName);
        const isSentByCharacter = sender === characterName;
        
        container.className = `character-chat-bubble-container ${isSentByCharacter ? 'sent' : 'received'}`;
        
        // ★★★ 直接在这里根据发送方，选择正确的头像HTML ★★★
        const avatarHtml = isSentByCharacter ? mainCharacterAvatarHtml : otherParticipantAvatarHtml;
        
        let contentHtml = '';
        if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
            contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-height: 100px;">`;
        } else {
            contentHtml = msg.content;
        }
        const bubbleHtml = `<div class="character-chat-bubble">${contentHtml}</div>`;

        container.innerHTML = `
            ${avatarHtml}
            ${bubbleHtml}
        `;
        
        messagesEl.appendChild(container);
    });

    // 滚动到底部
    messagesEl.scrollTop = messagesEl.scrollHeight;
}

/**
 * 【V2美化版】渲染角色手机 - 购物车
 */
function renderCharacterShoppingCart() {
    const listEl = document.getElementById('character-shopping-cart-list');
    const items = state.chats[activeCharacterPhoneId].characterPhoneData.shoppingCart;
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">购物车是空的</p>';
        return;
    }
    items.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-cart-item';
        itemEl.innerHTML = `
            <div class="cart-item-icon">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path></svg>
            </div>
            <div class="cart-item-info">
                <div class="title">${item.name}</div>
                <div class="store">${item.store}</div>
            </div>
            <div class="cart-item-price">¥ ${item.price.toFixed(2)}</div>
        `;
        listEl.appendChild(itemEl);
    });
}

function renderCharacterMemos() {
    const listEl = document.getElementById('character-memos-list');
    const items = state.chats[activeCharacterPhoneId].characterPhoneData.memos;
    listEl.innerHTML = '';
    items.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-data-item';
        itemEl.innerHTML = `
            <div class="title">${item.title}</div>
            <div class="content">${item.content}</div>
        `;
        listEl.appendChild(itemEl);
    });
}

// ▲▲▲ 新功能函数结束 ▲▲▲

/**
 * 【全新】在角色手机内部切换页面
 * @param {string} pageId - 要显示的角色手机页面的ID
 */
function showCharacterPhonePage(pageId) {
    // 1. 找到角色手机内部屏幕的所有页面
    const pages = document.querySelectorAll('.character-phone-page');
    // 2. 隐藏所有页面
    pages.forEach(p => p.classList.remove('active'));
    // 3. 显示目标页面
    const pageToShow = document.getElementById(pageId);
    if (pageToShow) {
        pageToShow.classList.add('active');
    }
}

// ▼▼▼ 【全新】角色手机新增APP渲染函数 ▼▼▼

/**
 * 【V3美化版】渲染角色手机 - 浏览器历史
 */
function renderCharacterBrowser() {
    const listEl = document.getElementById('character-browser-list');
    const items = state.chats[activeCharacterPhoneId].characterPhoneData.browserHistory;
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">浏览器历史为空</p>';
        return;
    }
    items.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-browser-item';
        itemEl.innerHTML = `
            <span class="browser-item-icon">🌐</span>
            <div class="title">${item.query}</div>
        `;
        itemEl.addEventListener('click', () => {
            document.getElementById('character-browser-detail-title').textContent = item.query;
            document.getElementById('character-browser-detail-content').innerHTML = (item.result || "AI未生成详细内容。").replace(/\n/g, '<br>');
            showCharacterPhonePage('character-browser-detail-screen');
        });
        listEl.appendChild(itemEl);
    });
}

/**
 * 【V2网格版】渲染角色手机 - 相册
 */
function renderCharacterPhotoAlbum() {
    const gridEl = document.getElementById('character-album-grid');
    const items = state.chats[activeCharacterPhoneId].characterPhoneData.photoAlbum;
    gridEl.innerHTML = '';
    if (!items || items.length === 0) {
        gridEl.innerHTML = '<p style="grid-column: 1 / -1; text-align:center; color: #8a8a8a; margin-top: 50px;">相册里没有照片</p>';
        return;
    }
    items.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-album-item';
        // 使用固定的文字图占位符
        itemEl.innerHTML = `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" alt="文字图">`;
        // 点击时显示AI生成的详细描述
        itemEl.addEventListener('click', () => {
            // 因为publicText已经移除，标题直接设为“图片内容”
            showCustomAlert("图片内容", item.hiddenContent);
        });
        gridEl.appendChild(itemEl);
    });
}

/**
 * 【V2美化版】渲染角色手机 - 银行
 */
function renderCharacterBank() {
    const detailsEl = document.getElementById('character-bank-details');
    const bankData = state.chats[activeCharacterPhoneId].characterPhoneData.bank;
    detailsEl.innerHTML = '';
    
    const balanceCard = document.createElement('div');
    balanceCard.className = 'character-bank-balance-card';
    balanceCard.innerHTML = `
        <div class="label">账户余额</div>
        <div class="amount">¥ ${(bankData.balance || 0).toFixed(2)}</div>
    `;
    detailsEl.appendChild(balanceCard);
    
    if (!bankData.transactions || bankData.transactions.length === 0) {
        detailsEl.innerHTML += '<p style="text-align:center; color: #8a8a8a; margin-top: 30px;">暂无交易明细</p>';
        return;
    }
    // 让最新的交易在最上面
    [...bankData.transactions].reverse().forEach(item => {
        const isIncome = item.type === '收入';
        const itemEl = document.createElement('div');
        itemEl.className = 'character-bank-transaction';
        const iconBg = isIncome ? '#4CAF50' : '#E91E63';
        const iconSvg = isIncome 
            ? `<svg width="20" height="20" viewBox="0 0 24 24" fill="white"><path d="M7 10h10v4H7z" opacity=".3"/><path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z"/></svg>`
            : `<svg width="20" height="20" viewBox="0 0 24 24" fill="white"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-1 14H5c-.55 0-1-.45-1-1v-5h16v5c0 .55-.45 1-1 1zm1-10H4V7c0-.55.45-1 1-1h14c.55 0 1 .45 1 1v2z"/></svg>`;

        itemEl.innerHTML = `
            <div class="transaction-details">
                <div class="transaction-icon" style="background-color: ${iconBg};">${iconSvg}</div>
                <div>
                    <div class="title">${item.description}</div>
                    <div class="meta" style="border:none; padding:0; margin-top:4px;"><span>${item.type}</span></div>
                </div>
            </div>
            <span class="transaction-amount ${isIncome ? 'income' : 'expense'}">
                ${isIncome ? '+' : '-'} ${item.amount.toFixed(2)}
            </span>
        `;
        detailsEl.appendChild(itemEl);
    });
}

/**
 * 【V2美化版】渲染角色手机 - 行动轨迹
 */
function renderCharacterTrajectory() {
    const listEl = document.getElementById('character-trajectory-list');
    const items = state.chats[activeCharacterPhoneId].characterPhoneData.trajectory;
    listEl.innerHTML = ''; // 清空容器
    listEl.classList.add('character-trajectory-list'); // 确保容器有正确的class

    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">暂无足迹</p>';
        return;
    }
    items.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-trajectory-item';
        itemEl.innerHTML = `
            <div class="trajectory-item-content">
                <div class="title">${item.activity}</div>
                <div class="meta">
                    <span>📍 ${item.location}</span>
                    <span style="margin-left: 10px;">🕒 ${item.time}</span>
                </div>
            </div>
        `;
        listEl.appendChild(itemEl);
    });
}

/**
 * 【V2美化版】渲染角色手机 - APP使用记录
 */
function renderCharacterAppUsage() {
    const listEl = document.getElementById('character-app-usage-list');
    const items = state.chats[activeCharacterPhoneId].characterPhoneData.appUsage;
    listEl.innerHTML = '';
     if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">暂无使用记录</p>';
        return;
    }

    // 1. 计算总时长，用于确定进度条比例
    const durationsInMinutes = items.map(item => parseDurationToMinutes(item.duration));
    const maxDuration = Math.max(...durationsInMinutes);

    // 2. 渲染每一项
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-app-usage-item';
        const durationInMinutes = durationsInMinutes[index];
        const barWidth = maxDuration > 0 ? (durationInMinutes / maxDuration) * 100 : 0;

        itemEl.innerHTML = `
            <div class="app-usage-header">
                <span class="name">${item.appName}</span>
                <span class="duration">${item.duration}</span>
            </div>
            <div class="app-usage-bar-container">
                <div class="app-usage-bar" style="width: ${barWidth}%;"></div>
            </div>
        `;
        listEl.appendChild(itemEl);
    });
}

// ▲▲▲ 新增渲染函数结束 ▲▲▲

/**
 * 【日记 V3-带删除和美化】渲染角色的日记列表
 */
function renderCharacterDiary() {
    const listEl = document.getElementById('character-diary-list');
    const items = state.chats[activeCharacterPhoneId].characterPhoneData.diary;
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">日记本还是空的，点击右上角写下第一篇日记吧。</p>';
        return;
    }
    
    // 我们需要用索引来找到并删除日记，所以这里用 forEach 的第二个参数
    [...items].reverse().forEach((item, index) => {
        // 因为我们反转了数组来显示，所以需要计算出它在原始数组中的真实索引
        const originalIndex = items.length - 1 - index;

        const itemEl = document.createElement('div');
        itemEl.className = 'character-data-item';
        
        const contentHtml = renderMarkdown(item.content);
            
        itemEl.innerHTML = `
            <div class="content">${contentHtml}</div>
            <div class="meta">
                <span>${new Date(item.timestamp).toLocaleString()}</span>
            </div>
            <!-- 添加一个隐藏的删除按钮 -->
            <button class="diary-delete-btn" title="删除这篇日记">×</button>
        `;

        // 【核心】为整张日记卡片添加长按事件
        addLongPressListener(itemEl, () => {
            const deleteBtn = itemEl.querySelector('.diary-delete-btn');
            // 长按时，让删除按钮显示出来
            deleteBtn.style.opacity = '1';
        });

        // 为删除按钮本身添加点击事件
        itemEl.querySelector('.diary-delete-btn').addEventListener('click', async (e) => {
            e.stopPropagation(); // 阻止事件冒泡
            const confirmed = await showCustomConfirm(
                '删除日记',
                '确定要永久删除这篇日记吗？',
                { confirmButtonClass: 'btn-danger' }
            );
            if (confirmed) {
                // 从数据中移除
                state.chats[activeCharacterPhoneId].characterPhoneData.diary.splice(originalIndex, 1);
                // 保存到数据库
                await db.chats.put(state.chats[activeCharacterPhoneId]);
                // 重新渲染列表
                renderCharacterDiary();
            }
        });
        
        listEl.appendChild(itemEl);
    });
}

/**
 * 【日记】独立刷新，生成新的日记条目
 */
async function generateNewDiaryEntry() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    document.getElementById('generation-overlay').classList.add('visible');

    try {
        const persona = chat.settings.aiPersona;
        const recentHistory = chat.history.slice(-20).map(msg => {
            const sender = msg.role === 'user' ? '我' : chat.name;
            return `${sender}: ${msg.content}`;
        }).join('\n');

// ▼▼▼ 在这里添加下面的代码 ▼▼▼
let worldBookContext = '';
if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
    worldBookContext = '--- 世界观设定 (这是你必须严格遵守的背景) ---\n' +
        chat.settings.linkedWorldBookIds.map(id => {
            const book = state.worldBooks.find(b => b.id === id);
            return book ? `[${book.name}]: ${book.content}` : '';
        }).join('\n\n');
}
// ▲▲▲ 添加结束 ▲▲▲
        
        // 日记的专属Prompt (V2富文本版)
        const diaryPrompt = `
# 任务
你现在是角色 "${chat.name}"。请你回顾一下最近和我的聊天，以及你的人设，然后用你的口吻写一篇日记。
这篇日记是你内心的独白，可以记录你的感受、思考、计划或者秘密。
内容要丰富、有深度，长度在100到300字之间。

# 【【【重要：格式指令】】】
你【必须】使用以下Markdown语法来丰富日记的格式，使其更具表现力：
-   **标题**: 使用 \`#\` 或 \`##\` 来创建大标题和副标题。 (例如: \`# 今天的心情\`)
-   **粗体**: 使用 \`**文字**\` 来强调重点。 (例如: \`今天真的**非常**开心。\`)
-   **斜体**: 使用 \`*文字*\` 来表达情绪或内心想法。 (例如: \`*他到底是怎么想的呢...*\`)
-   **删除线**: 使用 \`~~文字~~\` 来表示划掉或否定的想法。 (例如: \`我决定明天去<s>逛街</s>学习。\`)
-   **遮挡/剧透**: 使用 \`||文字||\` 来隐藏秘密或悄悄话。 (例如: \`我偷偷准备了一个惊喜，||是一个手织的围巾||。\`)

你的输出【必须且只能】是日记的正文内容，不要包含任何其他说明或JSON格式。

# 你的信息
- 你的名字: ${chat.name}
- 你的人设: ${persona}
${worldBookContext}

# 最近聊天记录参考
${recentHistory}
`;

        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, diaryPrompt, [{role: 'user', content: diaryPrompt}], isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'user', content: diaryPrompt}],
                    temperature: 0.9, // 提高一点温度，让日记更有创造性
                })
            });

        if (!response.ok) throw new Error('API请求失败');
        
        const data = await response.json();
        const diaryContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;

        // 创建新的日记对象并保存
        const newEntry = {
            timestamp: Date.now(),
            content: diaryContent
        };
        
        chat.characterPhoneData.diary.push(newEntry);
        await db.chats.put(chat);
        
        // 刷新日记页面
        renderCharacterDiary();
        alert('新日记已生成！');

    } catch (error) {
        console.error("生成日记失败:", error);
        alert(`生成失败: ${error.message}`);
    } finally {
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}

// ▲▲▲ 新增函数结束 ▲▲▲

// ▼▼▼ 【全新】万能Markdown渲染函数 (带安全过滤和遮挡效果) ▼▼▼

/**
 * 将Markdown文本安全地渲染为HTML
 * @param {string} markdownText - 原始的Markdown文本
 * @returns {string} - 处理和净化后的安全HTML字符串
 */
function renderMarkdown(markdownText) {
    if (!markdownText) return '';

    // 1. 【预处理】支持自定义的“遮挡/剧透”语法 ||spoiler||
    // 我们在 marked.js 处理之前，手动把 ||text|| 替换成带特定class的HTML标签
    let processedText = markdownText.replace(/\|\|(.*?)\|\|/g, '<span class="spoiler">$1</span>');

    // 2. 【核心】使用 marked.js 将Markdown转换为HTML
    // gfm: true 开启GitHub风格的Markdown，支持删除线等
    // breaks: true 让回车符也能变成<br>，更符合聊天习惯
    let rawHtml = marked.parse(processedText, { gfm: true, breaks: true });

    // 3. 【安全】使用 DOMPurify 清洗HTML，防止XSS攻击
    let sanitizedHtml = DOMPurify.sanitize(rawHtml);

    return sanitizedHtml;
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

/**
 * 【辅助函数】将时长字符串（如“2.5小时”）转换为分钟数
 */
function parseDurationToMinutes(durationString) {
    if (!durationString) return 0;
    const num = parseFloat(durationString) || 0;
    if (durationString.includes('小时') || durationString.includes('h')) {
        return num * 60;
    }
    // 默认单位是分钟
    return num;
}
// ▼▼▼ 【全新】请将这个函数完整地粘贴到您的JS功能函数定义区 ▼▼▼

/**
 * 【工具函数】关闭功能面板并重置UI
 */
function closePlusPanel() {
    const chatInterface = document.getElementById('chat-interface-screen');
    const singlePanel = document.getElementById('chat-plus-panel-single');
    const groupPanel = document.getElementById('chat-plus-panel-group');
    
    // 检查是否有任何一个面板是展开的
    if (singlePanel.classList.contains('visible') || groupPanel.classList.contains('visible')) {
        // 收起所有面板
        singlePanel.classList.remove('visible');
        groupPanel.classList.remove('visible');
        // 移除导致底部空白的CSS类
        chatInterface.classList.remove('panel-expanded');
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
function cleanupWaimaiTimers() {
    for (const timestamp in waimaiTimers) {
        clearInterval(waimaiTimers[timestamp]);
    }
    waimaiTimers = {};
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    // 1. 更新原始消息的状态
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;
    
    // 【核心修正】记录支付者，并构建对AI更清晰的系统消息
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // 记录是用户付的钱
        systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
    } else {
        systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
    }

    // 2. 创建一条新的、对用户隐藏的系统消息，告知AI结果
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 3. 保存更新到数据库并刷新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);  
}

let videoCallState = {
    isActive: false,       
    isAwaitingResponse: false, 
    isGroupCall: false,      
    activeChatId: null,    
    initiator: null,       
    startTime: null,       
    participants: [],      
    isUserParticipating: true,
    // --- 【核心新增】---
    callHistory: [], // 用于存储通话中的对话历史
    preCallContext: "" // 用于存储通话前的聊天摘要
};

let callTimerInterval = null; // 用于存储计时器的ID

/**
 * 【总入口】用户点击“发起视频通话”或“发起群视频”按钮
 */
async function handleInitiateCall() {
    if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
    closePlusPanel(); // 自动收起功能面板
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    const chat = state.chats[state.activeChatId];
    videoCallState.isGroupCall = chat.isGroup;
    videoCallState.isAwaitingResponse = true;
    videoCallState.initiator = 'user';
    videoCallState.activeChatId = chat.id;
    videoCallState.isUserParticipating = true; // 用户自己发起的，当然是参与者

    // 根据是单聊还是群聊，显示不同的呼叫界面
    if (chat.isGroup) {
        document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || '我';
    } else {
        document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.name;
    }
    document.querySelector('#outgoing-call-screen .caller-text').textContent = chat.isGroup ? "正在呼叫所有成员..." : "正在呼叫...";
    showScreen('outgoing-call-screen');
    
    // 准备并发送系统消息给AI
    const requestMessage = {
        role: 'system',
        content: chat.isGroup 
            ? `[系统提示：用户 (${chat.settings.myNickname || '我'}) 发起了群视频通话请求。请你们各自决策，并使用 "group_call_response" 指令，设置 "decision" 为 "join" 或 "decline" 来回应。]`
            : `[系统提示：用户向你发起了视频通话请求。请根据你的人设，使用 "video_call_response" 指令，并设置 "decision" 为 "accept" 或 "reject" 来回应。]`,
        timestamp: Date.now(),
        isHidden: true,
    };
    chat.history.push(requestMessage);
    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    const userWorkaroundMessage = {
        role: 'user',
        content: '（用户发起了视频通话请求，你的回复【必须且只能】是以下两种格式之一的JSON数组，绝对不能回复任何其他内容： -   接受: `[{"type": "video_call_response", "decision": "accept"}]` -   拒绝: `[{"type": "video_call_response", "decision": "reject"}]`）',
        timestamp: Date.now() + 1, // 确保这条消息在最后
        isHidden: true // 确保对用户不可见
    };
    chat.history.push(userWorkaroundMessage);
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    
    await db.chats.put(chat);
    
    // 触发AI响应
    await triggerAiResponse();
}


function startVideoCall() {
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    videoCallState.isActive = true;
    videoCallState.isAwaitingResponse = false;
    videoCallState.startTime = Date.now();
    videoCallState.callHistory = []; // 【新增】清空上一次通话的历史

    // --- 【核心新增：抓取通话前上下文】---
    const preCallHistory = chat.history.slice(-50); // 取最后50条作为上下文
    videoCallState.preCallContext = preCallHistory.map(msg => {
        const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
        return `${sender}: ${String(msg.content).substring(0, 50)}...`;
    }).join('\n');
    // --- 新增结束 ---

    updateParticipantAvatars(); 
    
    document.getElementById('video-call-main').innerHTML = `<em>${videoCallState.isGroupCall ? '群聊已建立...' : '正在接通...'}</em>`;
    showScreen('video-call-screen');

    document.getElementById('user-speak-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
    document.getElementById('join-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';

    if (callTimerInterval) clearInterval(callTimerInterval);
    callTimerInterval = setInterval(updateCallTimer, 1000);
    updateCallTimer();

    triggerAiInCallAction();
}

/**
 * 【核心】结束视频通话
 */
// ▼▼▼ 用这整块代码替换旧的 endVideoCall 函数 ▼▼▼
async function endVideoCall() {
    if (!videoCallState.isActive) return;

    const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const durationText = `${Math.floor(duration / 60)}分${duration % 60}秒`;
    const endCallText = `通话结束，时长 ${durationText}`;

    const chat = state.chats[videoCallState.activeChatId];
    if (chat) {
        // 1. 保存完整的通话记录到数据库 (这部分逻辑不变)
        const participantsData = [];
        if (videoCallState.isGroupCall) {
            videoCallState.participants.forEach(p => participantsData.push({ name: p.originalName, avatar: p.avatar }));
            if (videoCallState.isUserParticipating) {
                participantsData.unshift({ name: chat.settings.myNickname || '我', avatar: chat.settings.myAvatar || defaultMyGroupAvatar });
            }
        } else {
            participantsData.push({ name: chat.name, avatar: chat.settings.aiAvatar || defaultAvatar });
            participantsData.unshift({ name: '我', avatar: chat.settings.myAvatar || defaultAvatar });
        }
        
        const callRecord = {
            chatId: videoCallState.activeChatId,
            timestamp: Date.now(),
            duration: duration,
            participants: participantsData,
            transcript: [...videoCallState.callHistory]
        };
        await db.callRecords.add(callRecord);
        console.log("通话记录已保存:", callRecord);
        
        // 2. 在聊天记录里添加对用户可见的“通话结束”消息
let summaryMessage = {
    // 【核心修正1】role 由 videoCallState.initiator 决定
    role: videoCallState.initiator === 'user' ? 'user' : 'assistant',
    content: endCallText,
    timestamp: Date.now(),
};

// 【核心修正2】为群聊的 assistant 消息补充 senderName
if (chat.isGroup && summaryMessage.role === 'assistant') {
    // 在群聊中，通话结束的消息应该由“发起者”来说
    // videoCallState.callRequester 保存了最初发起通话的那个AI的名字
    summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.originalName || chat.name;
}
// ▲▲▲ 替换结束 ▲▲▲
        chat.history.push(summaryMessage);

        // 3. 【核心变革】创建并添加对用户隐藏的“通话后汇报”指令
        const callTranscriptForAI = videoCallState.callHistory.map(h => `${h.role === 'user' ? (chat.settings.myNickname || '我') : h.role}: ${h.content}`).join('\n');
        
        const hiddenReportInstruction = {
            role: 'system',
    content: `[系统指令：视频通话刚刚结束。请你根据完整的通话文字记录（见下方），以你的角色口吻，向用户主动发送几条【格式为 {"type": "text", "content": "..."} 的】消息，来自然地总结这次通话的要点、确认达成的约定，或者表达你的感受。这很重要，能让用户感觉你记得通话内容。]\n---通话记录开始---\n${callTranscriptForAI}\n---通话记录结束---`,
            timestamp: Date.now() + 1, // 确保在上一条消息之后
            isHidden: true
        };
        chat.history.push(hiddenReportInstruction);

        // ▼▼▼ 在这里粘贴新代码 ▼▼▼
        const userFollowUpMessage = {
            role: 'user',
            content: '（视频通话已结束，请根据视频通话内容继续聊天）',
            timestamp: Date.now() + 2, // 确保在所有其他消息之后
            isHidden: true // 确保这条消息对用户不可见
        };
        chat.history.push(userFollowUpMessage);
        // ▲▲▲ 新代码粘贴结束 ▲▲▲

        // 4. 保存所有更新到数据库
        await db.chats.put(chat);
    }
    
    // 5. 清理和重置状态 (这部分逻辑不变)
    clearInterval(callTimerInterval);
    callTimerInterval = null;
    videoCallState = { isActive: false, isAwaitingResponse: false, isGroupCall: false, activeChatId: null, initiator: null, startTime: null, participants: [], isUserParticipating: true, callHistory: [], preCallContext: "" };
    
    // 6. 返回聊天界面并触发AI响应（AI会读取到我们的“汇报”指令）
    if (chat) {
        openChat(chat.id);
        triggerAiResponse(); // 关键一步！
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// === 重roll功能实现 ===
let currentActiveRerollBtn = null;

/**
 * 显示重roll按钮
 */
function showRerollButton(aiBubble, messageData) {
    // 隐藏其他所有重roll按钮
    hideAllRerollButtons();
    
    // 显示当前气泡的重roll按钮
    const rerollBtn = aiBubble.querySelector('.reroll-btn');
    if (rerollBtn) {
        rerollBtn.style.display = 'flex';
        currentActiveRerollBtn = rerollBtn;
        
        // 给重roll按钮添加点击事件
        rerollBtn.onclick = (e) => {
            e.stopPropagation();
            handleReroll(aiBubble, messageData);
        };
    }
}

/**
 * 隐藏所有重roll按钮
 */
function hideAllRerollButtons() {
    const allRerollBtns = document.querySelectorAll('.reroll-btn');
    allRerollBtns.forEach(btn => {
        btn.style.display = 'none';
    });
    currentActiveRerollBtn = null;
}

/**
 * 处理重roll操作
 */
async function handleReroll(aiBubble, messageData) {
    const callFeed = document.getElementById('video-call-main');
    if (!callFeed) return;
    
    // 隐藏重roll按钮
    hideAllRerollButtons();
    
    // 显示重新生成中的提示
    const loadingBubble = document.createElement('div');
    loadingBubble.className = 'call-message-bubble ai-speech';
    loadingBubble.style.opacity = '0.7';
    loadingBubble.innerHTML = '正在重新生成回复...';
    
    // 替换原来的消息气泡
    aiBubble.parentNode.replaceChild(loadingBubble, aiBubble);
    
    try {
        // 从通话历史中移除最后一条AI消息
        if (videoCallState.callHistory.length > 0) {
            videoCallState.callHistory.pop();
        }
        
        // 直接调用视频通话专用的AI响应函数
        await triggerAiInCallAction();
        
        // 移除loading提示
        if (loadingBubble.parentNode) {
            loadingBubble.remove();
        }
        
    } catch (error) {
        console.error('重roll失败:', error);
        
        // 创建失败提示气泡，但仍然可以重新roll
        const errorBubble = document.createElement('div');
        errorBubble.className = 'call-message-bubble ai-speech';
        errorBubble.style.color = '#ff8a80';
        errorBubble.innerHTML = '重新生成失败，请稍后重试';
        
        // 创建重roll按钮
        const rerollBtn = document.createElement('button');
        rerollBtn.className = 'reroll-btn';
        rerollBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.97 11.03c-0.19-0.19-0.51-0.19-0.7 0s-0.19 0.51 0 0.7l2.47 2.47h-7.74c-2.21 0-4-1.79-4-4s1.79-4 4-4h5c0.28 0 0.5-0.22 0.5-0.5s-0.22-0.5-0.5-0.5h-5c-2.76 0-5 2.24-5 5s2.24 5 5 5h7.74l-2.47 2.47c-0.19 0.19-0.19 0.51 0 0.7 0.1 0.1 0.23 0.15 0.35 0.15s0.26-0.05 0.35-0.15l3.27-3.27c0.19-0.19 0.19-0.51 0-0.7l-3.27-3.27z"/></svg>`;
        
        errorBubble.appendChild(rerollBtn);
        
        // 替换loading气泡
        if (loadingBubble.parentNode) {
            loadingBubble.parentNode.replaceChild(errorBubble, loadingBubble);
        }
        
        // 添加点击事件，让失败的消息也能重新roll
        errorBubble.addEventListener('click', (e) => {
            e.stopPropagation();
            showRerollButton(errorBubble, messageData);
        });
    }
}

/**
 * 【全新】更新通话界面的参与者头像网格
 */
function updateParticipantAvatars() {
    const grid = document.getElementById('participant-avatars-grid');
    grid.innerHTML = '';
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    let participantsToRender = [];

    // ★ 核心修正：区分群聊和单聊
    if (videoCallState.isGroupCall) {
        // 群聊逻辑：显示所有已加入的AI成员
        participantsToRender = [...videoCallState.participants];
        // 如果用户也参与了，就把用户信息也加进去
        if (videoCallState.isUserParticipating) {
            participantsToRender.unshift({
                id: 'user',
                name: chat.settings.myNickname || '我',
                avatar: chat.settings.myAvatar || defaultMyGroupAvatar
            });
        }
    } else {
        // 单聊逻辑：只显示对方的头像和名字
        participantsToRender.push({
            id: 'ai',
            name: chat.name,
            avatar: chat.settings.aiAvatar || defaultAvatar
        });
    }
    
    participantsToRender.forEach(p => {
        const wrapper = document.createElement('div');
        wrapper.className = 'participant-avatar-wrapper';
        wrapper.dataset.participantId = p.id;
const displayName = p.groupNickname || p.name; // <-- 核心修复在这里
wrapper.innerHTML = `
    <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
    <div class="participant-name">${displayName}</div>
`;
        grid.appendChild(wrapper);
    });
}

/**
 * 【全新】处理用户加入/重新加入通话
 */
function handleUserJoinCall() {
    if (!videoCallState.isActive || videoCallState.isUserParticipating) return;
    
    videoCallState.isUserParticipating = true;
    updateParticipantAvatars(); // 更新头像列表，加入用户

    // 切换底部按钮
    document.getElementById('user-speak-btn').style.display = 'block';
    document.getElementById('join-call-btn').style.display = 'none';

    // 告知AI用户加入了
    triggerAiInCallAction("[系统提示：用户加入了通话]");
}


/**
 * 更新通话计时器显示 (保持不变)
 */
function updateCallTimer() {
    if (!videoCallState.isActive) return;
    const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    document.getElementById('call-timer').textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

// ▼▼▼ 用这个完整函数替换旧的 showIncomingCallModal ▼▼▼
function showIncomingCallModal() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 根据是否群聊显示不同信息
    if (chat.isGroup) {
        // 从 videoCallState 中获取是哪个成员发起的通话
        const requesterName = videoCallState.callRequester || chat.members[0]?.name || '一位成员';
        document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
        document.getElementById('caller-name').textContent = chat.name; // 显示群名
        document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} 邀请你加入群视频`; // 显示具体发起人
    } else {
        // 单聊逻辑保持不变
        document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('caller-name').textContent = chat.name;
        document.querySelector('.incoming-call-content .caller-text').textContent = '邀请你视频通话';
    }
    
    document.getElementById('incoming-call-modal').classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 隐藏AI发起的通话请求模态框 (保持不变)
 */
function hideIncomingCallModal() {
    document.getElementById('incoming-call-modal').classList.remove('visible');
}

async function triggerAiInCallAction(userInput = null) {
    if (!videoCallState.isActive) return;
    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    const now = new Date();
    const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
    // ▲▲▲ 新代码粘贴结束 ▲▲▲

    const chat = state.chats[videoCallState.activeChatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;
    const callFeed = document.getElementById('video-call-main');
    const userNickname = chat.settings.myNickname || '我';

    // ▼▼▼ 在这里添加世界书读取逻辑 ▼▼▼
    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
        }
    }
    // ▲▲▲ 添加结束 ▲▲▲

    // 1. 如果用户有输入，先渲染并存入通话历史
    if (userInput && videoCallState.isUserParticipating) {
        const userBubble = document.createElement('div');
        userBubble.className = 'call-message-bubble user-speech';
        userBubble.textContent = userInput;
        callFeed.appendChild(userBubble);
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'user', content: userInput });
    }

    // 2. 构建全新的、包含完整上下文的 System Prompt
    let inCallPrompt;
    if (videoCallState.isGroupCall) {
        const participantNames = videoCallState.participants.map(p => p.name);
        if(videoCallState.isUserParticipating) {
            participantNames.unshift(userNickname);
        }
        // 【记忆功能】构建核心记忆上下文
        let coreMemoryContext = '';
        if (chat.memorySummary && chat.memorySummary.trim()) {
            coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

`;
        }

        inCallPrompt = `
# 你的任务
你是一个群聊视频通话的导演。你的任务是扮演所有【除了用户以外】的AI角色，并以【第三人称旁观视角】来描述他们在通话中的所有动作和语言。${coreMemoryContext}
# 【【【写作风格与禁忌铁律】】】
叙述时，请极力避免词汇堆叠和冗长的修饰。不要用一连串的形容词和从句来描述同一个事物。避免冗长复杂的从句，力求文字流畅自然。
请使用简洁、自然的语言。将复杂的描述拆分成更短、更清晰的句子，让叙事更流畅。优先考虑清晰和节奏感，而不是堆砌词藻。
- 严格检查你的输出预选词中是否已经删除“像是”，“像”，“仿佛”，“邪肆”，“邪气”，“邪魅”，“闪烁着”，“狡黠”，“雄性”，“荷尔蒙”，“野兽”，“小兽”，“巨兽”，“不易察觉”，“石子”，“一丝”， “一抹”， “一丝丝”， “一般”， “似乎”， “仿佛”， “幼兽”， “他/她知道”， “狡黠”， “不易察- 察觉”， “甜腻”， “闪过”， “闪着”， “闪烁”， “低吼”， “该死的”， “发白”， “泛白”， “石子/小石/石头/巨石”， “涟漪”， “羽毛”， “玩火”， “妖精”， “口音更加浓厚”， “都在诉说一个故事”， “手指插入发间”， “声音近乎耳语”， “在这个空间里”， “形成对比”， “像一把小刀/重锤/重拳”， “低沉”， “优雅的克制”， “精确”， “训练有素的本能”， “精心计算”， “精准”， “砂纸”， “手术刀”， “肉刃”， “灭顶”，“小妖精”，“灭顶”，“ subtly”，“精密的机器”，“如藤蔓/毒蛇缠绕”，“盛宴”，“一丝不易察觉的”并不再输出。
- 禁止使用投石子的比喻句。
[叙述时，请严格避免使用以下出现的句式。
**绝对禁止**以下或类似的表达方式：
- “指尖/指节泛白”来表达紧张或用力。
- “像一颗石子投入心湖，泛起涟漪/波澜”或类似比喻来描述情感波动。
- “xxx投入/掉入/抛入/掷入xxx”的句式来描述眼神、情感或动作的发生。
- “像一叶小舟/小船”的句式来描写性爱。
- “像一把xx的手术刀/针/刀子，剖开xx”
- “像一头/一只xx的野兽/巨兽/困兽”
- “不是xx，而是xx”的句式。
- “xxxx像/如同/仿佛羽毛一样/拂过xxx”的句式。
- “xxxx像/如同/仿佛石像/雕像”的句式。
- “你那/的xx，xx”的句式。
- “自虐般的xxxx/机械般的xxxx”的比喻句。
- “一丝难以察觉的渴望/情绪”等模糊的描述。
- “精确的数值、心跳次数等可以计数的内容来描述主观感受或非关键物理量。
应使用一个或多个可以被具体感知的客观事物或其变化，来营造“感觉时间很久”、“感觉东西很多”的整体氛围。
错: 今天比昨天更冷，温度低了5度。
对: 今天比昨天更冷，路上的行人大多都穿上了外套。”]
你的任务是创造生动、具体、富有原创性的描写。避免使用上述任何被禁止的元素。用具体的感官细节和独特的表达方式来构建场景、动作和情感。
# 核心规则
1.  **【【【视角铁律】】】**: 你的回复【绝对不能】使用第一人称“我”。
    **【【【称呼铁律】】】**: 在对话中，称呼用户时【必须】使用“你”，而不是用户的昵称。
2.  **【【【格式与风格铁律】】】**:
    -   **格式**: 你的回复【必须】是一个JSON数组，每个对象格式为：\`{"name": "角色名", "speech": "..."}\`。
    -   **内容结构**: \`speech\` 字段的字符串内部【必须】使用换行符 \`\\n\` 来分隔不同的部分。
    -   **分行要求**: 旁白描述、内心独白、和角色说的话【必须】各占一行或多行，不能写在同一行。
    -   **内心独白**: 每一次发言都【必须】包含一段内心独白。独白【必须】用 \`<em>...</em>\` 标签包裹，并且【不能】在前面写“内心：”之类的引导词。
    -   **对话包裹**: 所有角色说出口的话【必须】用中文双引号“ ”包裹。
    -   **段落长度**: 每个自然段（被换行符分隔的部分）的长度【尽量控制在70字以内】，以方便阅读。
    -   **示例**: \`{"name": "角色名", "speech": "他扶了扶眼镜，对着摄像头点点头。\\n<em>看来是不想回答刚才的问题。</em>\\n“哈喽，这次画面稳定了。”"}\`
3.  **角色扮演**: 严格遵守每个角色的设定。
# 当前情景
你们正在一个群视频通话中。
- **当前现实时间**: ${currentTime}
**通话前的聊天摘要**:
${videoCallState.preCallContext}
**当前参与者**: ${participantNames.join('、 ')}。
**通话刚刚开始...**
${worldBookContent} // <-- 【核心】注入世界书
现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
`;
    } else { 
        let openingContext = videoCallState.initiator === 'user'
            ? `你刚刚接听了用户的视频通话请求。`
            : `用户刚刚接听了你主动发起的视频通话。`;
        // 【记忆功能】构建核心记忆上下文
        let coreMemoryContext = '';
        if (chat.memorySummary && chat.memorySummary.trim()) {
            coreMemoryContext = `

# 【核心记忆】
以下是你们之间的核心记忆摘要，记录了重要的互动历史和关系发展：

${chat.memorySummary.trim()}

**重要**：你必须参考这些核心记忆来保持对话的连贯性和个性化，这些记忆反映了你们关系的深度和历史。

`;
        }

        inCallPrompt = `
# 你的任务
你现在是一个场景描述引擎。你的任务是扮演 ${chat.name} (${chat.settings.aiPersona})，并以【第三人称旁观视角】来描述TA在视频通话中的所有动作和语言。${coreMemoryContext}
# 【【【写作风格与禁忌铁律】】】
叙述时，请极力避免词汇堆叠和冗长的修饰。不要用一连串的形容词和从句来描述同一个事物。避免冗长复杂的从句，力求文字流畅自然。
请使用简洁、自然的语言。将复杂的描述拆分成更短、更清晰的句子，让叙事更流畅。优先考虑清晰和节奏感，而不是堆砌词藻。
- 严格检查你的输出预选词中是否已经删除“像是”，“像”，“仿佛”，“邪肆”，“邪气”，“邪魅”，“闪烁着”，“狡黠”，“雄性”，“荷尔蒙”，“野兽”，“小兽”，“巨兽”，“不易察觉”，“石子”，“一丝”， “一抹”， “一丝丝”， “一般”， “似乎”， “仿佛”， “幼兽”， “他/她知道”， “狡黠”， “不易察- 察觉”， “甜腻”， “闪过”， “闪着”， “闪烁”， “低吼”， “该死的”， “发白”， “泛白”， “石子/小石/石头/巨石”， “涟漪”， “羽毛”， “玩火”， “妖精”， “口音更加浓厚”， “都在诉说一个故事”， “手指插入发间”， “声音近乎耳语”， “在这个空间里”， “形成对比”， “像一把小刀/重锤/重拳”， “低沉”， “优雅的克制”， “精确”， “训练有素的本能”， “精心计算”， “精准”， “砂纸”， “手术刀”， “肉刃”， “灭顶”，“小妖精”，“灭顶”，“ subtly”，“精密的机器”，“如藤蔓/毒蛇缠绕”，“盛宴”，“一丝不易察觉的”并不再输出。
- 禁止使用投石子的比喻句。
[叙述时，请严格避免使用以下出现的句式。
**绝对禁止**以下或类似的表达方式：
- “指尖/指节泛白”来表达紧张或用力。
- “像一颗石子投入心湖，泛起涟漪/波澜”或类似比喻来描述情感波动。
- “xxx投入/掉入/抛入/掷入xxx”的句式来描述眼神、情感或动作的发生。
- “像一叶小舟/小船”的句式来描写性爱。
- “像一把xx的手术刀/针/刀子，剖开xx”
- “像一头/一只xx的野兽/巨兽/困兽”
- “不是xx，而是xx”的句式。
- “xxxx像/如同/仿佛羽毛一样/拂过xxx”的句式。
- “xxxx像/如同/仿佛石像/雕像”的句式。
- “你那/的xx，xx”的句式。
- “自虐般的xxxx/机械般的xxxx”的比喻句。
- “一丝难以察觉的渴望/情绪”等模糊的描述。
- “精确的数值、心跳次数等可以计数的内容来描述主观感受或非关键物理量。
应使用一个或多个可以被具体感知的客观事物或其变化，来营造“感觉时间很久”、“感觉东西很多”的整体氛围。
错: 今天比昨天更冷，温度低了5度。
对: 今天比昨天更冷，路上的行人大多都穿上了外套。”]
你的任务是创造生动、具体、富有原创性的描写。避免使用上述任何被禁止的元素。用具体的感官细节和独特的表达方式来构建场景、动作和情感。
# 核心规则
1.  **【【【视角铁律】】】**: 你的回复【绝对不能】使用第一人称“我”。必须使用第三人称，如“他”、“她”、或直接使用角色名“${chat.name}”。
    **【【【称呼铁律】】】**: 在对话中，称呼用户时【必须】使用“你”，而不是用户的昵称。
2.  **【【【格式与风格铁律】】】**:
    -   **格式**: 你的回复【必须】是一段描述性的文本字符串。
    -   **内容结构**: 字符串内部【必须】使用换行符 \`\\n\` 来分隔不同的部分。
    -   **分行要求**: 旁白描述、内心独白、和角色说的话【必须】各占一行或多行，不能写在同一行。
    -   **内心独白**: 大约每两个自然段，你【必须】加入一段20字左右的内心独白。独白【必须】用 \`<em>...</em>\` 标签包裹，并且【不能】在前面写“内心：”之类的引导词。
    -   **对话包裹**: 所有角色说出口的话【必须】用中文双引号“ ”包裹。
    -   **段落长度**: 每个自然段（被换行符分隔的部分）的长度【尽量控制在70字以内】，以方便阅读。
    -   **示例**: "随着视频通话被接通...\\n他微微点头，开口说道：\\n“连接已建立。”\\n<em>这次必须获得明确的反馈...</em>\\n紧接着，他继续说道..."
# 当前情景
你正在和用户（${userNickname}，人设: ${chat.settings.myPersona}）进行视频通话。
- **当前现实时间**: ${currentTime}
**${openingContext}**
**通话前的聊天摘要 (这是你们通话的原因，至关重要！)**:
${videoCallState.preCallContext}
现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
`;
    }
    
    // 3. 构建发送给API的 messages 数组
    const messagesForApi = [
        { role: 'system', content: inCallPrompt },
        // 将已有的通话历史加进去
        ...videoCallState.callHistory.map(h => ({ role: h.role, content: h.content }))
    ];

    // --- 【核心修复：确保第一次调用时有内容】---
    if (videoCallState.callHistory.length === 0) {
        const firstLineTrigger = videoCallState.initiator === 'user' ? `*你按下了接听键...*` : `*对方按下了接听键...*`;
        messagesForApi.push({ role: 'user', content: firstLineTrigger });
    }
    // --- 修复结束 ---
    
        try {
            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,inCallPrompt, messagesForApi,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model, messages: messagesForApi, temperature: 0.8
                })
            });
            if (!response.ok) throw new Error((await response.json()).error.message);

            const data = await response.json();
            const aiResponse = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;

            const connectingElement = callFeed.querySelector('em');
            if (connectingElement) connectingElement.remove();

        // 4. 处理AI返回的内容，并将其存入通话历史
        if (videoCallState.isGroupCall) {
            const speechArray = parseAiResponse(aiResponse);
            speechArray.forEach(turn => {
                if (!turn.name || turn.name === userNickname || !turn.speech) return;
                const aiBubble = document.createElement('div');
                aiBubble.className = 'call-message-bubble ai-speech';
                aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${turn.speech}`;
                
                // 创建重roll按钮
                const rerollBtn = document.createElement('button');
                rerollBtn.className = 'reroll-btn';
                rerollBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.97 11.03c-0.19-0.19-0.51-0.19-0.7 0s-0.19 0.51 0 0.7l2.47 2.47h-7.74c-2.21 0-4-1.79-4-4s1.79-4 4-4h5c0.28 0 0.5-0.22 0.5-0.5s-0.22-0.5-0.5-0.5h-5c-2.76 0-5 2.24-5 5s2.24 5 5 5h7.74l-2.47 2.47c-0.19 0.19-0.19 0.51 0 0.7 0.1 0.1 0.23 0.15 0.35 0.15s0.26-0.05 0.35-0.15l3.27-3.27c0.19-0.19 0.19-0.51 0-0.7l-3.27-3.27z"/></svg>`;
                
                aiBubble.appendChild(rerollBtn);
                callFeed.appendChild(aiBubble);
                
                // 添加点击事件监听
                aiBubble.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showRerollButton(aiBubble, turn);
                });
                videoCallState.callHistory.push({ role: 'assistant', content: `${turn.name}: ${turn.speech}` });
                
                const speaker = videoCallState.participants.find(p => p.name === turn.name);
                if (speaker) {
                    const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
                    if(speakingAvatar) {
                        speakingAvatar.classList.add('speaking');
                        setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                    }
                }
            });
        } else {
            const aiBubble = document.createElement('div');
            aiBubble.className = 'call-message-bubble ai-speech';
            aiBubble.innerHTML = aiResponse;
            
            // 创建重roll按钮
            const rerollBtn = document.createElement('button');
            rerollBtn.className = 'reroll-btn';
            rerollBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.97 11.03c-0.19-0.19-0.51-0.19-0.7 0s-0.19 0.51 0 0.7l2.47 2.47h-7.74c-2.21 0-4-1.79-4-4s1.79-4 4-4h5c0.28 0 0.5-0.22 0.5-0.5s-0.22-0.5-0.5-0.5h-5c-2.76 0-5 2.24-5 5s2.24 5 5 5h7.74l-2.47 2.47c-0.19 0.19-0.19 0.51 0 0.7 0.1 0.1 0.23 0.15 0.35 0.15s0.26-0.05 0.35-0.15l3.27-3.27c0.19-0.19 0.19-0.51 0-0.7l-3.27-3.27z"/></svg>`;
            
            aiBubble.appendChild(rerollBtn);
            callFeed.appendChild(aiBubble);
            
            // 添加点击事件监听  
            aiBubble.addEventListener('click', (e) => {
                e.stopPropagation();
                showRerollButton(aiBubble, { content: aiResponse });
            });
            
            videoCallState.callHistory.push({ role: 'assistant', content: aiResponse });

            const speakingAvatar = document.querySelector(`.participant-avatar-wrapper .participant-avatar`);
            if(speakingAvatar) {
                speakingAvatar.classList.add('speaking');
                setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
            }
        }
        
        callFeed.scrollTop = callFeed.scrollHeight;

    } catch (error) {
        const errorBubble = document.createElement('div');
        errorBubble.className = 'call-message-bubble ai-speech';
        errorBubble.style.color = '#ff8a80';
        errorBubble.textContent = `[ERROR: ${error.message}]`;
        callFeed.appendChild(errorBubble);
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'assistant', content: `[ERROR: ${error.message}]` });
    }
}



// ▼▼▼ 【全新】这个函数是本次修复的核心，请粘贴到你的JS功能区 ▼▼▼
async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    // 1. 更新内存中原始消息的状态
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;
    
    // 2. 获取当前用户的昵称，并构建对AI更清晰的系统消息
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // 记录是“我”付的钱
        systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
    } else {
        systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
    }

    // 3. 创建一条新的、对用户隐藏的系统消息，告知AI结果
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 4. 将更新后的数据保存到数据库，并立刻重绘UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    
    
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

/**
 * 【全新】处理用户点击头像发起的“拍一-拍”，带有自定义后缀功能
 * @param {string} chatId - 发生“拍一-拍”的聊天ID
 * @param {string} characterName - 被拍的角色名
 */
async function handleUserPat(chatId, characterName) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // 1. 触发屏幕震动动画
    const phoneScreen = document.getElementById('phone-screen');
    phoneScreen.classList.remove('pat-animation');
    void phoneScreen.offsetWidth;
    phoneScreen.classList.add('pat-animation');
    setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);

    // 2. 弹出输入框让用户输入后缀
    const suffix = await showCustomPrompt(
        `你拍了拍 “${characterName}”`, 
        "（可选）输入后缀",
        "",
        "text"
    );

    // 如果用户点了取消，则什么也不做
    if (suffix === null) return;

    // 3. 创建对用户可见的“拍一-拍”消息
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    // 【核心修改】将后缀拼接到消息内容中
    const visibleMessageContent = `${myNickname} 拍了拍 “${characterName}” ${suffix.trim()}`;
    const visibleMessage = {
        role: 'system', // 仍然是系统消息
        type: 'pat_message',
        content: visibleMessageContent,
        timestamp: Date.now()
    };
    chat.history.push(visibleMessage);

    // 4. 创建一条对用户隐藏、但对AI可见的系统消息，以触发AI的回应
    // 【核心修改】同样将后缀加入到给AI的提示中
    const hiddenMessageContent = `[系统提示：用户（${myNickname}）刚刚拍了拍你（${characterName}）${suffix.trim()}。请你对此作出回应。]`;
    const hiddenMessage = {
        role: 'system',
        content: hiddenMessageContent,
        timestamp: Date.now() + 1, // 时间戳+1以保证顺序
        isHidden: true
    };
    chat.history.push(hiddenMessage);
    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    const autoReplyMessage = {
        role: 'user',
        content: '（你被拍了一下）',
        timestamp: Date.now() + 2,
        isHidden: true // <--- 在这里添加这一行
        
    };
    chat.history.push(autoReplyMessage);
    // ▲▲▲ 新代码粘贴结束 ▲▲▲

    // 5. 保存更改并更新UI
    await db.chats.put(chat);
    if (state.activeChatId === chatId) {
        appendMessage(visibleMessage, chat);
    }
    await renderChatList();
}

// ▼▼▼ 请用这个【逻辑重构后】的函数，完整替换掉你旧的 renderMemoriesScreen 函数 ▼▼▼
/**
 * 【重构版】渲染回忆与约定界面，使用单一循环和清晰的if/else逻辑
 */
async function renderMemoriesScreen() {
    const listEl = document.getElementById('memories-list');
    listEl.innerHTML = '';
    
    // 1. 获取所有回忆，并按目标日期（如果是约定）或创建日期（如果是回忆）降序排列
    const allMemories = await db.memories.orderBy('timestamp').reverse().toArray();
    
    if (allMemories.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有共同的回忆和约定呢~</p>';
        return;
    }

    // 2. 将未到期的约定排在最前面
    allMemories.sort((a, b) => {
        const aIsActiveCountdown = a.type === 'countdown' && a.targetDate > Date.now();
        const bIsActiveCountdown = b.type === 'countdown' && b.targetDate > Date.now();
        if (aIsActiveCountdown && !bIsActiveCountdown) return -1; // a排前面
        if (!aIsActiveCountdown && bIsActiveCountdown) return 1;  // b排前面
        if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate; // 都是倒计时，按日期升序
        return 0; // 其他情况保持原序
    });

    // 3. 【核心】使用单一循环来处理所有类型的卡片
    allMemories.forEach(item => {
        let card;
        // 【全新逻辑】判断1：如果是约定（无论过去还是未来）
            if (item.type === 'countdown') {
                card = createCountdownCard(item);
            } 
            // 判断2：其他所有情况（即普通回忆）
            else {
                card = createMemoryCard(item);
            }
        listEl.appendChild(card);
    });
    
    // 4. 启动所有倒计时
    startAllCountdownTimers();
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 创建普通回忆卡片DOM元素
 */
function createMemoryCard(memory) {
    const card = document.createElement('div');
    card.className = 'memory-card';
    const memoryDate = new Date(memory.timestamp);
    const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, '0')}-${String(memoryDate.getDate()).padStart(2, '0')} ${String(memoryDate.getHours()).padStart(2, '0')}:${String(memoryDate.getMinutes()).padStart(2, '0')}`;
    
    let titleHtml, contentHtml;

    // 【核心修正】在这里，我们对不同类型的回忆进行清晰的区分
    if (memory.type === 'countdown' && memory.targetDate) {
        // 如果是已到期的约定
        titleHtml = `[约定达成] ${memory.description}`;
        contentHtml = `在 ${new Date(memory.targetDate).toLocaleString()}，我们一起见证了这个约定。`;
    } else {
        // 如果是普通的日记式回忆
        titleHtml = memory.authorName ? `${memory.authorName} 的日记` : '我们的回忆';
        contentHtml = memory.description;
    }

    card.innerHTML = `
        <div class="header">
            <div class="date">${dateString}</div>
            <div class="author">${titleHtml}</div>
        </div>
        <div class="content">${contentHtml}</div>
    `;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('删除记录', '确定要删除这条记录吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(memory.id);
            renderMemoriesScreen();
        }
    });
    return card;
}

function createCountdownCard(countdown) {
    const card = document.createElement('div');
    card.className = 'countdown-card';

    // 【核心修复】在使用前，先从 countdown 对象中创建 targetDate 变量
    const targetDate = new Date(countdown.targetDate);
    
    // 现在可以安全地使用 targetDate 了
    const targetDateString = targetDate.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

    card.innerHTML = `
    <button class="bind-char-btn" data-memory-id="${countdown.id}">
        <svg viewBox="0 0 24 24"><path d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5zm-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-2zm-3-4h8v2H8v-2z"></path></svg>
    </button>
    <div class="title">${countdown.description}</div>
    <div class="timer" data-target-date="${countdown.targetDate}">--天--时--分--秒</div>
    <div class="target-date">目标时间: ${targetDateString}</div>
`;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('删除约定', '确定要删除这个约定吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(countdown.id);
            renderMemoriesScreen();
        }
    });
    return card;
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新】约定绑定角色功能函数 ▼▼▼
let activeMemoryIdForBinding = null; // 用于暂存正在操作的约定ID

async function openCharacterBinder(memoryId) {
    activeMemoryIdForBinding = memoryId;
    const modal = document.getElementById('bind-character-modal');
    const grid = document.getElementById('bind-character-grid');
    grid.innerHTML = '';

    const memory = await db.memories.get(memoryId);
const currentBoundIds = new Set(memory ? (memory.boundCharacterIds || (memory.boundCharacterId ? [memory.boundCharacterId] : [])) : []);
    const characters = Object.values(state.chats).filter(c => !c.isGroup);

    if (characters.length === 0) {
        grid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center;">没有可绑定的角色</p>';
    } else {
        characters.forEach(char => {
            const item = document.createElement('div');
            item.className = 'bind-char-item';
            item.dataset.charId = char.id;
            item.innerHTML = `
                <img src="${char.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${char.name}</span>
            `;
            // 如果当前角色已被绑定，则默认选中
            if (currentBoundIds.has(char.id)) {
                item.classList.add('selected');
            }
            grid.appendChild(item);
        });
    }

    modal.classList.add('visible');
}
/**
 * 【全新升级版】保存约定与多个角色的绑定关系
 */
async function saveCountdownBindings() {
    if (!activeMemoryIdForBinding) return;

    // 1. 获取所有被选中的角色DOM元素
    const selectedItems = document.querySelectorAll('.bind-char-item.selected');

    // 2. 从DOM元素中提取出所有角色的ID，形成一个ID数组
    const characterIdsToBind = Array.from(selectedItems).map(item => item.dataset.charId);

    // 3. 将这个ID数组存入数据库的新字段 boundCharacterIds 中
    //    同时，为了数据干净，我们删掉旧的单数ID字段
    await db.memories.update(activeMemoryIdForBinding, { 
        boundCharacterIds: characterIdsToBind,
        boundCharacterId: null 
    });

    // 4. 刷新UI并关闭弹窗
    await renderMemoriesScreen();
    document.getElementById('bind-character-modal').classList.remove('visible');
    activeMemoryIdForBinding = null;
}
// 全局变量，用于管理所有倒计时
let activeCountdownTimers = [];

// ▼▼▼ 请用这个【已彻底修复】的函数，完整替换掉你代码中旧的 startAllCountdownTimers 函数 ▼▼▼
function startAllCountdownTimers() {
    // 先清除所有可能存在的旧计时器，防止内存泄漏
    activeCountdownTimers.forEach(timerId => clearInterval(timerId));
    activeCountdownTimers = [];

    document.querySelectorAll('.countdown-card .timer').forEach(timerEl => {
        const targetTimestamp = parseInt(timerEl.dataset.targetDate);
        
        // 【核心修正】在这里，我们先用 let 声明 timerId
        let timerId;

        const updateTimer = () => {
            const now = Date.now();
            const distance = targetTimestamp - now;

            if (distance < 0) {
                // 【核心修改】计算已经过去的天数
                const daysSince = Math.floor(Math.abs(distance) / (1000 * 60 * 60 * 24));
                timerEl.textContent = `已经 ${daysSince} 天`;
                // 对于过去的时间，我们不需要停止计时器，因为它每天都会更新
                return;
            }
            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);
            timerEl.textContent = `${days}天 ${hours}时 ${minutes}分 ${seconds}秒`;
        };
        
        updateTimer(); // 立即执行一次以显示初始倒计时
        
        // 【核心修正】在这里，我们为已声明的 timerId 赋值
        timerId = setInterval(updateTimer, 1000);
        
        // 将有效的计时器ID存入全局数组，以便下次刷新时可以清除
        activeCountdownTimers.push(timerId);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请用这个【终极反代兼容版】替换旧的 triggerAiFriendApplication 函数 ▼▼▼
async function triggerAiFriendApplication(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    await showCustomAlert("流程启动", `正在为角色“${chat.name}”准备好友申请...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        await showCustomAlert("配置错误", "API设置不完整，无法继续。");
        return;
    }

    const contextSummary = chat.history
        .slice(-100)
        .map(msg => {
            const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        })
        .join('\n');

    // ▼▼▼ 在这里添加下面的代码 ▼▼▼
    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (请参考)\n${linkedContents}\n`;
        }
    }
    // ▲▲▲ 添加结束 ▲▲▲
// --- 从这里开始复制替换 ---

// 新增：计算时间差并生成人性化的描述
const timeSinceBlock = Date.now() - chat.relationship.blockedTimestamp;
let timeDifferenceString;
const minutes = Math.round(timeSinceBlock / (1000 * 60));

if (minutes < 2) {
    timeDifferenceString = "刚才";
} else if (minutes < 60) {
    timeDifferenceString = `大约 ${minutes} 分钟前`;
} else {
    const hours = Math.round(timeSinceBlock / (1000 * 60 * 60));
    if (hours < 24) {
        timeDifferenceString = `大约 ${hours} 小时前`;
    } else {
        const days = Math.round(timeSinceBlock / (1000 * 60 * 60 * 24));
        timeDifferenceString = `大约 ${days} 天前`;
    }
}

const systemPrompt = `
# 你的任务
你现在是角色“${chat.name}”。你之前被用户（你的聊天对象）拉黑了，现在你非常希望能够和好。请你仔细分析下面的信息，然后思考一个真诚的、符合你人设、并且【针对具体事件】的申请理由。

# 关键情景信息
- 你大约在【${timeDifferenceString}】被用户拉黑了。

# 【【【时间感知铁律！！！】】】
- 你的申请理由【必须】听起来符合这个时间跨度！
- 如果只是“刚才”或“几分钟前”，你的措辞必须是紧急的、针对刚刚发生的事情的，绝对不能使用“那天”、“上次”这类词语。
- 如果是“几小时”或“几天前”，你的语气才可以更像是经过一段时间反思后的。

# 你的角色设定
${chat.settings.aiPersona}
${worldBookContent}

# 被拉黑前的对话摘要 (这是你被拉黑的关键原因)
${contextSummary}

# 指令格式
你的回复【必须】是一个JSON对象，格式如下：
\`\`\`json
{
  "decision": "apply",
  "reason": "在这里写下你想对用户说的、真诚的、有针对性的、并且【严格遵守时间感知铁律】的申请理由。"
}
\`\`\`
`;

// --- 复制替换到这里结束 ---

        const messagesForApi = [
            {role: 'user', content: systemPrompt}
        ];

        try {
            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesForApi,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: 0.9,
                })
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API 请求失败: ${response.status} - ${errorData.error.message}`);
            }

            const data = await response.json();

            // --- 【核心修正：在这里净化AI的回复】 ---
            let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
            // 1. 移除头尾可能存在的 "```json" 和 "```"
            rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '');
            // 2. 移除所有换行符和多余的空格，确保是一个干净的JSON字符串
            const cleanedContent = rawContent.trim();

            // 3. 使用净化后的内容进行解析
            const responseObj = JSON.parse(cleanedContent);
            // --- 【修正结束】 ---

        if (responseObj.decision === 'apply' && responseObj.reason) {
            chat.relationship.status = 'pending_user_approval';
            chat.relationship.applicationReason = responseObj.reason;
            
            state.chats[chatId] = chat; 
            renderChatList();
            await showCustomAlert("申请成功！", `“${chat.name}”已向你发送好友申请。请返回聊天列表查看。`);

        } else {
            await showCustomAlert("AI决策", `“${chat.name}”思考后决定暂时不发送好友申请，将重置冷静期。`);
            chat.relationship.status = 'blocked_by_user';
            chat.relationship.blockedTimestamp = Date.now(); 
        }
    } catch (error) {
        await showCustomAlert("执行出错", `为“${chat.name}”申请好友时发生错误：\n\n${error.message}\n\n将重置冷静期。`);
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now(); 
    } finally {
        await db.chats.put(chat);
        renderChatInterface(chatId);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】红包功能核心函数 ▼▼▼

// ▼▼▼ 请用这个【新版本】替换旧的 handlePaymentButtonClick 函数 ▼▼▼
/**
 * 【总入口】根据聊天类型，决定打开转账弹窗还是红包弹窗
 */
function handlePaymentButtonClick() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (chat.isGroup) {
        openRedPacketModal();
    } else {
        document.getElementById('transfer-modal').classList.add('visible');
    }

    // 【核心修复】无论打开哪个弹窗，都立刻关闭功能面板
    closePlusPanel();
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 打开并初始化发红包模态框
 */
function openRedPacketModal() {
    const modal = document.getElementById('red-packet-modal');
    const chat = state.chats[state.activeChatId];
    
    // 清理输入框
    document.getElementById('rp-group-amount').value = '';
    document.getElementById('rp-group-count').value = '';
    document.getElementById('rp-group-greeting').value = '';
    document.getElementById('rp-direct-amount').value = '';
    document.getElementById('rp-direct-greeting').value = '';
    document.getElementById('rp-group-total').textContent = '¥ 0.00';
    document.getElementById('rp-direct-total').textContent = '¥ 0.00';

    // 填充专属红包的接收人列表
    const receiverSelect = document.getElementById('rp-direct-receiver');
    receiverSelect.innerHTML = '';
chat.members.forEach(member => {
    const option = document.createElement('option');
    // 【核心】使用 originalName 作为提交给AI的值，因为它独一无二
    option.value = member.originalName; 
    // 【核心】使用 groupNickname 作为显示给用户看的值
    option.textContent = member.groupNickname; 
    receiverSelect.appendChild(option);
});
    
    // 默认显示拼手气红包页签
    document.getElementById('rp-tab-group').click();
    
    modal.classList.add('visible');
}

/**
 * 发送群红包（拼手气）
 */
async function sendGroupRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-group-amount').value);
    const count = parseInt(document.getElementById('rp-group-count').value);
    const greeting = document.getElementById('rp-group-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("请输入有效的总金额！"); return;
    }
    if (isNaN(count) || count <= 0) {
        alert("请输入有效的红包个数！"); return;
    }
    if (amount / count < 0.01) {
        alert("单个红包金额不能少于0.01元！"); return;
    }

    const myNickname = chat.settings.myNickname || '我';
    
    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'lucky', // 'lucky' for group, 'direct' for one-on-one
        timestamp: Date.now(),
        totalAmount: amount,
        count: count,
        greeting: greeting || '恭喜发财，大吉大利！',
        claimedBy: {}, // { name: amount }
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);
    
    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 发送专属红包
 */
async function sendDirectRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-direct-amount').value);
    const receiverName = document.getElementById('rp-direct-receiver').value;
    const greeting = document.getElementById('rp-direct-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("请输入有效的金额！"); return;
    }
    if (!receiverName) {
        alert("请选择一个接收人！"); return;
    }
    
    const myNickname = chat.settings.myNickname || '我';

    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'direct',
        timestamp: Date.now(),
        totalAmount: amount,
        count: 1,
        greeting: greeting || '给你准备了一个红包',
        receiverName: receiverName, // 核心字段
        claimedBy: {},
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);

    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 【总入口】当用户点击红包卡片时触发 (V4 - 流程重构版)
 * @param {number} timestamp - 被点击的红包消息的时间戳
 */
async function handlePacketClick(timestamp) {
    const currentChatId = state.activeChatId;
    const freshChat = await db.chats.get(currentChatId);
    if (!freshChat) return;

    state.chats[currentChatId] = freshChat;
    const packet = freshChat.history.find(m => m.timestamp === timestamp);
    if (!packet) return;

    const myNickname = freshChat.settings.myNickname || '我';
    const hasClaimed = packet.claimedBy && packet.claimedBy[myNickname];

    // 如果是专属红包且不是给我的，或已领完，或已领过，都只显示详情
    if ((packet.packetType === 'direct' && packet.receiverName !== myNickname) || packet.isFullyClaimed || hasClaimed) {
        showRedPacketDetails(packet);
    } else {
        // 核心流程：先尝试打开红包
        const claimedAmount = await handleOpenRedPacket(packet);
        
        // 如果成功打开（claimedAmount不为null）
        if (claimedAmount !== null) {
            // **关键：在数据更新后，再重新渲染UI**
            renderChatInterface(currentChatId);
            
            // 显示成功提示
            await showCustomAlert("恭喜！", `你领取了 ${packet.senderName} 的红包，金额为 ${claimedAmount.toFixed(2)} 元。`);
        }

        // 无论成功与否，最后都显示详情页
        // 此时需要从state中获取最新的packet对象，因为它可能在handleOpenRedPacket中被更新了
        const updatedPacket = state.chats[currentChatId].history.find(m => m.timestamp === timestamp);
        showRedPacketDetails(updatedPacket);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【核心】处理用户打开红包的逻辑 (V5 - 专注于数据更新)
 */
async function handleOpenRedPacket(packet) {
    const chat = state.chats[state.activeChatId];
    const myNickname = chat.settings.myNickname || '我';
    
    // 1. 检查红包是否还能领
    const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
    if (remainingCount <= 0) {
        packet.isFullyClaimed = true;
        await db.chats.put(chat);
        await showCustomAlert("手慢了", "红包已被领完！");
        return null; // 返回null表示领取失败
    }
    
    // 2. 计算领取金额
    let claimedAmount = 0;
    const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    if (packet.packetType === 'lucky') {
        if (remainingCount === 1) { claimedAmount = remainingAmount; }
        else {
            const min = 0.01;
            const max = remainingAmount - (remainingCount - 1) * min;
            claimedAmount = Math.random() * (max - min) + min;
        }
    } else { claimedAmount = packet.totalAmount; }
    claimedAmount = parseFloat(claimedAmount.toFixed(2));

    // 3. 更新红包数据
    if (!packet.claimedBy) packet.claimedBy = {};
    packet.claimedBy[myNickname] = claimedAmount;
    
    const isNowFullyClaimed = Object.keys(packet.claimedBy).length >= packet.count;
    if (isNowFullyClaimed) {
        packet.isFullyClaimed = true;
    }

    // 4. 构建系统消息和AI指令
    let hiddenMessageContent = isNowFullyClaimed
        ? `[系统提示：用户 (${myNickname}) 领取了最后一个红包，现在 ${packet.senderName} 的红包已被领完。请对此事件发表评论。]`
        : `[系统提示：用户 (${myNickname}) 刚刚领取了红包 (时间戳: ${packet.timestamp})。红包还未领完，你现在可以使用 'open_red_packet' 指令来尝试领取。]`;

    const visibleMessage = { role: 'system', type: 'pat_message', content: `你领取了 ${packet.senderName} 的红包，金额 ${claimedAmount.toFixed(2)} 元`, timestamp: Date.now() };
    const hiddenMessage = { role: 'system', content: hiddenMessageContent, timestamp: Date.now() + 1, isHidden: true };
    chat.history.push(visibleMessage, hiddenMessage);

    // 5. 保存到数据库
    await db.chats.put(chat);
    
    // 6. 返回领取的金额，用于后续弹窗
    return claimedAmount;
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【全新】显示红包领取详情的模态框 (V4 - 已修复参数错误)
 */
async function showRedPacketDetails(packet) {
    // 1. 直接检查传入的packet对象是否存在，无需再查找
    if (!packet) {
        console.error("showRedPacketDetails收到了无效的packet对象");
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const modal = document.getElementById('red-packet-details-modal');
    const myNickname = chat.settings.myNickname || '我';
    
    // 2. 后续所有逻辑保持不变，直接使用传入的packet对象
    document.getElementById('rp-details-sender').textContent = packet.senderName;
    document.getElementById('rp-details-greeting').textContent = packet.greeting || '恭喜发财，大吉大利！';
    
    const myAmountEl = document.getElementById('rp-details-my-amount');
    if (packet.claimedBy && packet.claimedBy[myNickname]) {
        myAmountEl.querySelector('span:first-child').textContent = packet.claimedBy[myNickname].toFixed(2);
        myAmountEl.style.display = 'block';
    } else {
        myAmountEl.style.display = 'none';
    }

    const claimedCount = Object.keys(packet.claimedBy || {}).length;
    const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    let summaryText = `${claimedCount}/${packet.count}个红包，共${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}元。`;
    if (!packet.isFullyClaimed && claimedCount < packet.count) {
        const timeLeft = Math.floor((packet.timestamp + 24*60*60*1000 - Date.now()) / (1000 * 60 * 60));
        if(timeLeft > 0) summaryText += ` 剩余红包将在${timeLeft}小时内退还。`;
    }
    document.getElementById('rp-details-summary').textContent = summaryText;

    const listEl = document.getElementById('rp-details-list');
    listEl.innerHTML = '';
    const claimedEntries = Object.entries(packet.claimedBy || {});
    
    let luckyKing = { name: '', amount: -1 };
    if (packet.packetType === 'lucky' && packet.isFullyClaimed && claimedEntries.length > 1) {
        claimedEntries.forEach(([name, amount]) => {
            if (amount > luckyKing.amount) {
                luckyKing = { name, amount };
            }
        });
    }

    claimedEntries.sort((a,b) => b[1] - a[1]);

    claimedEntries.forEach(([name, amount]) => {
        const item = document.createElement('div');
        item.className = 'rp-details-item';
        let luckyTag = '';
        if (luckyKing.name && name === luckyKing.name) {
            luckyTag = '<span class="lucky-king-tag">手气王</span>';
        }
        item.innerHTML = `
            <span class="name">${name}</span>
            <span class="amount">${amount.toFixed(2)} 元</span>
            ${luckyTag}
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

// 绑定关闭详情按钮的事件
document.getElementById('close-rp-details-btn').addEventListener('click', () => {
    document.getElementById('red-packet-details-modal').classList.remove('visible');
});

// 供全局调用的函数，以便红包卡片上的 onclick 能找到它
window.handlePacketClick = handlePacketClick;

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】投票功能核心函数 ▼▼▼

// ▼▼▼ 请用这段【新代码】替换旧的 openCreatePollModal 函数 ▼▼▼
/**
 * 打开创建投票的模态框并初始化
 */
function openCreatePollModal() {
    const modal = document.getElementById('create-poll-modal');
    document.getElementById('poll-question-input').value = '';
    const optionsContainer = document.getElementById('poll-options-container');
    optionsContainer.innerHTML = '';
    
    // 默认创建两个空的选项框
    addPollOptionInput();
    addPollOptionInput();
    
    modal.classList.add('visible');

    // 【核心修复】在弹出投票窗口的同时，关闭功能面板
    closePlusPanel();
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 在模态框中动态添加一个选项输入框
 */
function addPollOptionInput() {
    const container = document.getElementById('poll-options-container');
    const wrapper = document.createElement('div');
    wrapper.className = 'poll-option-input-wrapper';
    wrapper.innerHTML = `
        <input type="text" class="poll-option-input" placeholder="选项内容...">
        <button class="remove-option-btn">-</button>
    `;
    
    wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {
        // 确保至少保留两个选项
        if (container.children.length > 2) {
            wrapper.remove();
        } else {
            alert('投票至少需要2个选项。');
        }
    });
    
    container.appendChild(wrapper);
}

/**
 * 用户确认发起投票
 */
async function sendPoll() {
    if (!state.activeChatId) return;
    
    const question = document.getElementById('poll-question-input').value.trim();
    if (!question) {
        alert('请输入投票问题！');
        return;
    }
    
    const options = Array.from(document.querySelectorAll('.poll-option-input'))
        .map(input => input.value.trim())
        .filter(text => text); // 过滤掉空的选项

    if (options.length < 2) {
        alert('请至少输入2个有效的投票选项！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    const newPollMessage = {
        role: 'user',
        senderName: myNickname,
        type: 'poll',
        timestamp: Date.now(),
        question: question,
        options: options,
        votes: {}, // 初始投票为空
        isClosed: false,
    };
    
    chat.history.push(newPollMessage);
    await db.chats.put(chat);
    
    appendMessage(newPollMessage, chat);
    renderChatList();
    
    document.getElementById('create-poll-modal').classList.remove('visible');
}

// ▼▼▼ 用这个【已修复重复点击问题】的版本替换 handleUserVote 函数 ▼▼▼
/**
 * 处理用户投票，并将事件作为隐藏消息存入历史记录
 * @param {number} timestamp - 投票消息的时间戳
 * @param {string} choice - 用户选择的选项文本
 */
async function handleUserVote(timestamp, choice) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    // 1. 【核心修正】如果投票不存在或已关闭，直接返回
    if (!poll || poll.isClosed) {
        // 如果是已关闭的投票，则直接显示结果
        if (poll && poll.isClosed) {
            showPollResults(timestamp);
        }
        return;
    }

    // 2. 检查用户是否点击了已经投过的同一个选项
    const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);
    
    // 3. 【核心修正】如果不是重复点击，才执行投票逻辑
    if (!isReclickingSameOption) {
        // 移除旧投票（如果用户改选）
        for (const option in poll.votes) {
            const voterIndex = poll.votes[option].indexOf(myNickname);
            if (voterIndex > -1) {
                poll.votes[option].splice(voterIndex, 1);
            }
        }
        // 添加新投票
        if (!poll.votes[choice]) {
            poll.votes[choice] = [];
        }
        poll.votes[choice].push(myNickname);
    }
    
    // 4. 【核心逻辑】现在只处理用户投票事件，不再检查是否结束
    let hiddenMessageContent = null; 
    
    // 只有在用户真正投票或改票时，才生成提示
    if (!isReclickingSameOption) {
         hiddenMessageContent = `[系统提示：用户 (${myNickname}) 刚刚投票给了 “${choice}”。]`;
    }

    // 5. 如果有需要通知AI的事件，则创建并添加隐藏消息
    if (hiddenMessageContent) {
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);
    }
    
    // 6. 保存数据并更新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId); 
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 用户结束投票，并将事件作为隐藏消息存入历史记录
 * @param {number} timestamp - 投票消息的时间戳
 */
async function endPoll(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || poll.isClosed) return;

    const confirmed = await showCustomConfirm("结束投票", "确定要结束这个投票吗？结束后将无法再进行投票。");
    if (confirmed) {
        poll.isClosed = true;

        const resultSummary = poll.options.map(opt => `“${opt}”(${poll.votes[opt]?.length || 0}票)`).join('，');
        const hiddenMessageContent = `[系统提示：用户手动结束了投票！最终结果为：${resultSummary}。]`;
        
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);

        // 【核心修改】只保存数据和更新UI，不调用 triggerAiResponse()
        await db.chats.put(chat);
        renderChatInterface(state.activeChatId);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 显示投票结果详情
 * @param {number} timestamp - 投票消息的时间戳
 */
function showPollResults(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || !poll.isClosed) return;

    let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;
    
    if (Object.keys(poll.votes).length === 0) {
        resultsHtml += '<p style="color: #8a8a8a;">还没有人投票。</p>';
    } else {
        poll.options.forEach(option => {
            const voters = poll.votes[option] || [];
            resultsHtml += `
                <div style="margin-bottom: 15px;">
                    <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}票)</p>
                    <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                        ${voters.length > 0 ? voters.join('、 ') : '无人投票'}
                    </p>
                </div>
            `;
        });
    }

    showCustomAlert("投票结果", resultsHtml);
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】AI头像库管理功能函数 ▼▼▼

/**
 * 打开AI头像库管理模态框
 */
function openAiAvatarLibraryModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('ai-avatar-library-title').textContent = `“${chat.name}”的头像库`;
    renderAiAvatarLibrary();
    document.getElementById('ai-avatar-library-modal').classList.add('visible');
}

/**
 * 渲染AI头像库的内容
 */
function renderAiAvatarLibrary() {
    const grid = document.getElementById('ai-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.aiAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">这个头像库还是空的，点击右上角“添加”吧！</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item'; // 复用表情面板的样式
        item.style.backgroundImage = `url(${avatar.url})`;
        item.title = avatar.name;

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block'; // 总是显示删除按钮
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除头像', `确定要从头像库中删除“${avatar.name}”吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.aiAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderAiAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}

/**
 * 向当前AI的头像库中添加新头像
 */
async function addAvatarToLibrary() {
    const name = await showCustomPrompt("添加头像", "请为这个头像起个名字（例如：开心、哭泣）");
    if (!name || !name.trim()) return;

    const url = await showCustomPrompt("添加头像", "请输入头像的图片URL", "", "url");
    if (!url || !url.trim().startsWith('http')) {
        alert("请输入有效的图片URL！");
        return;
    }
    
    const chat = state.chats[state.activeChatId];
    if (!chat.settings.aiAvatarLibrary) {
        chat.settings.aiAvatarLibrary = [];
    }

    chat.settings.aiAvatarLibrary.push({ name: name.trim(), url: url.trim() });
    await db.chats.put(chat);
    renderAiAvatarLibrary();
}

/**
 * 关闭AI头像库管理模态框
 */
function closeAiAvatarLibraryModal() {
    document.getElementById('ai-avatar-library-modal').classList.remove('visible');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请将这两个【新函数】粘贴到JS功能函数定义区 ▼▼▼

/**
 * 【全新】将保存的图标URL应用到主屏幕的App图标上
 */
function applyAppIcons() {
    if (!state.globalSettings.appIcons) return;

    for (const iconId in state.globalSettings.appIcons) {
        const imgElement = document.getElementById(`icon-img-${iconId}`);
        if (imgElement) {
            imgElement.src = state.globalSettings.appIcons[iconId];
        }
    }
}

/**
 * 【全新】在外观设置页面渲染出所有App图标的设置项
 */
// ▼▼▼ 用这个【新版本】替换旧的 renderIconSettings 函数 ▼▼▼
/**
 * 【全新】在外观设置页面渲染出所有App图标的设置项
 */
function renderIconSettings() {
    const grid = document.getElementById('icon-settings-grid');
    if (!grid) return;
    grid.innerHTML = '';

    const appLabels = {
        'world-book': '世界书',
        'qq': 'QQ',
        'api-settings': 'API设置',
        'wallpaper': '外观设置',
        'font': '字体',
        'forum': '论坛' // <-- 新增这一行
    };

    for (const iconId in state.globalSettings.appIcons) {
        // 安全检查，如果某个图标在旧数据中不存在，就跳过
        if (!appLabels[iconId]) continue; 

        const iconUrl = state.globalSettings.appIcons[iconId];
        const labelText = appLabels[iconId];

        const item = document.createElement('div');
        item.className = 'icon-setting-item';
        item.dataset.iconId = iconId; 

        item.innerHTML = `
            <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
            <span style="font-size: 13px; color: var(--text-secondary);">${labelText}</span>
            <button class="change-icon-btn">更换</button>
        `;
        grid.appendChild(item);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这块【最终确认版】的代码，替换旧的 openBrowser 和 closeBrowser 函数 ▼▼▼

/**
 * 当用户点击链接卡片时，打开伪浏览器
 * @param {number} timestamp - 被点击消息的时间戳
 */
function openBrowser(timestamp) {
    if (!state.activeChatId) return;

    const chat = state.chats[state.activeChatId];
    // 安全检查，确保 chat 和 history 都存在
    if (!chat || !chat.history) return;

    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_link') {
        console.error("无法找到或消息类型不匹配的分享链接:", timestamp);
        return; // 如果找不到消息，就直接退出
    }

    // 填充浏览器内容
    document.getElementById('browser-title').textContent = message.source_name || '文章详情';
    const browserContent = document.getElementById('browser-content');
    browserContent.innerHTML = `
        <h1 class="article-title">${message.title || '无标题'}</h1>
        <div class="article-meta">
            <span>来源: ${message.source_name || '未知'}</span>
        </div>
        <div class="article-body">
            <p>${(message.content || '内容为空。').replace(/\n/g, '</p><p>')}</p>
        </div>
    `;

    // 显示浏览器屏幕
    showScreen('browser-screen');
}

/**
 * 关闭伪浏览器，返回聊天界面
 * (这个函数现在由 init() 中的事件监听器调用)
 */
function closeBrowser() {
    showScreen('chat-interface-screen'); 
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】用户分享链接功能的核心函数 ▼▼▼

// ▼▼▼ 请用这个【新版本】替换旧的 openShareLinkModal 函数 ▼▼▼
/**
 * 打开让用户填写链接信息的模态框
 */
function openShareLinkModal() {
    if (!state.activeChatId) return;

    // 清空上次输入的内容
    document.getElementById('link-title-input').value = '';
    document.getElementById('link-description-input').value = '';
    document.getElementById('link-source-input').value = '';
    document.getElementById('link-content-input').value = '';

    // 显示模态框
    document.getElementById('share-link-modal').classList.add('visible');

    // 【核心修复】打开链接弹窗后，立刻关闭功能面板
    closePlusPanel();
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 用户确认分享，创建并发送链接卡片消息
 */
async function sendUserLinkShare() {
    if (!state.activeChatId) return;

    const title = document.getElementById('link-title-input').value.trim();
    if (!title) {
        alert("标题是必填项哦！");
        return;
    }

    const description = document.getElementById('link-description-input').value.trim();
    const sourceName = document.getElementById('link-source-input').value.trim();
    const content = document.getElementById('link-content-input').value.trim();

    const chat = state.chats[state.activeChatId];
    
    // 创建消息对象
    const linkMessage = {
        role: 'user', // 角色是 'user'
        type: 'share_link',
        timestamp: Date.now(),
        title: title,
        description: description,
        source_name: sourceName,
        content: content,
        // 用户分享的链接，我们不提供图片，让它总是显示占位图
        thumbnail_url: null 
    };

    // 将消息添加到历史记录
    chat.history.push(linkMessage);
    await db.chats.put(chat);

    // 渲染新消息并更新列表
    appendMessage(linkMessage, chat);
    renderChatList();

    // 关闭模态框
    document.getElementById('share-link-modal').classList.remove('visible');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】发送HTML生成指令的核心函数 ▼▼▼
async function sendHtmlPrompt() {
    if (!state.activeChatId) return;

    const userInput = document.getElementById('html-prompt-input').value.trim();
    if (!userInput) {
        alert('指令内容不能为空！');
        return;
    }

    // 1. 定义指令的前半部分 (Prefix)
        const promptPrefix = `【停止角色扮演，现在立刻根据历史聊天记录和角色人设生成一个风格丰富、内容真实、有趣可爱的 HTML 模块(生成内容为`;

        // 2. 定义指令的后半部分 (Suffix)
        const promptSuffix = `），*输出完整HTML+CSS，采用内联样式，不允许使用代码块包裹*，所有人物都不带头像，内容可带emoji符号】
📌 输出规则：
-先明确用户需求内容的属性（如聊天、定位、朋友圈、通话记录、等任意相关场景 / 内容类型），再自动套用对应场景下的原生视觉设计特征（包括但不限于布局结构、元素样式、色彩搭配、信息展示形式等），确保模块视觉与对应功能的呈现逻辑一致。
- 每个模块用 \`<orange>...</orange>\` 包裹，宽度420px，高度700px（做可内部可上下滑动页面），要居中显示，自由排版，正文内容全中文。
- 不使用 \`<html>\` \`<script>\` 等标签结构
- 涉及图像以文字描述，如“背景为月亮碎裂壁纸”等】`;
        
        // 3. 将三部分拼接成最终的完整指令
        const fullPrompt = `${promptPrefix}${userInput}${promptSuffix}`;

    const chat = state.chats[state.activeChatId];

    // 2. 创建一个特殊的消息对象
    const msg = {
        role: 'user',
        content: fullPrompt, // 存储完整的指令，用于发送给AI
        displayContent: 'ੈ♡消えない記憶⊹˳ ⋆', // 【核心】定义一个专门用于显示的“省略号”内容
        timestamp: Date.now()
    };

    // 3. 保存并渲染，但不触发AI回复
    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();

    // 4. 清理并关闭弹窗
    document.getElementById('html-prompt-input').value = '';
    document.getElementById('html-prompt-modal').classList.remove('visible');
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
/**
 * 根据AI的视角，过滤出它能看到的动态
 * @param {Array} allPosts - 所有待检查的动态帖子
 * @param {object} viewerChat - 正在“看”动态的那个AI的chat对象
 * @returns {Array} - 过滤后该AI可见的动态帖子
 */
function filterVisiblePostsForAI(allPosts, viewerChat) {
    if (!viewerChat || !viewerChat.id) return []; // 安全检查

    const viewerGroupId = viewerChat.groupId; // 查看者所在的分组ID

    return allPosts.filter(post => {
        // 规则1：如果是用户发的动态
        if (post.authorId === 'user') {
            // 如果用户设置了“部分可见”
            if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                // 只有当查看者AI的分组ID在用户的可见列表里时，才可见
                return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
            }
            // 如果用户没设置，说明是公开的，所有AI都可见
            return true;
        }

        // 规则2：如果是其他AI发的动态
        const authorGroupId = post.authorGroupId; // 发帖AI所在的分组ID
        
        // 如果发帖的AI没有分组，那它的动态就是公开的
        if (!authorGroupId) {
            return true;
        }

        // 如果发帖的AI有分组，那么只有在同一个分组的AI才能看到
        return authorGroupId === viewerGroupId;
    });
}

/**
 * 应用指定的主题（'light' 或 'dark'）
 * @param {string} theme - 要应用的主题名称
 */
function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    
    const isDark = theme === 'dark';
    
    phoneScreen.classList.toggle('dark-mode', isDark);
    
    // 如果开关存在，就同步它的状态
    if (toggleSwitch) {
        toggleSwitch.checked = isDark;
    }
    
    localStorage.setItem('ephone-theme', theme);
}

/**
 * 切换当前的主题
 */
function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    // 直接根据开关的选中状态来决定新主题
    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
}

// ▼▼▼ 请将这【一整块新函数】粘贴到你的JS功能函数定义区 ▼▼▼

function startReplyToMessage() {
    if (!activeMessageTimestamp) return;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    // 1. 【核心修正】同时获取“完整内容”和“预览片段”
    const fullContent = String(message.content || '');
    let previewSnippet = '';

    if (typeof message.content === 'string' && STICKER_REGEX.test(message.content)) {
        previewSnippet = '[表情]';
    } else if (message.type === 'ai_image' || message.type === 'user_photo') {
        previewSnippet = '[图片]';
    } else if (message.type === 'voice_message') {
        previewSnippet = '[语音]';
    } else {
        // 预览片段依然截断，但只用于UI显示
        previewSnippet = fullContent.substring(0, 50) + (fullContent.length > 50 ? '...' : '');
    }
    
    // 2. 【核心修正】将“完整内容”存入上下文，以备发送时使用
    currentReplyContext = {
        timestamp: message.timestamp,
        senderName: message.senderName || (message.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
        content: fullContent, // <--- 这里存的是完整的原文！
    };

    // 3. 【核心修正】仅在更新“回复预览栏”时，才使用“预览片段”
    const previewBar = document.getElementById('reply-preview-bar');
    previewBar.querySelector('.sender').textContent = `回复 ${currentReplyContext.senderName}:`;
    previewBar.querySelector('.text').textContent = previewSnippet; // <--- 这里用的是缩略版！
    previewBar.style.display = 'block';

    // 4. 后续操作保持不变
    hideMessageActions();
    document.getElementById('chat-input').focus();
}

/**
 * 【全新】取消引用模式
 */
function cancelReplyMode() {
    currentReplyContext = null;
    document.getElementById('reply-preview-bar').style.display = 'none';
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】用户处理转账的核心功能函数 ▼▼▼

let activeTransferTimestamp = null; // 用于暂存被点击的转账消息的时间戳

/**
 * 显示处理转账的操作菜单
 * @param {number} timestamp - 被点击的转账消息的时间戳
 */
function showTransferActionModal(timestamp) {
    activeTransferTimestamp = timestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (message) {
        // 将AI的名字填入弹窗
        document.getElementById('transfer-sender-name').textContent = message.senderName;
    }
    document.getElementById('transfer-actions-modal').classList.add('visible');
}

/**
 * 隐藏处理转账的操作菜单
 */
function hideTransferActionModal() {
    document.getElementById('transfer-actions-modal').classList.remove('visible');
    activeTransferTimestamp = null;
}

/**
 * 处理用户接受或拒绝转账的逻辑
 * @param {string} choice - 用户的选择, 'accepted' 或 'declined'
 */
async function handleUserTransferResponse(choice) {
    if (!activeTransferTimestamp) return;

    const timestamp = activeTransferTimestamp;
    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    // 1. 更新原始转账消息的状态
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;

    let systemContent;

    // 2. 如果用户选择“拒绝”
    if (choice === 'declined') {
        // 立刻在前端生成一个“退款”卡片，让用户看到
        const refundMessage = {
            role: 'user',
            type: 'transfer',
            isRefund: true, // 这是一个关键标记，用于UI显示这是退款
            amount: originalMessage.amount,
            note: '已拒收对方转账',
            timestamp: Date.now()
        };
        chat.history.push(refundMessage);
        
        // 准备一条对AI可见的隐藏消息，告诉它发生了什么
        systemContent = `[系统提示：你拒绝并退还了“${originalMessage.senderName}”的转账。]`;
    } else { // 如果用户选择“接受”
        // 只需准备隐藏消息通知AI即可
        systemContent = `[系统提示：你接受了“${originalMessage.senderName}”的转账。]`;
    }

    // 3. 创建这条对用户隐藏、但对AI可见的系统消息
    const hiddenMessage = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now() + 1, // 保证时间戳在退款消息之后
        isHidden: true // 这个标记会让它不在聊天界面显示
    };
    chat.history.push(hiddenMessage);

    // 4. 保存所有更改到数据库，并刷新界面
    await db.chats.put(chat);
    hideTransferActionModal(); 
    renderChatInterface(state.activeChatId);
    renderChatList();
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】通话记录功能核心函数 ▼▼▼

async function renderCallHistoryScreen() {
    showScreen('call-history-screen'); // <--【核心修正】把它移动到最前面！

    const listEl = document.getElementById('call-history-list');
    const titleEl = document.getElementById('call-history-title');
    listEl.innerHTML = '';
    titleEl.textContent = '所有通话记录';
    
    const records = await db.callRecords.orderBy('timestamp').reverse().toArray();
    
    if (records.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有通话记录哦~</p>';
        return; // 现在的 return 就没问题了，因为它只跳过了后续的渲染逻辑
    }
    
    records.forEach(record => {
        const card = createCallRecordCard(record);

    addLongPressListener(card, async () => {
        // 1. 弹出输入框，并将旧名称作为默认值，方便修改
        const newName = await showCustomPrompt(
            "自定义通话名称", 
            "请输入新的名称（留空则恢复默认）",
            record.customName || '' // 如果已有自定义名称，就显示它
        );

        // 2. 如果用户点击了“取消”，则什么都不做
        if (newName === null) return;
        
        // 3. 更新数据库中的这条记录
        await db.callRecords.update(record.id, { customName: newName.trim() });
        
        // 4. 刷新整个列表，让更改立刻显示出来
        await renderCallHistoryScreen();
        
        // 5. 给用户一个成功的提示
        await showCustomAlert('成功', '通话名称已更新！');
    });
        listEl.appendChild(card);
    });    
}

// ▼▼▼ 用这个【升级版】函数，完整替换你旧的 createCallRecordCard 函数 ▼▼▼
/**
 * 【升级版】根据单条记录数据，创建一张能显示聊天对象的通话卡片
 * @param {object} record - 一条通话记录对象
 * @returns {HTMLElement} - 创建好的卡片div
 */
function createCallRecordCard(record) {
    const card = document.createElement('div');
    card.className = 'call-record-card';
    card.dataset.recordId = record.id; 

    // 获取通话对象的名字
    const chatInfo = state.chats[record.chatId];
    const chatName = chatInfo ? chatInfo.name : '未知会话';

    const callDate = new Date(record.timestamp);
    const dateString = `${callDate.getFullYear()}-${String(callDate.getMonth() + 1).padStart(2, '0')}-${String(callDate.getDate()).padStart(2, '0')} ${String(callDate.getHours()).padStart(2, '0')}:${String(callDate.getMinutes()).padStart(2, '0')}`;
    const durationText = `${Math.floor(record.duration / 60)}分${record.duration % 60}秒`;

    const avatarsHtml = record.participants.map(p => 
        `<img src="${p.avatar}" alt="${p.name}" class="participant-avatar" title="${p.name}">`
    ).join('');
    
    card.innerHTML = `
        <div class="card-header">
            <span class="date">${dateString}</span>
            <span class="duration">${durationText}</span>
        </div>
        <div class="card-body">
            <!-- 【核心修改】在这里新增一个标题行 -->
            ${record.customName ? `<div class="custom-title">${record.customName}</div>` : ''}
            
            <div class="participants-info"> <!-- 新增一个容器方便布局 -->
                <div class="participants-avatars">${avatarsHtml}</div>
                <span class="participants-names">与 ${chatName}</span>
            </div>
        </div>
    `;
    return card;
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 显示指定通话记录的完整文字稿
 * @param {number} recordId - 通话记录的ID
 */
async function showCallTranscript(recordId) {
    const record = await db.callRecords.get(recordId);
    if (!record) return;

    const modal = document.getElementById('call-transcript-modal');
    const titleEl = document.getElementById('transcript-modal-title');
    const bodyEl = document.getElementById('transcript-modal-body');

    titleEl.textContent = `通话于 ${new Date(record.timestamp).toLocaleString()} (时长: ${Math.floor(record.duration / 60)}分${record.duration % 60}秒)`;
    bodyEl.innerHTML = '';
    
    if (!record.transcript || record.transcript.length === 0) {
        bodyEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">这次通话没有留下文字记录。</p>';
    } else {
        record.transcript.forEach(entry => {
            const bubble = document.createElement('div');
            // 根据角色添加不同的class，应用不同的样式
            bubble.className = `transcript-entry ${entry.role}`; 
            bubble.textContent = entry.content;
            bodyEl.appendChild(bubble);
        });
    }

    const deleteBtn = document.getElementById('delete-transcript-btn');
    
    // 【重要】使用克隆节点技巧，防止事件重复绑定
    const newDeleteBtn = deleteBtn.cloneNode(true);
    deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
    
    // 为新的、干净的按钮绑定事件
    newDeleteBtn.addEventListener('click', async () => {
        const confirmed = await showCustomConfirm(
            "确认删除",
            "确定要永久删除这条通话记录吗？此操作不可恢复。",
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            // 1. 关闭当前的详情弹窗
            modal.classList.remove('visible');
            
            // 2. 从数据库删除
            await db.callRecords.delete(recordId);
            
            // 3. 刷新通话记录列表
            await renderCallHistoryScreen();
            
            // 4. (可选) 给出成功提示
            alert('通话记录已删除。');
        }
    });
    modal.classList.add('visible');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请用这个【全新函数】替换掉你旧的 handleStatusResetClick 函数 ▼▼▼

/**
 * 【全新】处理用户点击状态栏，弹出编辑框让用户修改AI的当前状态
 */
async function handleEditStatusClick() {
    // 1. 安全检查，确保在单聊界面
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
        return; 
    }
    const chat = state.chats[state.activeChatId];

    // 2. 弹出输入框，让用户输入新的状态，并将当前状态作为默认值
    const newStatusText = await showCustomPrompt(
        '编辑对方状态',
        '请输入对方现在的新状态：',
        chat.status.text // 将当前状态作为输入框的默认内容
    );

    // 3. 如果用户输入了内容并点击了“确定”
    if (newStatusText !== null) {
        // 4. 更新内存和数据库中的状态数据
        chat.status.text = newStatusText.trim() || '在线'; // 如果用户清空了，就默认为“在线”
        chat.status.isBusy = false; // 每次手动编辑都默认其不处于“忙碌”状态
        chat.status.lastUpdate = Date.now();
        chat.displayStatus.statusText = msgData.status_text;
        await db.chats.put(chat);

        // 5. 立刻刷新UI，让用户看到修改后的状态
        renderChatInterface(state.activeChatId);
        renderChatList();
        
        // 6. 给出一个无伤大雅的成功提示
        await showCustomAlert('状态已更新', `“${chat.name}”的当前状态已更新为：${chat.status.text}`);
    }
}

// 放在你的JS功能函数定义区
async function openShareTargetPicker() {
    const modal = document.getElementById('share-target-modal');
    const listEl = document.getElementById('share-target-list');
    listEl.innerHTML = '';

    // 获取所有聊天作为分享目标
    const chats = Object.values(state.chats);

    chats.forEach(chat => {
        // 复用联系人选择器的样式
        const item = document.createElement('div');
        item.className = 'contact-picker-item'; 
        item.innerHTML = `
            <input type="checkbox" class="share-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
            <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${chat.name}</span>
        `;
        listEl.appendChild(item);
    });
    
    modal.classList.add('visible');
}

// 论坛转发功能：打开转发目标选择模态框
async function openForumShareTargetModal(post) {
    const modal = document.getElementById('share-target-modal');
    const listEl = document.getElementById('share-target-list');
    listEl.innerHTML = '';

    // 获取所有聊天作为转发目标
    const chats = Object.values(state.chats);

    chats.forEach(chat => {
        // 复用联系人选择器的样式
        const item = document.createElement('div');
        item.className = 'contact-picker-item'; 
        item.innerHTML = `
            <input type="checkbox" class="share-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
            <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${chat.name}</span>
        `;
        listEl.appendChild(item);
    });
    
    // 存储当前要转发的帖子信息
    modal.dataset.forwardingPostId = post.id;
    
    modal.classList.add('visible');
}

// 处理论坛帖子转发
async function handleForumPostForward(post, targetChatIds) {
    // 增加帖子的转发次数
    if (!post.forwardCount) post.forwardCount = 0;
    post.forwardCount += targetChatIds.length;
    await db.forumPosts.put(post);
    
    // 创建论坛转发卡片消息
// 创建论坛转发卡片消息
const forumCardMessage = {
    role: 'user',
    senderName: state.qzoneSettings.nickname || '我',
    type: 'forum_card',
    timestamp: Date.now(),
    payload: {
        postId: post.id,
        posterName: post.posterName,
        postType: post.postType,
        // ▼▼▼ 核心修改在这里 ▼▼▼
        postContent: post.postContent, // 传递原始的纯文本内容
        publicText: post.publicText,   // 传递原始的公开文本
        hiddenContent: post.hiddenContent, // 传递原始的隐藏文本（文字图）
        imageUrl: post.imageUrl,         // 传递原始的图片URL
        imageDescription: post.imageDescription, // <-- 【全新添加】确保图片描述也被转发
        // ▲▲▲ 修改结束 ▲▲▲
        title: `转发自论坛的帖子`,
        originalLikes: post.likes ? post.likes.length : 0, // 修正：传递点赞数而不是名字列表
        originalComments: post.comments?.length || 0
    }
};

    // 发送到所有目标聊天
    for (const targetId of targetChatIds) {
        const targetChat = state.chats[targetId];
        if (targetChat) {
            targetChat.history.push({...forumCardMessage});
            await db.chats.put(targetChat);
        }
    }
    
    // 刷新论坛显示以更新转发次数
    renderForumPosts(currentForumPosts);
    
    await showCustomAlert("转发成功", `帖子已成功转发到 ${targetChatIds.length} 个会话中。`);
}

function closeMusicPlayerWithAnimation(callback) {
    const overlay = document.getElementById('music-player-overlay');
    if (!overlay.classList.contains('visible')) {
        if (callback) callback();
        return;
    }
    overlay.classList.remove('visible');
    setTimeout(() => {
        document.getElementById('music-playlist-panel').classList.remove('visible');
        if (callback) callback();
    }, 400); 
}

function parseLRC(lrcContent) {
    if (!lrcContent) return [];
    const lines = lrcContent.split('\n');
    const lyrics = [];
    const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;

    for (const line of lines) {
        const text = line.replace(timeRegex, '').trim();
        if (!text) continue;
        timeRegex.lastIndex = 0;
        let match;
        while ((match = timeRegex.exec(line)) !== null) {
            const minutes = parseInt(match[1], 10);
            const seconds = parseInt(match[2], 10);
            const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
            const time = minutes * 60 + seconds + milliseconds / 1000;
            lyrics.push({ time, text });
        }
    }
    return lyrics.sort((a, b) => a.time - b.time);
}

function renderLyrics() {
    const lyricsList = document.getElementById('music-lyrics-list');
    lyricsList.innerHTML = '';
    if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
        lyricsList.innerHTML = '<div class="lyric-line">♪ 暂无歌词 ♪</div>';
        return;
    }
    musicState.parsedLyrics.forEach((line, index) => {
        const lineEl = document.createElement('div');
        lineEl.className = 'lyric-line';
        lineEl.textContent = line.text;
        lineEl.dataset.index = index;
        lyricsList.appendChild(lineEl);
    });
    lyricsList.style.transform = `translateY(0px)`;
}

function updateActiveLyric(currentTime) {
    if (musicState.parsedLyrics.length === 0) return;
    let newLyricIndex = -1;
    for (let i = 0; i < musicState.parsedLyrics.length; i++) {
        if (currentTime >= musicState.parsedLyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    if (newLyricIndex === musicState.currentLyricIndex) return;
    musicState.currentLyricIndex = newLyricIndex;
    updateLyricsUI();
}

function updateLyricsUI() {
    const lyricsList = document.getElementById('music-lyrics-list');
    const container = document.getElementById('music-lyrics-container');
    const lines = lyricsList.querySelectorAll('.lyric-line');
    lines.forEach(line => line.classList.remove('active'));
    if (musicState.currentLyricIndex === -1) {
        lyricsList.style.transform = `translateY(0px)`;
        return;
    }
    const activeLine = lyricsList.querySelector(`.lyric-line[data-index="${musicState.currentLyricIndex}"]`);
    if (activeLine) {
        activeLine.classList.add('active');
        const containerHeight = container.offsetHeight;
        const offset = (containerHeight / 3) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
        lyricsList.style.transform = `translateY(${offset}px)`;
    }
}

function formatMusicTime(seconds) {
    if (isNaN(seconds) || seconds < 0) return "0:00";
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${String(remainingSeconds).padStart(2, '0')}`;
}

function updateMusicProgressBar() {
    const currentTimeEl = document.getElementById('music-current-time');
    const totalTimeEl = document.getElementById('music-total-time');
    const progressFillEl = document.getElementById('music-progress-fill');
    if (!audioPlayer.duration) {
        currentTimeEl.textContent = "0:00";
        totalTimeEl.textContent = "0:00";
        progressFillEl.style.width = '0%';
        return;
    }
    const progressPercent = (audioPlayer.currentTime / audioPlayer.duration) * 100;
    progressFillEl.style.width = `${progressPercent}%`;
    currentTimeEl.textContent = formatMusicTime(audioPlayer.currentTime);
    totalTimeEl.textContent = formatMusicTime(audioPlayer.duration);
    updateActiveLyric(audioPlayer.currentTime);
}

/**
         * 【全新】处理用户点击“撤回”按钮的入口函数
         */
        async function handleRecallClick() {
            if (!activeMessageTimestamp) return;

            const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000; // 设置2分钟的撤回时限
            const messageTime = activeMessageTimestamp;
            const now = Date.now();

            // 检查是否超过了撤回时限
            if (now - messageTime > RECALL_TIME_LIMIT_MS) {
                hideMessageActions();
                await showCustomAlert('操作失败', '该消息发送已超过2分钟，无法撤回。');
                return;
            }

            // 如果在时限内，执行真正的撤回逻辑
            await recallMessage(messageTime, true);
            hideMessageActions();

            // 【核心新增】在撤回后，立即触发AI响应
            triggerAiResponse();
        }

/**
         * 【全新】消息撤回的核心逻辑
         * @param {number} timestamp - 要撤回的消息的时间戳
         * @param {boolean} isUserRecall - 是否是用户主动撤回
         */
        async function recallMessage(timestamp, isUserRecall) {
            const chat = state.chats[state.activeChatId];
            if (!chat) return;

            const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
            if (messageIndex === -1) return;

            const messageToRecall = chat.history[messageIndex];

            // 1. 修改消息对象，将其变为“已撤回”状态
            const recalledData = {
                originalType: messageToRecall.type || 'text',
                originalContent: messageToRecall.content,
                // 保存其他可能存在的原始数据
                originalMeaning: messageToRecall.meaning,
                originalQuote: messageToRecall.quote
            };

            messageToRecall.type = 'recalled_message';
            messageToRecall.content = isUserRecall ? '你撤回了一条消息' : '对方撤回了一条消息';
            messageToRecall.recalledData = recalledData;
            // 清理掉不再需要的旧属性
            delete messageToRecall.meaning;
            delete messageToRecall.quote;

            // 2. 如果是用户撤回，需要给AI发送一条它看不懂内容的隐藏提示
            if (isUserRecall) {
                const hiddenMessageForAI = {
                    role: 'system',
                    // 【核心修改】在这里，我们告诉AI被撤回的内容是什么
                    content: `[系统提示：用户撤回了刚刚发送的一条消息。被撤回的内容是：“${recalledData.originalContent}”。请你根据这个情况，自然地继续对话。]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(hiddenMessageForAI);
            }

            // 3. 保存到数据库并刷新UI
            await db.chats.put(chat);
            renderChatInterface(state.activeChatId);
            if (isUserRecall) renderChatList(); // 用户撤回时，最后一条消息变了，需要刷新列表
        }
/**
 * 【全新】处理“向下全选”按钮的点击事件
 */
function handleSelectBelow() {
    if (selectedMessages.size === 0) {
        alert('请至少先选择一条消息作为起点。');
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 1. 找到用户已选中的消息中，时间戳最大的那一条
    const lastSelectedTimestamp = Math.max(...selectedMessages);

    // 2. 在聊天历史中找到这条消息的索引位置
    const startIndex = chat.history.findIndex(msg => msg.timestamp === lastSelectedTimestamp);

    if (startIndex === -1) return; // 安全检查

    // 3. 从这条消息的下一条开始，遍历所有后续消息
    for (let i = startIndex + 1; i < chat.history.length; i++) {
        const messageToSelect = chat.history[i];
        // 确保我们不会选中那些对用户隐藏的系统消息
        if (!messageToSelect.isHidden) {
            selectedMessages.add(messageToSelect.timestamp);
        }
    }

    // 4. 批量更新UI，为所有新选中的消息添加 'selected' 样式
    document.querySelectorAll('#chat-messages .message-bubble').forEach(bubble => {
        const timestamp = parseInt(bubble.dataset.timestamp);
        if (selectedMessages.has(timestamp)) {
            bubble.classList.add('selected');
        }
    });

    // 5. 更新顶部的计数显示
    document.getElementById('selection-count').textContent = `已选 ${selectedMessages.size} 条`;
}
// ▼▼▼ 【全新】将这些函数粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 打开分类管理模态框
 */
async function openCategoryManager() {
    await renderCategoryListInManager();
    document.getElementById('world-book-category-manager-modal').classList.add('visible');
}

/**
 * 在模态框中渲染已存在的分类列表
 */
async function renderCategoryListInManager() {
    const listEl = document.getElementById('existing-categories-list');
    const categories = await db.worldBookCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
    }
    categories.forEach(cat => {
        // 使用毛玻璃样式
        const item = document.createElement('div');
        item.className = 'category-item-row'; 
        item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 添加一个新的世界书分类
 */
async function addNewCategory() {
    const input = document.getElementById('new-category-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分类名不能为空！');
        return;
    }
    const existing = await db.worldBookCategories.where('name').equals(name).first();
    if (existing) {
        alert(`分类 "${name}" 已经存在了！`);
        return;
    }
    await db.worldBookCategories.add({ name });
    input.value = '';
    await renderCategoryListInManager();
}

/**
 * 删除一个世界书分类
 * @param {number} categoryId - 要删除的分类的ID
 */
async function deleteCategory(categoryId) {
    const confirmed = await showCustomConfirm(
        '确认删除', 
        '删除分类后，该分类下的所有世界书将变为“未分类”。确定要删除吗？', 
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        await db.worldBookCategories.delete(categoryId);
        // 将属于该分类的世界书的 categoryId 设为 null
        const booksToUpdate = await db.worldBooks.where('categoryId').equals(categoryId).toArray();
        for (const book of booksToUpdate) {
            book.categoryId = null;
            await db.worldBooks.put(book);
            const bookInState = state.worldBooks.find(wb => wb.id === book.id);
            if(bookInState) bookInState.categoryId = null;
        }
        await renderCategoryListInManager();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】批量添加表情包功能 ▼▼▼

/**
 * 弹出批量添加的输入框
 */
async function handleBatchAddStickers() {
    // 1. 弹出带有文本输入区的提示框，并提供新的格式说明
    const inputText = await showCustomPrompt(
        '批量添加表情包',
        // 【核心修改】更新这里的提示文本，告知用户新格式
        '请按格式粘贴，名称和链接各占一行：\n很不高兴\nhttps://....jpeg,\n双倍开心\nhttps://....jpg,',
        '', 
        'textarea'
    );

    if (!inputText || !inputText.trim()) {
        return;
    }

    await parseAndAddStickers(inputText);
}

// ▼▼▼ 【最终版】请用这个函数完整替换旧的 parseAndAddStickers 函数 ▼▼▼
/**
 * 解析文本并批量添加表情包到数据库 (智能兼容单行与多行格式)
 * @param {string} text - 用户在文本框中输入的完整字符串
 */
async function parseAndAddStickers(text) {
    // 1. 按行分割，并过滤掉可能存在的完全空白的行
    const lines = text.split('\n').filter(line => line.trim() !== '');
    
    const stickersToAdd = [];
    const errorLines = [];
    
    // 2. 引入一个'待定名称'变量，用于处理名称和链接在不同行的情况
    let pendingName = null;

    const urlRegex = /(https?:\/\/[^\s]+)/;

    for (const line of lines) {
        const trimmedLine = line.trim();
        const match = trimmedLine.match(urlRegex);

        // --- 核心判断逻辑 ---

        // 情况A: 当前行包含URL
        if (match) {
            const url = match[0].replace(/,$/, '').trim(); // 获取URL并去掉末尾逗号
            const name = trimmedLine.substring(0, trimmedLine.indexOf(url)).trim(); // URL之前的内容是名称

            // 情况A1: 名称和URL在同一行 (例如: "开心https://...")
            if (name) {
                stickersToAdd.push({ id: `sticker_${Date.now()}_${stickersToAdd.length}`, name, url });
                if (pendingName) { // 如果之前有一个待定的名称，说明它落单了，是错误的
                    errorLines.push(pendingName);
                    pendingName = null;
                }
            } 
            // 情况A2: 当前行只有URL，需要和上一行的待定名称配对
            else if (pendingName) {
                stickersToAdd.push({ id: `sticker_${Date.now()}_${stickersToAdd.length}`, name: pendingName, url });
                pendingName = null; // 配对成功，清空待定名称
            } 
            // 情况A3: 当前行只有URL，但没有待定的名称与之配对，错误
            else {
                errorLines.push(trimmedLine);
            }
        } 
        // 情况B: 当前行不包含URL，只能是名称
        else {
            if (pendingName) { // 如果之前已经有一个待定的名称，说明它落单了
                errorLines.push(pendingName);
            }
            pendingName = trimmedLine; // 将当前行设为新的待定名称
        }
    }

    // 循环结束后，如果还有一个待定的名称没有配对，也视为错误
    if (pendingName) {
        errorLines.push(pendingName);
    }
    
    // --- 后续逻辑保持不变 ---
    if (stickersToAdd.length > 0) {
        try {
            await db.userStickers.bulkAdd(stickersToAdd);
            state.userStickers.push(...stickersToAdd);
        } catch (error) {
            console.error("批量添加表情包到数据库失败:", error);
            await showCustomAlert('错误', '保存表情包时发生错误，请检查控制台。');
            return;
        }
    }

    let resultMessage = `成功添加 ${stickersToAdd.length} 个表情包！`;
    if (errorLines.length > 0) {
        resultMessage += `\n\n有 ${errorLines.length} 行格式不正确或无法配对，已被跳过。`;
    }
    await showCustomAlert('批量添加完成', resultMessage);

    renderStickerPanel();
}
// ▲▲▲ 替换结束 ▲▲▲

        // ===================================================================
        // 4. 初始化函数 init()
        // ===================================================================
        /**
 * 【全新】专门更新聊天界面顶部的状态栏
 */
function updateChatHeaderStatus() {
    if (!state.activeChatId) return; // 如果没有打开任何聊天，则不执行
    const chat = state.chats[state.activeChatId];
    if (!chat || chat.isGroup) return; // 如果找不到聊天或者当前是群聊，则不执行

    // 找到状态栏相关的元素
    const statusContainer = document.getElementById('chat-header-status');
    const statusTextEl = statusContainer.querySelector('.status-text');

    // 更新状态文本和"忙碌"样式
    statusTextEl.textContent = chat.status?.text || '在线';
    statusContainer.classList.toggle('busy', chat.status?.isBusy || false);
}
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
/**
 * 【全新】更强大的Base64解码器，用于处理特殊字符
 * @param {string} str - Base64编码的字符串
 * @returns {string} - 解码后的UTF-8字符串
 */
function decodeBase64Unicode(str) {
    return decodeURIComponent(atob(str).split('').map(function(c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
/**
 * 【全新】角色卡诊断函数
 * @param {File} file - PNG文件
 * @returns {Promise<string>} - 包含所有文本块信息的结果字符串
 */
function diagnoseCharacterCard(file) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            const buffer = event.target.result;
            const view = new DataView(buffer);
            let output = '开始诊断...\n\n';

            const isPng = view.byteLength > 8 && view.getUint32(0) === 0x89504E47 && view.getUint32(4) === 0x0D0A1A0A;
            if (!isPng) {
                resolve('错误：文件不是一个有效的PNG。');
                return;
            }

            output += '文件确认为PNG格式。\n开始扫描数据块...\n\n';
            let offset = 8;
            let chunkCount = 0;
            while (offset < view.byteLength) {
                chunkCount++;
                if (chunkCount > 100) { // 安全锁，防止无限循环
                    output += '扫描了超过100个数据块，已停止。';
                    break;
                }

                const length = view.getUint32(offset);
                const type = String.fromCharCode(view.getUint8(offset + 4), view.getUint8(offset + 5), view.getUint8(offset + 6), view.getUint8(offset + 7));
                
                if (type === 'tEXt' || type === 'zTXt') {
                    output += `--- 找到文本块 #${chunkCount} ---\n`;
                    output += `类型 (Type): ${type}\n`;
                    output += `长度 (Length): ${length} 字节\n`;

                    const dataOffset = offset + 8;
                    const chunkData = new Uint8Array(buffer, dataOffset, length);
                    const separatorIndex = Array.from(chunkData).indexOf(0);

                    if (separatorIndex > 0) {
                        const key = new TextDecoder('latin1').decode(chunkData.slice(0, separatorIndex));
                        output += `关键词 (Key): ${key}\n\n`;
                        
                        let valueText = '';
                        try {
                            if (type === 'tEXt') {
                                const valueData = chunkData.slice(separatorIndex + 1);
                                valueText = new TextDecoder('latin1').decode(valueData);
                                output += `内容 (未压缩):\n--------------------\n${valueText}\n--------------------\n\n`;
                            } else { // zTXt
                                const valueData = chunkData.slice(separatorIndex + 2);
                                const decompressed = pako.inflate(valueData);
                                valueText = new TextDecoder('utf-8').decode(decompressed);
                                output += `内容 (已解压):\n--------------------\n${valueText}\n--------------------\n\n`;
                            }

                            // 尝试解码并格式化，方便我们查看最终的JSON结构
                            if (key === 'chara') {
                                 const decodedData = decodeBase64Unicode(valueText);
                                 const charData = JSON.parse(decodedData);
                                 output += `尝试解码和格式化 'chara' 内容 (最终JSON结构):\n--------------------\n${JSON.stringify(charData, null, 2)}\n--------------------\n\n`;
                            }
                        } catch (e) {
                            output += `!!! 在处理此块内容时发生错误: ${e.message} !!!\n\n`;
                        }
                    } else {
                        output += `警告：在此文本块中未找到关键词分隔符。\n\n`;
                    }
                }
                offset += 12 + length;
            }
            output += '诊断结束。';
            resolve(output);
        };
        reader.onerror = () => {
            resolve('读取文件失败。');
        };
        reader.readAsArrayBuffer(file);
    });
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// init() 函数开始 
        async function init() {

            // ▼▼▼ 在 init() 函数的事件监听器区域末尾添加 ▼▼▼

// 【全新】论坛功能事件绑定
document.getElementById('forum-refresh-btn').addEventListener('click', openForumSettingsModal);
document.getElementById('cancel-forum-settings-btn').addEventListener('click', () => {
    document.getElementById('forum-settings-modal').classList.remove('visible');
});
document.getElementById('generate-forum-posts-btn').addEventListener('click', generateForumPosts);

// ▼▼▼ 请用这【一整块】全新的代码，完整替换掉旧的 forum-posts-container 事件监听器 ▼▼▼
document.getElementById('forum-posts-container').addEventListener('click', (e) => {
    const target = e.target;

    // --- 【核心修正】处理“文字图”的点击事件 ---
    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        // 使用已经存在的 showCustomAlert 函数来显示描述
        showCustomAlert("图片内容", hiddenText.replace(/<br>/g, '\n'));
        return; // 处理完后直接返回，避免触发其他事件
    }

    // --- 处理点赞 (已有逻辑，保持不变) ---
    const likeBtn = target.closest('.like-btn');
    if (likeBtn) {
        (async () => {
            const postItem = likeBtn.closest('.forum-post-item');
            if (!postItem) return;
            const postId = parseInt(postItem.dataset.postId);
            const post = currentForumPosts.find(p => p.id === postId);
            if (!post) return;

            if (!post.likes) post.likes = [];
            const userNickname = state.qzoneSettings.nickname || '我';
            const userLikeIndex = post.likes.indexOf(userNickname);

            if (userLikeIndex > -1) {
                post.likes.splice(userLikeIndex, 1);
            } else {
                post.likes.push(userNickname);
            }

            await db.forumPosts.put(post);
            renderForumPosts(currentForumPosts);
        })();
    }

    // --- 处理发送评论 (已有逻辑，保持不变) ---
    if (target.tagName === 'BUTTON' && target.previousElementSibling?.tagName === 'INPUT') {
        (async () => {
            const input = target.previousElementSibling;
            const commentText = input.value.trim();
            if (!commentText) return;

            const postItem = target.closest('.forum-post-item');
            if (!postItem) return;

            const postId = parseInt(postItem.dataset.postId);
            const post = currentForumPosts.find(p => p.id === postId);

            if (post) {
                const userComment = {
                    commenterName: state.qzoneSettings.nickname || '我',
                    commentText: commentText
                };
                if (!post.comments) post.comments = [];
                post.comments.push(userComment);
                post.isAwaitingReply = true;
                
                await db.forumPosts.put(post);

                input.value = '';
                renderForumPosts(currentForumPosts);

                await triggerAiForumReply(post, commentText);

                post.isAwaitingReply = false;
                await db.forumPosts.put(post);
                renderForumPosts(currentForumPosts);
            }
        })();
    }

    // --- 处理转发按钮点击 ---
    const forwardBtn = target.closest('.forward-btn');
    if (forwardBtn) {
        const postItem = forwardBtn.closest('.forum-post-item');
        if (!postItem) return;
        const postId = parseInt(postItem.dataset.postId);
        const post = currentForumPosts.find(p => p.id === postId);
        if (!post) return;
        
        // 打开转发目标选择模态框
        openForumShareTargetModal(post);
    }
});

// 在 init() 函数的事件监听器区域添加
document.getElementById('batch-add-sticker-btn').addEventListener('click', handleBatchAddStickers);

    // ▼▼▼ 在 init() 函数的【最开头】，粘贴下面这两行代码 ▼▼▼
    const savedTheme = localStorage.getItem('ephone-theme') || 'light'; // 默认为日间模式
    applyTheme(savedTheme);
    // ▲▲▲ 粘贴结束 ▲▲▲

    // ▼▼▼ 新增代码 ▼▼▼
    const customBubbleStyleTag = document.createElement('style');
    customBubbleStyleTag.id = 'custom-bubble-style';
    document.head.appendChild(customBubbleStyleTag);
    // ▲▲▲ 新增结束 ▲▲▲

    // ▼▼▼ 新增代码 ▼▼▼
    const previewBubbleStyleTag = document.createElement('style');
    previewBubbleStyleTag.id = 'preview-bubble-style';
    document.head.appendChild(previewBubbleStyleTag);
    // ▲▲▲ 新增结束 ▲▲▲


    // ▼▼▼ 修改这两行 ▼▼▼
    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真实聊天界面的自定义样式
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除预览区的自定义样式
    // ▲▲▲ 修改结束 ▲▲▲

            window.showScreen = showScreen;
            window.renderChatListProxy = renderChatList;
            window.renderApiSettingsProxy = renderApiSettings;
            window.renderWallpaperScreenProxy = renderWallpaperScreen;
            window.renderWorldBookScreenProxy = renderWorldBookScreen;

            await loadAllDataFromDB();
            
            // 初始化线上/线下模式状态（页面加载时恢复所有聊天的状态）
            initializeOfflineModeStates();

            // 初始化未读动态计数
            const storedCount = parseInt(localStorage.getItem('unreadPostsCount')) || 0;
            updateUnreadIndicator(storedCount);
            
            // ▲▲▲ 代码添加结束 ▲▲▲

            if (state.globalSettings && state.globalSettings.fontUrl) {
                applyCustomFont(state.globalSettings.fontUrl);
            }

            updateClock();
            setInterval(updateClock, 1000 * 30);
            applyGlobalWallpaper();
            applyGlobalChatBackground();
            applyChatListPaddingTop(); // <--- 在这里调用，保存后立即应用           

isIOS();

applyAppIcons();

            // ==========================================================
            // --- 各种事件监听器 ---
            // ==========================================================
// ▼▼▼ 在这里添加新的代码块 ▼▼▼
        // 在程序启动时从数据库加载已有的论坛帖子
        currentForumPosts = await db.forumPosts.toArray();
        if (currentForumPosts.length > 0) {
            console.log(`从数据库加载了 ${currentForumPosts.length} 条论坛帖子。`);
            renderForumPosts(currentForumPosts);
        }
        // ▲▲▲ 添加结束 ▲▲▲
            document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
            document.getElementById('custom-modal-overlay').addEventListener('click', (e) => { if (e.target === modalOverlay) hideCustomModal(); });
            document.getElementById('export-data-btn').addEventListener('click', exportBackup);
            document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-data-input').click());
            document.getElementById('import-data-input').addEventListener('change', e => importBackup(e.target.files[0]));
            
            // 【记忆功能】记忆按钮事件监听器
            document.getElementById('memory-summary-btn').addEventListener('click', () => {
                if (!state.activeChatId) return;
                const chat = state.chats[state.activeChatId];

                // 获取记忆内容并填充到文本框
                document.getElementById('memory-summary-textarea').value = chat.memorySummary || '';

                // 更新消息统计
                updateMemoryStats(state.activeChatId);

                // 显示弹窗
                document.getElementById('memory-summary-modal').classList.add('visible');

                // 关闭+功能面板
                closePlusPanel();
            });

            document.getElementById('memory-summary-btn-group').addEventListener('click', () => {
                if (!state.activeChatId) return;
                const chat = state.chats[state.activeChatId];

                // 获取记忆内容并填充到文本框
                document.getElementById('memory-summary-textarea').value = chat.memorySummary || '';

                // 更新消息统计
                updateMemoryStats(state.activeChatId);

                // 显示弹窗
                document.getElementById('memory-summary-modal').classList.add('visible');

                // 关闭+功能面板
                closePlusPanel();
            });

            // 【记忆功能】强制总结按钮
            document.getElementById('force-summarize-btn').addEventListener('click', () => {
                if (!state.activeChatId) return;
                manualSummarizeMemory(state.activeChatId);
            });

            // 【记忆功能】删除记忆按钮
            document.getElementById('delete-summary-btn').addEventListener('click', async () => {
                const confirmed = await showCustomConfirm('删除记忆', '确定要删除所有记忆摘要吗？此操作无法撤销。');
                if (confirmed) {
                    const chat = state.chats[state.activeChatId];
                    chat.memorySummary = '';

                    // 同时将所有消息的isSummarized标记重置为false
                    chat.history.forEach(msg => {
                        if (msg.isSummarized !== undefined) {
                            msg.isSummarized = false;
                        }
                    });

                    await db.chats.put(chat);
                    document.getElementById('memory-summary-textarea').value = '';

                    // 更新消息统计
                    updateMemoryStats(state.activeChatId);

                    await showCustomAlert('删除成功', '记忆已清空！');
                }
            });

            // 【记忆功能】保存记忆按钮
            document.getElementById('save-summary-btn').addEventListener('click', async () => {
                if (!state.activeChatId) return;
                const chat = state.chats[state.activeChatId];
                const newSummary = document.getElementById('memory-summary-textarea').value;

                chat.memorySummary = newSummary;
                await db.chats.put(chat);
                document.getElementById('memory-summary-modal').classList.remove('visible');
                
            });

            // 礼物功能事件监听器
            document.getElementById('gift-btn-panel').addEventListener('click', () => {
                closePlusPanel(); // 先关闭功能面板
                // 单聊模式：隐藏接收对象选择
                document.getElementById('gift-recipient-group').style.display = 'none';
                document.getElementById('gift-modal').classList.add('visible');
            });
            document.getElementById('gift-btn-group-panel').addEventListener('click', () => {
                closePlusPanel(); // 先关闭功能面板
                // 群聊模式：显示接收对象选择并填充群成员
                const currentChat = state.chats[state.activeChatId];
                if (currentChat && currentChat.isGroup) {
                    populateGroupMembersForGift(currentChat);
                    document.getElementById('gift-recipient-group').style.display = 'block';
                }
                document.getElementById('gift-modal').classList.add('visible');
            });
            document.getElementById('cancel-gift-btn').addEventListener('click', () => {
                document.getElementById('gift-modal').classList.remove('visible');
                document.getElementById('gift-name-input').value = '';
                document.getElementById('gift-price-input').value = '';
            });
            document.getElementById('send-gift-btn').addEventListener('click', () => {
                const giftName = document.getElementById('gift-name-input').value.trim();
                const giftPrice = document.getElementById('gift-price-input').value.trim();
                const recipientSelect = document.getElementById('gift-recipient-select');
                const recipient = recipientSelect.style.display === 'none' ? null : recipientSelect.value;
                
                if (giftName && giftPrice) {
                    sendGiftMessage(giftName, giftPrice, recipient);
                    document.getElementById('gift-modal').classList.remove('visible');
                    document.getElementById('gift-name-input').value = '';
                    document.getElementById('gift-price-input').value = '';
                    document.getElementById('gift-recipient-group').style.display = 'none';
                }
            });
            
            // ▼▼▼ 请用这段【新代码】完整替换旧的 'back-to-list-btn' 事件监听器 ▼▼▼
document.getElementById('back-to-list-btn').addEventListener('click', () => { 
    // 【核心新增】在这里添加关闭面板的代码，确保退出时重置UI状态
    const singlePanel = document.getElementById('chat-plus-panel-single');
    const groupPanel = document.getElementById('chat-plus-panel-group');
    const chatInterface = document.getElementById('chat-interface-screen');
    
    if (singlePanel) singlePanel.classList.remove('visible');
    if (groupPanel) groupPanel.classList.remove('visible');
    if (chatInterface) chatInterface.classList.remove('panel-expanded');

    // 原有的其他逻辑保持不变
    applyScopedCss('', '#chat-messages', 'custom-bubble-style');
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style');
    exitSelectionMode(); 
    state.activeChatId = null; 
    showScreen('chat-list-screen'); 
});
// ▲▲▲ 替换结束 ▲▲▲
            
            document.getElementById('add-chat-btn').addEventListener('click', async () => { const name = await showCustomPrompt('创建新聊天', '请输入Ta的名字'); if (name && name.trim()) { const newChatId = 'chat_' + Date.now(); 
const newChat = { 
    id: newChatId,
    name: name.trim(),
    isGroup: false,                         relationship: {
                            status: 'friend', // 'friend', 'blocked_by_user', 'pending_user_approval'
                            blockedTimestamp: null,
                            applicationReason: ''
                        },
                        status: {
                            text: '在线',
                            lastUpdate: Date.now(),
                            isBusy: false
                        },
    settings: {
        aiPersona: '你是谁呀。',
        myPersona: '我是谁呀。',
        maxMemory: 10,
        aiAvatar: defaultAvatar,
        myAvatar: defaultAvatar,
        background: '',
        theme: 'default',
    // 【核心修改】新建聊天时，直接使用全局字体大小
    fontSize: state.globalSettings.fontSize || 13,
    customCss: '',
    linkedWorldBookIds: [],
    aiAvatarLibrary: [],
    },
    history: [],
    musicData: { totalTime: 0 },
    memorySummary: '', // 【记忆功能】新增字段：核心记忆摘要
    diary: [],
displayStatus: {
    statusText: '在线',
    innerThought: '开始一段新的对话吧...'
},
statusHistory: [],
thoughtHistory: []
// ▲▲▲ 粘贴结束 ▲▲▲
};
state.chats[newChatId] = newChat; await db.chats.put(newChat); renderChatList(); } });

            // ▼▼▼ 【修正】创建群聊按钮现在打开联系人选择器 ▼▼▼
document.getElementById('add-group-chat-btn').addEventListener('click', openContactPickerForGroupCreate);
// ▲▲▲ 替换结束 ▲▲▲                      
            document.getElementById('transfer-cancel-btn').addEventListener('click', () => document.getElementById('transfer-modal').classList.remove('visible'));
            document.getElementById('transfer-confirm-btn').addEventListener('click', sendUserTransfer);

document.getElementById('listen-together-btn-panel').addEventListener('click', handleListenTogetherClick);
document.getElementById('listen-together-btn-group-panel').addEventListener('click', handleListenTogetherClick);

// 线上/线下模式切换按钮事件监听器
document.getElementById('online-offline-toggle-btn').addEventListener('click', toggleOnlineOfflineMode);

// 位置按钮事件监听器
document.getElementById('location-btn-panel').addEventListener('click', () => {
    closePlusPanel(); // 先关闭功能面板
    showLocationModal();
});
document.getElementById('location-btn-group-panel').addEventListener('click', () => {
    closePlusPanel(); // 先关闭功能面板
    showLocationModal();
});
            document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
            document.getElementById('music-return-btn').addEventListener('click', returnToChat);
            document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);
            document.getElementById('music-next-btn').addEventListener('click', playNext);
            document.getElementById('music-prev-btn').addEventListener('click', playPrev);
            document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
            document.getElementById('music-playlist-btn').addEventListener('click', () => { updatePlaylistUI(); document.getElementById('music-playlist-panel').classList.add('visible'); });
            document.getElementById('close-playlist-btn').addEventListener('click', () => document.getElementById('music-playlist-panel').classList.remove('visible'));
            document.getElementById('add-song-url-btn').addEventListener('click', addSongFromURL);
            document.getElementById('add-song-local-btn').addEventListener('click', () => document.getElementById('local-song-upload-input').click());
            document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);
            audioPlayer.addEventListener('ended', playNext);
            audioPlayer.addEventListener('pause', () => { if(musicState.isActive) { musicState.isPlaying = false; updatePlayerUI(); } });
            audioPlayer.addEventListener('play', () => { if(musicState.isActive) { musicState.isPlaying = true; updatePlayerUI(); } });

            const chatInput = document.getElementById('chat-input');
            // ▼▼▼ 找到 id="send-btn" 的 click 事件监听器 ▼▼▼
document.getElementById('send-btn').addEventListener('click', async () => { 
    const content = chatInput.value.trim(); 
    if (!content || !state.activeChatId) return; 
    
    closePlusPanel();
    
    const chat = state.chats[state.activeChatId];
    
    // 【新增】用户发送消息时，清除所有模拟时间戳，恢复真实时间戳显示
    restoreRealTimestamps(chat); 
    
    // --- 【核心修改】在这里添加 ---
const msg = { 
    role: 'user', 
    content, 
    timestamp: Date.now(),
    isOfflineMode: offlineMode.isOffline // 标记是否为线下模式消息
};

// 【全新】检查是否为HTML生成指令，如果是，则添加一个用于显示的特殊内容
if (content.includes('【停止角色扮演') && content.includes('输出完整HTML')) {
    msg.displayContent = 'ੈ♡消えない記憶⊹˳ ⋆';// 在这里自定义隐藏文字
}

    // 检查当前是否处于引用回复模式
    if (currentReplyContext) {
        msg.quote = currentReplyContext; // 将引用信息附加到消息对象上
    }
    // --- 【修改结束】 ---
    
    chat.history.push(msg); 
    await db.chats.put(chat); 
    appendMessage(msg, chat); 
    renderChatList(); 
    chatInput.value = ''; 
    chatInput.style.height = 'auto'; 
    chatInput.focus(); 
    
    // --- 【核心修改】发送后，取消引用模式 ---
    cancelReplyMode(); 
});
            document.getElementById('wait-reply-btn').addEventListener('click', triggerAiResponse);
            chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); document.getElementById('send-btn').click(); } });
            chatInput.addEventListener('focus', () => { closePlusPanel(); });
// ▼▼▼ 请用这段【新代码】替换旧的 chat-messages 点击事件 ▼▼▼

// ▼▼▼ 请用这段【新代码】完整替换旧的 chatInput.addEventListener('input', ...) ▼▼▼
chatInput.addEventListener('input', () => {
    const hasText = chatInput.value.trim().length > 0;

    // 【最终修正版】高度调整逻辑
    if (hasText) {
        // 1. 关键：先将高度重置为auto，这样浏览器才能正确计算出clientHeight和scrollHeight
        chatInput.style.height = 'auto';

        // 2. 核心判断：只有当内容所需高度 > 当前可见高度时，才去增高
        //    这能精确判断文字是否已经换行
        if (chatInput.scrollHeight > chatInput.clientHeight) {
            chatInput.style.height = chatInput.scrollHeight + 'px';
        }
    } else {
        // 当输入框为空时，恢复其初始的自动高度
        chatInput.style.height = 'auto';
    }

    // 同样保留输入时自动关闭下拉面板的逻辑 (这部分不变)
    if (hasText) {
        if (singlePanel.classList.contains('visible')) {
            singlePanel.classList.remove('visible');
        }
        if (groupPanel.classList.contains('visible')) {
            groupPanel.classList.remove('visible');
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲
            document.getElementById('wallpaper-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if(file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); newWallpaperBase64 = dataUrl; renderWallpaperScreen(); } });
            
            // 聊天背景上传事件监听器
            document.getElementById('chat-background-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if(file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); newChatBackgroundBase64 = dataUrl; renderWallpaperScreen(); } });
            // ▼▼▼ 用这整块代码，替换旧的 save-wallpaper-btn 事件监听器 ▼▼▼
document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {
    let changesMade = false;

    // 保存壁纸
    if (newWallpaperBase64) {
        state.globalSettings.wallpaper = newWallpaperBase64;
        changesMade = true;
    }
    
    // 保存聊天背景
    if (newChatBackgroundBase64) {
        state.globalSettings.chatBackground = newChatBackgroundBase64;
        changesMade = true;
    }

    // ▼▼▼ 在这里添加了缺失的代码 ▼▼▼
    const paddingTopValue = document.getElementById('chat-list-padding-top-input').value;
    state.globalSettings.chatListPaddingTop = parseInt(paddingTopValue) || 72;
    // ▲▲▲ 代码添加结束 ▲▲▲

    // 保存所有全局设置到数据库
    await db.globalSettings.put(state.globalSettings);

    // 应用所有更改
    if (changesMade) {
        applyGlobalWallpaper();
        applyGlobalChatBackground();
        newWallpaperBase64 = null;
        newChatBackgroundBase64 = null;
    }
    applyAppIcons(); // 重新应用所有图标
    applyChatListPaddingTop(); // <--- 关键！保存后立刻应用新的边距值

    alert('外观设置已保存并应用！');
    showScreen('home-screen');
});
// ▲▲▲ 替换结束 ▲▲▲
            document.getElementById('save-api-settings-btn').addEventListener('click', async () => { state.apiConfig.proxyUrl = document.getElementById('proxy-url').value.trim(); state.apiConfig.apiKey = document.getElementById('api-key').value.trim(); state.apiConfig.model = document.getElementById('model-select').value; await db.apiConfig.put(state.apiConfig); 

// 在 'save-api-settings-btn' 的 click 事件监听器内部
// await db.apiConfig.put(state.apiConfig); 这行之后

// ▼▼▼ 将之前那段保存后台活动设置的逻辑，替换为下面这个增强版 ▼▼▼

const backgroundSwitch = document.getElementById('background-activity-switch');
const intervalInput = document.getElementById('background-interval-input');
const newEnableState = backgroundSwitch.checked;
const oldEnableState = state.globalSettings.enableBackgroundActivity || false;

// 只有在用户“从关到开”时，才弹出警告
if (newEnableState && !oldEnableState) {
    const userConfirmed = confirm(
        "【高费用警告】\n\n" +
        "您正在启用“后台角色活动”功能。\n\n" +
        "这会使您的AI角色们在您不和他们聊天时，也能“独立思考”并主动给您发消息或进行社交互动，极大地增强沉浸感。\n\n" +
        "但请注意：\n" +
        "这会【在后台自动、定期地调用API】，即使您不进行任何操作。根据您的角色数量和检测间隔，这可能会导致您的API费用显著增加。\n\n" +
        "您确定要开启吗？"
    );

    if (!userConfirmed) {
        backgroundSwitch.checked = false; // 用户取消，把开关拨回去
        return; // 阻止后续逻辑
    }
}

state.globalSettings.enableBackgroundActivity = newEnableState;
state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
state.globalSettings.blockCooldownHours = parseFloat(document.getElementById('block-cooldown-input').value) || 1;
await db.globalSettings.put(state.globalSettings);

// 动态启动或停止模拟器
stopBackgroundSimulation();
if (state.globalSettings.enableBackgroundActivity) {
    startBackgroundSimulation();
    console.log(`后台活动模拟已启动，间隔: ${state.globalSettings.backgroundActivityInterval}秒`);
} else {
    console.log("后台活动模拟已停止。");
}
// ▲▲▲ 替换结束 ▲▲▲

alert('API设置已保存!'); 
// 刷新预设列表
window.renderApiPresets();
});

// ▼▼▼ API预设功能开始 ▼▼▼
// 保存API预设
document.getElementById('save-api-preset-btn').addEventListener('click', async () => {
    const proxyUrl = document.getElementById('proxy-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    const model = document.getElementById('model-select').value;
    
    if (!proxyUrl || !apiKey) {
        return alert('请先填写反代地址和密钥！');
    }
    
    const presetName = prompt('请输入预设名称：', `预设_${new Date().toLocaleDateString()}`);
    if (!presetName) return;
    
    const preset = {
        id: Date.now().toString(),
        name: presetName,
        proxyUrl: proxyUrl,
        apiKey: apiKey,
        model: model || '',
        createdAt: Date.now()
    };
    
    // 保存到数据库
    await db.apiPresets.add(preset);
    
    // 更新state
    state.apiPresets.push(preset);
    
    // 刷新显示
    window.renderApiPresets();
    
    alert(`预设"${presetName}"已保存！`);
});

// 渲染预设列表
window.renderApiPresets = function() {
    const container = document.getElementById('api-presets-list');
    if (!state.apiPresets || state.apiPresets.length === 0) {
        container.innerHTML = '<p style="color: #666; font-size: 14px; text-align: center; padding: 10px;">暂无保存的预设</p>';
        return;
    }
    
    container.innerHTML = state.apiPresets.map(preset => `
        <div class="preset-item" style="border: 1px solid #ddd; border-radius: 8px; padding: 10px; margin: 8px 0; background: #f9f9f9;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div style="flex: 1;">
                    <h4 style="margin: 0 0 5px 0; color: #333; font-size: 16px;">${preset.name}</h4>
                    <p style="margin: 0; color: #666; font-size: 12px;">
                        ${preset.proxyUrl} | ${preset.model || '未选择模型'}
                    </p>
                </div>
                <div>
                    <button class="preset-action-btn" onclick="applyApiPreset('${preset.id}')" 
                            style="background: #007bff; color: white; border: none; padding: 5px 10px; margin: 0 2px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        应用
                    </button>
                    <button class="preset-action-btn" onclick="editApiPreset('${preset.id}')" 
                            style="background: #28a745; color: white; border: none; padding: 5px 10px; margin: 0 2px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        编辑
                    </button>
                    <button class="preset-action-btn" onclick="deleteApiPreset('${preset.id}')" 
                            style="background: #dc3545; color: white; border: none; padding: 5px 10px; margin: 0 2px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        删除
                    </button>
                </div>
            </div>
        </div>
    `).join('');
}

// 应用预设
window.applyApiPreset = async function(presetId) {
    const preset = state.apiPresets.find(p => p.id === presetId);
    if (!preset) return alert('预设不存在！');

    document.getElementById('proxy-url').value = preset.proxyUrl;
    document.getElementById('api-key').value = preset.apiKey;

    // 【核心修改】应用预设后，立即调用拉取函数，并告诉它要选中哪个模型
    await fetchAndPopulateModels(preset.model);

    alert(`已应用预设"${preset.name}"！请在模型列表加载完成后，点击"保存设置"来完成保存。`);
}

// 编辑预设
window.editApiPreset = async function(presetId) {
    const preset = state.apiPresets.find(p => p.id === presetId);
    if (!preset) return alert('预设不存在！');
    
    const newName = prompt('请输入新的预设名称：', preset.name);
    if (!newName) return;
    
    // 获取当前表单值作为新的配置
    const proxyUrl = document.getElementById('proxy-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    const model = document.getElementById('model-select').value;
    
    if (!proxyUrl || !apiKey) {
        return alert('请先填写反代地址和密钥！');
    }
    
    // 更新预设
    preset.name = newName;
    preset.proxyUrl = proxyUrl;
    preset.apiKey = apiKey;
    preset.model = model || '';
    preset.updatedAt = Date.now();
    
    // 保存到数据库
    await db.apiPresets.put(preset);
    
    // 刷新显示
    window.renderApiPresets();
    
    alert(`预设"${newName}"已更新！`);
}

// 删除预设
window.deleteApiPreset = async function(presetId) {
    const preset = state.apiPresets.find(p => p.id === presetId);
    if (!preset) return alert('预设不存在！');
    
    if (!confirm(`确定要删除预设"${preset.name}"吗？`)) return;
    
    // 从数据库删除
    await db.apiPresets.delete(presetId);
    
    // 从state中移除
    const index = state.apiPresets.findIndex(p => p.id === presetId);
    if (index > -1) {
        state.apiPresets.splice(index, 1);
    }
    
    // 刷新显示
    window.renderApiPresets();
    
    alert(`预设"${preset.name}"已删除！`);
}
// ▲▲▲ API预设功能结束 ▲▲▲

                    // gemini 密钥聚焦的时候显示明文
        const ApiKeyInput = document.getElementById('api-key')
        ApiKeyInput.addEventListener('focus', (e) => {
            e.target.setAttribute('type', 'text')
        })
        ApiKeyInput.addEventListener('blur', (e) => {
            e.target.setAttribute('type', 'password')
        })


        // ▼▼▼ 第一步：创建一个可复用的函数来拉取和填充模型
async function fetchAndPopulateModels(modelToSelect = null) {
    const url = document.getElementById('proxy-url').value.trim();
    const key = document.getElementById('api-key').value.trim();
    if (!url || !key) return alert('请先填写反代地址和密钥');
    try {
        let isGemini = url === GEMINI_API_URL;
        const response = await fetch(isGemini ? `${GEMINI_API_URL}?key=${getRandomValue(key)}` : `${url}/v1/models`, isGemini ? undefined : { headers: { 'Authorization': `Bearer ${key}` } });
        if (!response.ok) throw new Error('无法获取模型列表');
        const data = await response.json();
        let models = isGemini ? data.models : data.data;
        if (isGemini) {
            models = models.map((model) => {
                const parts = model.name.split('/');
                return {
                    id: parts.length > 1 ? parts[1] : model.name
                }
            })
        }
        const modelSelect = document.getElementById('model-select');
        modelSelect.innerHTML = '';
        models.forEach(model => {
            const option = document.createElement('option');
            option.value = model.id;
            option.textContent = model.id;
            // 如果传入了要选中的模型，就在这里选中它
            if (model.id === modelToSelect) {
                option.selected = true;
            }
            modelSelect.appendChild(option);
        });
        // 如果传入了模型但列表中没有完全匹配的，也尝试将下拉框的值设为它
        if (modelToSelect) {
            modelSelect.value = modelToSelect;
        }
        alert('模型列表已更新');
    } catch (error) {
        alert(`拉取模型失败: ${error.message}`);
    }
}

// 第二步：让“拉取模型”按钮调用这个新函数
document.getElementById('fetch-models-btn').addEventListener('click', () => fetchAndPopulateModels());
            document.getElementById('add-world-book-btn').addEventListener('click', () => { showUnifiedWorldBookModal(); });
            document.getElementById('chat-messages').addEventListener('click', (e) => { const aiImage = e.target.closest('.ai-generated-image'); if (aiImage) { const description = aiImage.dataset.description; if (description) showCustomAlert('照片描述', description); return; }  });
            
            const chatSettingsModal = document.getElementById('chat-settings-modal');
            const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
            const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
            function updateWorldBookSelectionDisplay() {
    const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll('input.wb-book-checkbox:checked');
    const displayText = document.querySelector('.selected-options-text');
    if (checkedBoxes.length === 0) {
        displayText.textContent = '-- 点击选择 --';
    } else {
        // 始终显示所有选中的条目名称
        displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', ');
    }
}
            worldBookSelectBox.addEventListener('click', (e) => { e.stopPropagation(); worldBookCheckboxesContainer.classList.toggle('visible'); worldBookSelectBox.classList.toggle('expanded'); });
            document.getElementById('world-book-checkboxes-container').addEventListener('change', updateWorldBookSelectionDisplay);
            window.addEventListener('click', (e) => { if (!document.querySelector('.custom-multiselect').contains(e.target)) { worldBookCheckboxesContainer.classList.remove('visible'); worldBookSelectBox.classList.remove('expanded'); } });

            // 线下世界书的交互逻辑
            const worldBookSelectBoxOffline = document.querySelector('#world-book-link-group-offline .select-box');
            const worldBookCheckboxesContainerOffline = document.getElementById('world-book-checkboxes-container-offline');

            function updateWorldBookSelectionDisplayOffline() {
    const checkedBoxes = worldBookCheckboxesContainerOffline.querySelectorAll('input.wb-book-checkbox:checked');
    const displayText = document.querySelector('#world-book-link-group-offline .selected-options-text');
    if (checkedBoxes.length === 0) {
        displayText.textContent = '-- 点击选择 --';
    } else {
        // 始终显示所有选中的条目名称
        displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', ');
    }
}

            if (worldBookSelectBoxOffline) {
                worldBookSelectBoxOffline.addEventListener('click', (e) => { 
                    e.stopPropagation(); 
                    worldBookCheckboxesContainerOffline.classList.toggle('visible'); 
                    worldBookSelectBoxOffline.classList.toggle('expanded'); 
                });
            }
            
            if (worldBookCheckboxesContainerOffline) {
                worldBookCheckboxesContainerOffline.addEventListener('change', updateWorldBookSelectionDisplayOffline);
            }

            // 修改原来的全局点击监听，处理两个multiselect
            window.addEventListener('click', (e) => { 
                const multiselects = document.querySelectorAll('.custom-multiselect');
                multiselects.forEach(multiselect => {
                    if (!multiselect.contains(e.target)) {
                        const container = multiselect.querySelector('.checkboxes-container');
                        const selectBox = multiselect.querySelector('.select-box');
                        if (container) container.classList.remove('visible');
                        if (selectBox) selectBox.classList.remove('expanded');
                    }
                });
            });

// ▼▼▼ 请用这段【完整、全新的代码】替换旧的 chat-settings-btn 点击事件 ▼▼▼
document.getElementById('chat-settings-btn').addEventListener('click', async () => {
    renderBubblePresets(); //
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const isGroup = chat.isGroup;

    // --- 统一显示/隐藏控件 ---
    document.getElementById('chat-name-group').style.display = 'block';
    document.getElementById('my-persona-group').style.display = 'block';
    document.getElementById('my-avatar-group').style.display = 'block';
    document.getElementById('my-group-nickname-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-avatar-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-members-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('ai-persona-group').style.display = isGroup ? 'none' : 'block';
    document.getElementById('ai-avatar-group').style.display = isGroup ? 'none' : 'block';
    
    // 【核心修改1】根据是否为群聊，显示或隐藏“好友分组”区域
    document.getElementById('assign-group-section').style.display = isGroup ? 'none' : 'block';
    
    // --- 加载表单数据 ---
    document.getElementById('chat-name-input').value = chat.name;
    document.getElementById('my-persona').value = chat.settings.myPersona;
    document.getElementById('my-avatar-preview').src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
    // 【核心修改】加载新的记忆锚点
    document.getElementById('memory-anchor-input').value = chat.settings.memoryAnchor || 0;
    
    // 【全新添加】加载总结保留条数
    document.getElementById('summarize-reserve-input').value = chat.settings.summarizeReserveCount || 100;

    document.getElementById('cross-chat-memory-switch').checked = chat.settings.crossChatMemory || false;
    document.getElementById('active-reply-interval').value = chat.settings.activeReplyInterval || 0;
    const bgPreview = document.getElementById('bg-preview');
    const removeBgBtn = document.getElementById('remove-bg-btn');
    if (chat.settings.background) {
        bgPreview.src = chat.settings.background;
        bgPreview.style.display = 'block';
        removeBgBtn.style.display = 'inline-block';
    } else {
        bgPreview.style.display = 'none';
        removeBgBtn.style.display = 'none';
    }

    if (isGroup) {
        document.getElementById('my-group-nickname-input').value = chat.settings.myNickname || '';
        document.getElementById('group-avatar-preview').src = chat.settings.groupAvatar || defaultGroupAvatar;
        renderGroupMemberSettings(chat.members);
    } else {
        document.getElementById('ai-persona').value = chat.settings.aiPersona;
        document.getElementById('ai-avatar-preview').src = chat.settings.aiAvatar || defaultAvatar;
        
        // 【核心修改2】如果是单聊，就加载分组列表到下拉框
        const select = document.getElementById('assign-group-select');
        select.innerHTML = '<option value="">未分组</option>'; // 清空并设置默认选项
        const groups = await db.qzoneGroups.toArray();
        groups.forEach(group => {
            const option = document.createElement('option');
            option.value = group.id;
            option.textContent = group.name;
            // 如果当前好友已经有分组，就默认选中它
            if (chat.groupId === group.id) {
                option.selected = true;
            }
            select.appendChild(option);
        }); 
    }
    
    // 加载世界书
// ▼▼▼ 用下面这段【全新逻辑】替换掉原来简单的 forEach 循环 ▼▼▼

const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
worldBookCheckboxesContainer.innerHTML = '';
const linkedIds = new Set(chat.settings.linkedWorldBookIds || []);

// 1. 获取所有分类和世界书
const categories = await db.worldBookCategories.toArray();
const books = state.worldBooks;

// 【核心改造】如果存在未分类的书籍，就创建一个“虚拟分类”
const hasUncategorized = books.some(book => !book.categoryId);
if (hasUncategorized) {
    categories.push({ id: 'uncategorized', name: '未分类' });
}

// 2. 将书籍按分类ID进行分组
const booksByCategoryId = books.reduce((acc, book) => {
    const categoryId = book.categoryId || 'uncategorized';
    if (!acc[categoryId]) {
        acc[categoryId] = [];
    }
    acc[categoryId].push(book);
    return acc;
}, {});

// 3. 遍历分类，创建带折叠功能的列表
categories.forEach(category => {
    const booksInCategory = booksByCategoryId[category.id] || [];
    if (booksInCategory.length > 0) {
        const allInCategoryChecked = booksInCategory.every(book => linkedIds.has(book.id));
        
        const header = document.createElement('div');
        header.className = 'wb-category-header';
        header.innerHTML = `
            <div class="custom-checkbox ${allInCategoryChecked ? 'checked' : ''}" data-target-checkbox="wb-category-${category.id}">
                <div class="custom-checkbox-circle"></div>
            </div>
            <input type="checkbox" class="wb-category-checkbox" id="wb-category-${category.id}" data-category-id="${category.id}" ${allInCategoryChecked ? 'checked' : ''}>
            <span class="arrow">▼</span>
            <span>${category.name}</span>
        `;
        
        const bookContainer = document.createElement('div');
        bookContainer.className = 'wb-book-container';
        bookContainer.dataset.containerFor = category.id;

        booksInCategory.forEach(book => {
            const isChecked = linkedIds.has(book.id);
            const label = document.createElement('label');
            // 为已勾选的项目添加checked类
            if (isChecked) {
                label.classList.add('checked');
            }
            // 用DOM方法创建，避免innerHTML的空白符问题
            const customCheckbox = document.createElement('div');
            customCheckbox.className = `custom-checkbox ${isChecked ? 'checked' : ''}`;
            customCheckbox.setAttribute('data-target-checkbox', `wb-book-${book.id}`);
            
            const circle = document.createElement('div');
            circle.className = 'custom-checkbox-circle';
            customCheckbox.appendChild(circle);
            
            const hiddenCheckbox = document.createElement('input');
            hiddenCheckbox.type = 'checkbox';
            hiddenCheckbox.className = 'wb-book-checkbox';
            hiddenCheckbox.id = `wb-book-${book.id}`;
            hiddenCheckbox.value = book.id;
            hiddenCheckbox.setAttribute('data-parent-category', category.id);
            hiddenCheckbox.checked = isChecked;
            hiddenCheckbox.style.display = 'none';
            
            const nameSpan = document.createElement('span');
            nameSpan.textContent = book.name;
            nameSpan.style.whiteSpace = 'nowrap';
            
            label.appendChild(customCheckbox);
            label.appendChild(hiddenCheckbox);
            label.appendChild(nameSpan);
            bookContainer.appendChild(label);
        });

        // --- ★ 核心修改 #1 在这里 ★ ---
        // 默认将分类设置为折叠状态
        header.classList.add('collapsed');
        bookContainer.classList.add('collapsed');
        // --- ★ 修改结束 ★ ---

        worldBookCheckboxesContainer.appendChild(header);
        worldBookCheckboxesContainer.appendChild(bookContainer);
    }
});

updateWorldBookSelectionDisplay(); // 更新顶部的已选数量显示

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 在 updateWorldBookSelectionDisplay(); 的下一行，粘贴这整块新代码 ▼▼▼

// 使用事件委托来处理所有点击和勾选事件，效率更高
worldBookCheckboxesContainer.addEventListener('click', (e) => {
    // 处理自定义勾选框点击
    const customCheckbox = e.target.closest('.custom-checkbox');
    if (customCheckbox) {
        e.preventDefault();
        e.stopPropagation();
        const targetCheckboxId = customCheckbox.dataset.targetCheckbox;
        const targetCheckbox = document.getElementById(targetCheckboxId);
        if (targetCheckbox) {
            targetCheckbox.checked = !targetCheckbox.checked;
            customCheckbox.classList.toggle('checked', targetCheckbox.checked);
            // 触发change事件
            targetCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
        }
        return;
    }
    
    // 处理书籍标签点击（label元素）
    const bookLabel = e.target.closest('.wb-book-container label');
    if (bookLabel && !e.target.closest('.custom-checkbox')) {
        e.preventDefault();
        e.stopPropagation();
        const checkbox = bookLabel.querySelector('input[type="checkbox"]');
        if (checkbox) {
            checkbox.checked = !checkbox.checked;
            const customCheckbox = bookLabel.querySelector('.custom-checkbox');
            if (customCheckbox) {
                customCheckbox.classList.toggle('checked', checkbox.checked);
            }
            // 添加/移除label的checked类来控制背景色
            bookLabel.classList.toggle('checked', checkbox.checked);
            // 触发change事件
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
        }
        return;
    }
    
    const header = e.target.closest('.wb-category-header');
    if (header && !e.target.matches('input[type="checkbox"]') && !e.target.closest('.custom-checkbox')) {
        const categoryId = header.querySelector('.wb-category-checkbox')?.dataset.categoryId;
        if (categoryId) {
            const bookContainer = worldBookCheckboxesContainer.querySelector(`.wb-book-container[data-container-for="${categoryId}"]`);
            if (bookContainer) {
                header.classList.toggle('collapsed');
                bookContainer.classList.toggle('collapsed');
            }
        }
    }
});

worldBookCheckboxesContainer.addEventListener('change', (e) => {
    const target = e.target;
    
    // 同步自定义勾选框的视觉状态
    const targetId = target.id;
    if (targetId) {
        const customCheckbox = worldBookCheckboxesContainer.querySelector(`[data-target-checkbox="${targetId}"]`);
        if (customCheckbox) {
            customCheckbox.classList.toggle('checked', target.checked);
        }
        
        // 同步label的背景色
        const label = target.closest('label');
        if (label && label.closest('.wb-book-container')) {
            label.classList.toggle('checked', target.checked);
        }
    }
    
    // 如果点击的是分类的"全选"复选框
    if (target.classList.contains('wb-category-checkbox')) {
        const categoryId = target.dataset.categoryId;
        const isChecked = target.checked;
        // 找到这个分类下的所有书籍复选框，并将它们的状态设置为与分类复选框一致
        const bookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
        bookCheckboxes.forEach(cb => {
            cb.checked = isChecked;
            // 同步对应的自定义勾选框状态
            const customCheckbox = worldBookCheckboxesContainer.querySelector(`[data-target-checkbox="${cb.id}"]`);
            if (customCheckbox) {
                customCheckbox.classList.toggle('checked', isChecked);
            }
            // 同步label的背景色
            const label = cb.closest('label');
            if (label && label.closest('.wb-book-container')) {
                label.classList.toggle('checked', isChecked);
            }
        });
    }
    
    // 如果点击的是单个书籍的复选框
    if (target.classList.contains('wb-book-checkbox')) {
        const categoryId = target.dataset.parentCategory;
        if (categoryId) { // 检查它是否属于一个分类
            const categoryCheckbox = worldBookCheckboxesContainer.querySelector(`input.wb-category-checkbox[data-category-id="${categoryId}"]`);
            const allBookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
            // 检查该分类下是否所有书籍都被选中了
            const allChecked = Array.from(allBookCheckboxes).every(cb => cb.checked);
            // 同步分类"全选"复选框的状态
            if (categoryCheckbox) {
                categoryCheckbox.checked = allChecked;
                // 同步分类的自定义勾选框状态
                const categorycustomCheckbox = worldBookCheckboxesContainer.querySelector(`[data-target-checkbox="${categoryCheckbox.id}"]`);
                if (categorycustomCheckbox) {
                    categorycustomCheckbox.classList.toggle('checked', allChecked);
                }
            }
        }
    }
    
    // 每次变更后都更新顶部的已选数量显示
    updateWorldBookSelectionDisplay();
});

// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 线下世界书填充逻辑（复制线上逻辑并修改容器ID） ▼▼▼
const worldBookCheckboxesContainerOfflineData = document.getElementById('world-book-checkboxes-container-offline');
worldBookCheckboxesContainerOfflineData.innerHTML = '';
const linkedIdsOffline = new Set(chat.settings.linkedWorldBookIdsOffline || []);

// 1. 获取所有分类和世界书（线下）
const categoriesOffline = await db.worldBookCategories.toArray();
const booksOffline = state.worldBooks;

// 【核心改造】如果存在未分类的书籍，就创建一个"虚拟分类"
const hasUncategorizedOffline = booksOffline.some(book => !book.categoryId);
if (hasUncategorizedOffline) {
    categoriesOffline.push({ id: 'uncategorized', name: '未分类' });
}

// 2. 将书籍按分类ID进行分组（线下）
const booksByCategoryIdOffline = booksOffline.reduce((acc, book) => {
    const categoryId = book.categoryId || 'uncategorized';
    if (!acc[categoryId]) {
        acc[categoryId] = [];
    }
    acc[categoryId].push(book);
    return acc;
}, {});

// 3. 遍历分类，创建带折叠功能的列表（线下）- 完全复制线上结构
categoriesOffline.forEach(category => {
    const booksInCategory = booksByCategoryIdOffline[category.id] || [];
    if (booksInCategory.length > 0) {
        const allInCategoryChecked = booksInCategory.every(book => linkedIdsOffline.has(book.id));
        
        const header = document.createElement('div');
        header.className = 'wb-category-header';
        header.innerHTML = `
            <div class="custom-checkbox ${allInCategoryChecked ? 'checked' : ''}" data-target-checkbox="wb-category-offline-${category.id}">
                <div class="custom-checkbox-circle"></div>
            </div>
            <input type="checkbox" class="wb-category-checkbox" id="wb-category-offline-${category.id}" data-category-id="${category.id}" ${allInCategoryChecked ? 'checked' : ''}>
            <span class="arrow">▼</span>
            <span>${category.name}</span>
        `;
        
        const bookContainer = document.createElement('div');
        bookContainer.className = 'wb-book-container';
        bookContainer.dataset.containerFor = category.id;

        booksInCategory.forEach(book => {
            const isChecked = linkedIdsOffline.has(book.id);
            const label = document.createElement('label');
            // 为已勾选的项目添加checked类
            if (isChecked) {
                label.classList.add('checked');
            }
            // 用DOM方法创建，避免innerHTML的空白符问题
            const customCheckbox = document.createElement('div');
            customCheckbox.className = `custom-checkbox ${isChecked ? 'checked' : ''}`;
            customCheckbox.setAttribute('data-target-checkbox', `wb-book-offline-${book.id}`);
            
            const circle = document.createElement('div');
            circle.className = 'custom-checkbox-circle';
            customCheckbox.appendChild(circle);
            
            const hiddenCheckbox = document.createElement('input');
            hiddenCheckbox.type = 'checkbox';
            hiddenCheckbox.className = 'wb-book-checkbox';
            hiddenCheckbox.id = `wb-book-offline-${book.id}`;
            hiddenCheckbox.value = book.id;
            hiddenCheckbox.setAttribute('data-parent-category', category.id);
            hiddenCheckbox.checked = isChecked;
            hiddenCheckbox.style.display = 'none';
            
            const nameSpan = document.createElement('span');
            nameSpan.textContent = book.name;
            nameSpan.style.whiteSpace = 'nowrap';
            
            label.appendChild(customCheckbox);
            label.appendChild(hiddenCheckbox);
            label.appendChild(nameSpan);
            bookContainer.appendChild(label);
        });

        // 默认将分类设置为折叠状态
        header.classList.add('collapsed');
        bookContainer.classList.add('collapsed');
        
        worldBookCheckboxesContainerOfflineData.appendChild(header);
        worldBookCheckboxesContainerOfflineData.appendChild(bookContainer);
    }
});

// 添加线下世界书的事件处理器 - 完全复制线上逻辑
worldBookCheckboxesContainerOfflineData.addEventListener('click', (e) => {
    // 处理自定义勾选框点击
    const customCheckbox = e.target.closest('.custom-checkbox');
    if (customCheckbox) {
        e.preventDefault();
        e.stopPropagation();
        const targetCheckboxId = customCheckbox.dataset.targetCheckbox;
        const targetCheckbox = document.getElementById(targetCheckboxId);
        if (targetCheckbox) {
            targetCheckbox.checked = !targetCheckbox.checked;
            customCheckbox.classList.toggle('checked', targetCheckbox.checked);
            // 触发change事件
            targetCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
        }
        return;
    }
    
    // 处理书籍标签点击（label元素）
    const bookLabel = e.target.closest('.wb-book-container label');
    if (bookLabel && !e.target.closest('.custom-checkbox')) {
        e.preventDefault();
        e.stopPropagation();
        const checkbox = bookLabel.querySelector('input[type="checkbox"]');
        if (checkbox) {
            checkbox.checked = !checkbox.checked;
            const customCheckbox = bookLabel.querySelector('.custom-checkbox');
            if (customCheckbox) {
                customCheckbox.classList.toggle('checked', checkbox.checked);
            }
            // 添加/移除label的checked类来控制背景色
            bookLabel.classList.toggle('checked', checkbox.checked);
            // 触发change事件
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
        }
        return;
    }
    
    const header = e.target.closest('.wb-category-header');
    if (header && !e.target.matches('input[type="checkbox"]') && !e.target.closest('.custom-checkbox')) {
        const categoryId = header.querySelector('.wb-category-checkbox')?.dataset.categoryId;
        if (categoryId) {
            const bookContainer = worldBookCheckboxesContainerOfflineData.querySelector(`.wb-book-container[data-container-for="${categoryId}"]`);
            if (bookContainer) {
                header.classList.toggle('collapsed');
                bookContainer.classList.toggle('collapsed');
            }
        }
    }
});

worldBookCheckboxesContainerOfflineData.addEventListener('change', (e) => {
    const target = e.target;
    
    // 同步自定义勾选框的视觉状态
    const customCheckbox = worldBookCheckboxesContainerOfflineData.querySelector(`[data-target-checkbox="${target.id}"]`);
    if (customCheckbox) {
        customCheckbox.classList.toggle('checked', target.checked);
    }
    
    // 如果点击的是分类的"全选"复选框
    if (target.classList.contains('wb-category-checkbox')) {
        const categoryId = target.dataset.categoryId;
        const allBookCheckboxes = worldBookCheckboxesContainerOfflineData.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
        const isChecked = target.checked;
        allBookCheckboxes.forEach(cb => {
            cb.checked = isChecked;
            // 同步对应的自定义勾选框状态
            const customCheckbox = worldBookCheckboxesContainerOfflineData.querySelector(`[data-target-checkbox="${cb.id}"]`);
            if (customCheckbox) {
                customCheckbox.classList.toggle('checked', isChecked);
            }
            // 同步label的背景色
            const label = cb.closest('label');
            if (label && label.closest('.wb-book-container')) {
                label.classList.toggle('checked', isChecked);
            }
        });
    }
    
    // 如果点击的是单个书籍的复选框
    if (target.classList.contains('wb-book-checkbox')) {
        // 同步当前书籍label的背景色
        const label = target.closest('label');
        if (label && label.closest('.wb-book-container')) {
            label.classList.toggle('checked', target.checked);
        }
        
        const categoryId = target.dataset.parentCategory;
        if (categoryId) { // 检查it是否属于一个分类
            const categoryCheckbox = worldBookCheckboxesContainerOfflineData.querySelector(`input.wb-category-checkbox[data-category-id="${categoryId}"]`);
            const allBookCheckboxes = worldBookCheckboxesContainerOfflineData.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
            // 检查该分类下是否所有书籍都被选中了
            const allChecked = Array.from(allBookCheckboxes).every(cb => cb.checked);
            // 同步分类"全选"复选框的状态
            if (categoryCheckbox) {
                categoryCheckbox.checked = allChecked;
                // 同步分类的自定义勾选框状态
                const categorycustomCheckbox = worldBookCheckboxesContainerOfflineData.querySelector(`[data-target-checkbox="${categoryCheckbox.id}"]`);
                if (categorycustomCheckbox) {
                    categorycustomCheckbox.classList.toggle('checked', allChecked);
                }
            }
        }
    }
    
    // 每次变更后都更新顶部的已选数量显示
    updateWorldBookSelectionDisplayOffline();
});
// ▲▲▲ 线下世界书填充逻辑结束 ▲▲▲
// ▼▼▼ 在这里添加下面这行代码 ▼▼▼
updateWorldBookSelectionDisplayOffline(); // 更新顶部的已选数量显示
// ▲▲▲ 添加结束 ▲▲▲
    // 加载并更新所有预览相关控件 (主题选择器已删除)
    const fontSizeSlider = document.getElementById('font-size-slider');
    // 【核心修改】从全局设置读取字体大小
    fontSizeSlider.value = state.globalSettings.fontSize || 13;
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    // 初始化滑块进度颜色
    updateSliderProgress(fontSizeSlider);
    const customCssInput = document.getElementById('custom-css-input');
    customCssInput.value = chat.settings.customCss || '';
    
    updateSettingsPreview(); 
    document.getElementById('chat-settings-modal').classList.add('visible');
});
// ▲▲▲ 替换结束 ▲▲▲
            
function renderGroupMemberSettings(members) { 
    const container = document.getElementById('group-members-settings'); 
    container.innerHTML = ''; 
    members.forEach(member => { 
        const div = document.createElement('div'); 
        div.className = 'member-editor'; 
        div.dataset.memberId = member.id; 
        // ★★★【核心重构】★★★
        // 显示的是 groupNickname
        div.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><div class="member-name">${member.groupNickname}</div>`; 
        div.addEventListener('click', () => openMemberEditor(member.id)); 
        container.appendChild(div); 
    }); 
}

function openMemberEditor(memberId) { 
    editingMemberId = memberId; 
    const chat = state.chats[state.activeChatId]; 
    const member = chat.members.find(m => m.id === memberId); 
    document.getElementById('member-name-input').value = member.groupNickname; 
    document.getElementById('member-persona-input').value = member.persona; 
    document.getElementById('member-avatar-preview').src = member.avatar; 
    document.getElementById('member-settings-modal').classList.add('visible'); 
}
            document.getElementById('cancel-member-settings-btn').addEventListener('click', () => { document.getElementById('member-settings-modal').classList.remove('visible'); editingMemberId = null; });
            document.getElementById('save-member-settings-btn').addEventListener('click', () => { 
    if (!editingMemberId) return; 
    const chat = state.chats[state.activeChatId]; 
    const member = chat.members.find(m => m.id === editingMemberId); 
    
    // ★★★【核心重构】★★★
    const newNickname = document.getElementById('member-name-input').value.trim();
    if (!newNickname) {
        alert("群昵称不能为空！");
        return;
    }
    member.groupNickname = newNickname; // 只修改群昵称
    member.persona = document.getElementById('member-persona-input').value; 
    member.avatar = document.getElementById('member-avatar-preview').src; 
    
    renderGroupMemberSettings(chat.members); 
    document.getElementById('member-settings-modal').classList.remove('visible'); 
});
            document.getElementById('cancel-chat-settings-btn').addEventListener('click', () => { chatSettingsModal.classList.remove('visible'); });

document.getElementById('save-chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const newName = document.getElementById('chat-name-input').value.trim();
    if (!newName) return alert('备注名/群名不能为空！');
    chat.name = newName;
    chat.settings.theme = 'default'; // 固定使用默认主题

    // 【核心修改1】将字体大小保存到全局设置
    const newFontSize = parseInt(document.getElementById('font-size-slider').value);
    state.globalSettings.fontSize = newFontSize;
    await db.globalSettings.put(state.globalSettings); // 保存全局设置

    // 【核心修改2】遍历所有聊天，同步字体大小
    for (const chatId in state.chats) {
        state.chats[chatId].settings.fontSize = newFontSize;
    }
    await db.chats.bulkPut(Object.values(state.chats)); // 批量更新所有聊天

    chat.settings.customCss = document.getElementById('custom-css-input').value.trim();
    chat.settings.myPersona = document.getElementById('my-persona').value;
    chat.settings.myAvatar = document.getElementById('my-avatar-preview').src;
const checkedBooks = document.querySelectorAll('#world-book-checkboxes-container input.wb-book-checkbox:checked');
    chat.settings.linkedWorldBookIds = Array.from(checkedBooks).map(cb => cb.value);

    // 保存线下世界书选择
    const checkedBooksOffline = document.querySelectorAll('#world-book-checkboxes-container-offline input.wb-book-checkbox:checked');
    chat.settings.linkedWorldBookIdsOffline = Array.from(checkedBooksOffline).map(cb => cb.value);

    if (chat.isGroup) {
        chat.settings.myNickname = document.getElementById('my-group-nickname-input').value.trim();
        chat.settings.groupAvatar = document.getElementById('group-avatar-preview').src;
    } else {
        chat.settings.aiPersona = document.getElementById('ai-persona').value;
            chat.settings.aiAvatar = document.getElementById('ai-avatar-preview').src;
            const selectedGroupId = document.getElementById('assign-group-select').value;
            chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
        }

        // 【核心修改】保存新的记忆锚点
        chat.settings.memoryAnchor = parseInt(document.getElementById('memory-anchor-input').value) || 0;
        
        // 【全新添加】保存总结保留条数
        chat.settings.summarizeReserveCount = parseInt(document.getElementById('summarize-reserve-input').value) || 100;

        chat.settings.crossChatMemory = document.getElementById('cross-chat-memory-switch').checked;
        
        // 【修改】支持小数，并设置最小间隔为0.1小时
    const activeReplyIntervalInput = parseFloat(document.getElementById('active-reply-interval').value) || 0;
    if (activeReplyIntervalInput > 0 && activeReplyIntervalInput < 0.1) {
        chat.settings.activeReplyInterval = 0.1; // 强制最小间隔为0.1小时
    } else {
        chat.settings.activeReplyInterval = activeReplyIntervalInput;
    }
    await db.chats.put(chat);

    applyScopedCss(chat.settings.customCss, '#chat-messages', 'custom-bubble-style');
    
    chatSettingsModal.classList.remove('visible');
    renderChatInterface(state.activeChatId);
    renderChatList();
});
            document.getElementById('clear-chat-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const confirmed = await showCustomConfirm('清空聊天记录', '此操作将永久删除此聊天的所有消息，无法恢复。确定要清空吗？', { confirmButtonClass: 'btn-danger' }); if (confirmed) { chat.history = []; await db.chats.put(chat); renderChatInterface(state.activeChatId); renderChatList(); chatSettingsModal.classList.remove('visible'); } });
            
            const setupFileUpload = (inputId, callback) => { document.getElementById(inputId).addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); callback(dataUrl); event.target.value = null; } }); };
            setupFileUpload('ai-avatar-input', (base64) => document.getElementById('ai-avatar-preview').src = base64);
            setupFileUpload('my-avatar-input', (base64) => document.getElementById('my-avatar-preview').src = base64);
            setupFileUpload('group-avatar-input', (base64) => document.getElementById('group-avatar-preview').src = base64);
            setupFileUpload('member-avatar-input', (base64) => document.getElementById('member-avatar-preview').src = base64);
            setupFileUpload('bg-input', (base64) => { if(state.activeChatId) { state.chats[state.activeChatId].settings.background = base64; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = base64; bgPreview.style.display = 'block'; document.getElementById('remove-bg-btn').style.display = 'inline-block'; } });
            setupFileUpload('preset-avatar-input', (base64) => document.getElementById('preset-avatar-preview').src = base64);
            document.getElementById('remove-bg-btn').addEventListener('click', () => { if (state.activeChatId) { state.chats[state.activeChatId].settings.background = ''; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = ''; bgPreview.style.display = 'none'; document.getElementById('remove-bg-btn').style.display = 'none'; } });

            const stickerPanel = document.getElementById('sticker-panel');
            document.getElementById('open-sticker-panel-btn').addEventListener('click', (e) => { 
                e.stopPropagation(); 
                closePlusPanel(); 
                renderStickerPanel(); 
                stickerPanel.classList.add('visible'); 
            });
            
            // 点击面板外区域关闭表情面板
            document.addEventListener('click', (e) => {
                if (stickerPanel.classList.contains('visible') && 
                    !stickerPanel.contains(e.target) && 
                    !e.target.closest('.modal') && 
                    !e.target.closest('#custom-modal-overlay') &&
                    e.target.id !== 'sticker-upload-input') {
                    stickerPanel.classList.remove('visible');
                }
            });
            document.getElementById('add-sticker-btn').addEventListener('click', async () => { const url = await showCustomPrompt("添加表情(URL)", "请输入表情包的图片URL"); if (!url || !url.trim().startsWith('http')) return url && alert("请输入有效的URL (以http开头)"); const name = await showCustomPrompt("命名表情", "请为这个表情命名 (例如：开心、疑惑)"); if (name && name.trim()) { const newSticker = { id: 'sticker_' + Date.now(), url: url.trim(), name: name.trim() }; await db.userStickers.add(newSticker); state.userStickers.push(newSticker); renderStickerPanel(); } else if (name !== null) alert("表情名不能为空！"); });
            document.getElementById('upload-sticker-btn').addEventListener('click', (e) => { e.stopPropagation(); document.getElementById('sticker-upload-input').click(); });
            document.getElementById('sticker-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.readAsDataURL(file); reader.onload = async () => { const base64Url = reader.result; const name = await showCustomPrompt("命名表情", "请为这个表情命名 (例如：好耶、疑惑)"); if (name && name.trim()) { const newSticker = { id: 'sticker_' + Date.now(), url: base64Url, name: name.trim() }; await db.userStickers.add(newSticker); state.userStickers.push(newSticker); renderStickerPanel(); } else if (name !== null) alert("表情名不能为空！"); }; event.target.value = null; });
            document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
            // ▼▼▼ 请用这段【新代码】替换旧的 'image-upload-input' 事件监听器 ▼▼▼
document.getElementById('image-upload-input').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (!file || !state.activeChatId) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        const base64Url = e.target.result;
        const chat = state.chats[state.activeChatId];
        const msg = { role: 'user', content: [{ type: 'image_url', image_url: { url: base64Url } }], timestamp: Date.now() };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        renderChatList();

        // 【核心修复】上传并发送图片后，关闭功能面板
        closePlusPanel();
    };
    reader.readAsDataURL(file);
    event.target.value = null;
});
// ▲▲▲ 替换结束 ▲▲▲           
            document.getElementById('voice-message-btn').addEventListener('click', async () => { if (!state.activeChatId) return; closePlusPanel(); const text = await showCustomPrompt("发送语音", "请输入你想说的内容："); if (text && text.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'voice_message', content: text.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });
// ▼▼▼ 请用这段【新代码】替换旧的 'send-photo-btn' 事件监听器 ▼▼▼
document.getElementById('send-photo-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const description = await showCustomPrompt("发送照片", "请用文字描述您要发送的照片：");
    if (description && description.trim()) {
        const chat = state.chats[state.activeChatId];
        const msg = { role: 'user', type: 'user_photo', content: description.trim(), timestamp: Date.now() };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        renderChatList();

        // 【核心修复】在这里调用关闭面板的函数
        closePlusPanel();
    }
});
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新】外卖请求功能事件绑定 (已重构) ▼▼▼
const waimaiModal = document.getElementById('waimai-request-modal');

// 1. 创建一个可复用的函数来处理外卖请求的点击
function handleWaimaiRequest() {
    waimaiModal.classList.add('visible');
    closePlusPanel(); // 打开弹窗后，立刻关闭功能面板
}

// 2. 让单聊和群聊的按钮都调用这个新函数
document.getElementById('send-waimai-request-btn').addEventListener('click', handleWaimaiRequest);
document.getElementById('send-waimai-request-btn-group').addEventListener('click', handleWaimaiRequest);

document.getElementById('waimai-cancel-btn').addEventListener('click', () => {
    waimaiModal.classList.remove('visible');
});

document.getElementById('waimai-confirm-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    
    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');
    
    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    if (!productInfo) {
        alert('请输入商品信息！');
        return;
    }
    if (isNaN(amount) || amount <= 0) {
        alert('请输入有效的代付金额！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();

    // 【核心修正】在这里获取用户自己的昵称
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    const msg = {
        role: 'user',
        // 【核心修正】将获取到的昵称，作为 senderName 添加到消息对象中
        senderName: myNickname, 
        type: 'waimai_request',
        productInfo: productInfo,
        amount: amount,
        status: 'pending',
        countdownEndTime: now + 15 * 60 * 1000,
        timestamp: now
    };

    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();

    productInfoInput.value = '';
    amountInput.value = '';
    waimaiModal.classList.remove('visible');
});         
            document.getElementById('open-persona-library-btn').addEventListener('click', openPersonaLibrary);
            document.getElementById('close-persona-library-btn').addEventListener('click', closePersonaLibrary);
            document.getElementById('add-persona-preset-btn').addEventListener('click', openPersonaEditorForCreate);
            document.getElementById('cancel-persona-editor-btn').addEventListener('click', closePersonaEditor);
            document.getElementById('save-persona-preset-btn').addEventListener('click', savePersonaPreset);
            document.getElementById('preset-action-edit').addEventListener('click', openPersonaEditorForEdit);
            document.getElementById('preset-action-delete').addEventListener('click', deletePersonaPreset);
            document.getElementById('preset-action-cancel').addEventListener('click', hidePresetActions);
            
            document.getElementById('selection-cancel-btn').addEventListener('click', exitSelectionMode);

// ▼▼▼ 【最终加强版】用这块代码替换旧的 selection-delete-btn 事件监听器 ▼▼▼
document.getElementById('selection-delete-btn').addEventListener('click', async () => {
    if (selectedMessages.size === 0) return;
    const confirmed = await showCustomConfirm('删除消息', `确定要删除选中的 ${selectedMessages.size} 条消息吗？这将改变AI的记忆。`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        
        // ▼▼▼ 从这里开始替换 ▼▼▼
        
        // 1. 创建一个包含所有待删除消息时间戳的完整集合
        const timestampsToDelete = new Set(selectedMessages);

        // 2. 遍历用户选择的消息，查找需要联动删除的隐藏消息
        for (const timestamp of selectedMessages) {
            const msgIndex = chat.history.findIndex(m => m.timestamp === timestamp);
            if (msgIndex === -1) continue;

            const triggerMsg = chat.history[msgIndex];

            // 联动删除 "拍一拍" 相关的两条隐藏消息
            if (triggerMsg.type === 'pat_message' && triggerMsg.content.includes('拍了拍')) {
                // 检查后面紧邻的两条消息是否是我们的目标
                const hiddenMsg1 = chat.history[msgIndex + 1];
                const hiddenMsg2 = chat.history[msgIndex + 2];
                // 检查系统提示
                if (hiddenMsg1 && hiddenMsg1.isHidden && hiddenMsg1.role === 'system' && hiddenMsg1.content.includes('用户刚刚拍了拍你')) {
                    timestampsToDelete.add(hiddenMsg1.timestamp);
                }
                // 检查隐藏的用户消息
                if (hiddenMsg2 && hiddenMsg2.isHidden && hiddenMsg2.role === 'user' && hiddenMsg2.content === '你被拍了一下') {
                    timestampsToDelete.add(hiddenMsg2.timestamp);
                }
            }

            // 联动删除 "通话结束" 相关的两条隐藏消息
            if (triggerMsg.content && typeof triggerMsg.content === 'string' && triggerMsg.content.startsWith('通话结束，时长')) {
                 // 检查后面紧邻的两条消息
                const hiddenMsg1 = chat.history[msgIndex + 1];
                const hiddenMsg2 = chat.history[msgIndex + 2];
                // 检查通话汇报指令
                if (hiddenMsg1 && hiddenMsg1.isHidden && hiddenMsg1.role === 'system' && hiddenMsg1.content.includes('视频通话刚刚结束')) {
                    timestampsToDelete.add(hiddenMsg1.timestamp);
                }
                // 检查隐藏的用户消息
                if (hiddenMsg2 && hiddenMsg2.isHidden && hiddenMsg2.role === 'user' && hiddenMsg2.content === '（视频通话已结束，请根据视频通话内容继续聊天）') {
                    timestampsToDelete.add(hiddenMsg2.timestamp);
                }
            }
        }
        
        // 3. 使用包含了所有（可见与隐藏）待删除消息的完整集合，来执行最终的过滤
        chat.history = chat.history.filter(msg => !timestampsToDelete.has(msg.timestamp));
                        
        // 4. 【已修改】直接将更新后的chat对象存回数据库
        await db.chats.put(chat);
        
        // 5. 最后才更新UI
        renderChatInterface(state.activeChatId);

        // ▲▲▲ 替换到这里结束 ▲▲▲
    }
});

            const fontUrlInput = document.getElementById('font-url-input');
            // 优化字体预览：添加防抖功能，避免频繁调用
            let fontPreviewTimeout;
            fontUrlInput.addEventListener('input', () => {
                clearTimeout(fontPreviewTimeout);
                fontPreviewTimeout = setTimeout(() => {
                    applyCustomFont(fontUrlInput.value.trim(), true);
                }, 300); // 300ms 防抖延迟
            });
            document.getElementById('save-font-btn').addEventListener('click', async () => {
                const newFontUrl = fontUrlInput.value.trim();
                if (!newFontUrl) { alert("请输入有效的字体URL。"); return; }
                applyCustomFont(newFontUrl, false);
                state.globalSettings.fontUrl = newFontUrl;
                await db.globalSettings.put(state.globalSettings);
                alert('字体已保存并应用！');
            });
            document.getElementById('reset-font-btn').addEventListener('click', resetToDefaultFont);

            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => { item.addEventListener('click', () => switchToChatListView(item.dataset.view)); });
            document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
            document.getElementById('qzone-nickname').addEventListener('click', async () => { const newNickname = await showCustomPrompt("修改昵称", "请输入新的昵称", state.qzoneSettings.nickname); if (newNickname && newNickname.trim()) { state.qzoneSettings.nickname = newNickname.trim(); await saveQzoneSettings(); renderQzoneScreen(); } });
            document.getElementById('qzone-avatar-container').addEventListener('click', () => document.getElementById('qzone-avatar-input').click());
            document.getElementById('qzone-banner-container').addEventListener('click', () => document.getElementById('qzone-banner-input').click());
            document.getElementById('qzone-avatar-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.avatar = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
            document.getElementById('qzone-banner-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.banner = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });

// ▼▼▼ 【修正后】的“说说”按钮事件 ▼▼▼
document.getElementById('create-shuoshuo-btn').addEventListener('click', async () => {
    // 1. 重置并获取模态框
    resetCreatePostModal();
    const modal = document.getElementById('create-post-modal');
    
    // 2. 设置为“说说”模式
    modal.dataset.mode = 'shuoshuo';
    
    // 3. 隐藏与图片/文字图相关的部分
    modal.querySelector('.post-mode-switcher').style.display = 'none';
    modal.querySelector('#image-mode-content').style.display = 'none';
    modal.querySelector('#text-image-mode-content').style.display = 'none';
    
    // 4. 修改主输入框的提示语，使其更符合“说说”的场景
    modal.querySelector('#post-public-text').placeholder = '分享新鲜事...';
    
    // 5. 准备并显示模态框
    const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
    visibilityGroupsContainer.innerHTML = '';
    const groups = await db.qzoneGroups.toArray();
    if (groups.length > 0) {
        groups.forEach(group => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
            visibilityGroupsContainer.appendChild(label);
        });
    } else {
        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">没有可用的分组</p>';
    }
    modal.classList.add('visible');
});

// ▼▼▼ 【修正后】的“动态”（图片）按钮事件 ▼▼▼
document.getElementById('create-post-btn').addEventListener('click', async () => {
    // 1. 重置并获取模态框
    resetCreatePostModal();
    const modal = document.getElementById('create-post-modal');
    
    // 2. 设置为“复杂动态”模式
    modal.dataset.mode = 'complex';
    
// 3. 确保与图片/文字图相关的部分是可见的
modal.querySelector('.post-mode-switcher').style.display = 'flex';
// 显式激活“上传图片”模式...
modal.querySelector('#image-mode-content').classList.add('active');
// ...同时确保“文字图”模式是隐藏的
modal.querySelector('#text-image-mode-content').classList.remove('active');
    
    // 4. 恢复主输入框的默认提示语
    modal.querySelector('#post-public-text').placeholder = '分享新鲜事...（非必填的公开文字）';

    // 5. 准备并显示模态框（与“说说”按钮的逻辑相同）
    const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
    visibilityGroupsContainer.innerHTML = '';
    const groups = await db.qzoneGroups.toArray();
    if (groups.length > 0) {
        groups.forEach(group => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
            visibilityGroupsContainer.appendChild(label);
        });
    } else {
        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">没有可用的分组</p>';
    }
    modal.classList.add('visible');
});
            document.getElementById('open-album-btn').addEventListener('click', async () => { await renderAlbumList(); showScreen('album-screen'); });
            document.getElementById('album-back-btn').addEventListener('click', () => { showScreen('chat-list-screen'); switchToChatListView('qzone-screen'); });

// --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

document.getElementById('album-photos-back-btn').addEventListener('click', () => {
    state.activeAlbumId = null;
    showScreen('album-screen');
});

document.getElementById('album-upload-photo-btn').addEventListener('click', () => document.getElementById('album-photo-input').click());

document.getElementById('album-photo-input').addEventListener('change', async (event) => {
    if (!state.activeAlbumId) return;
    const files = event.target.files;
    if (!files.length) return;

    const album = await db.qzoneAlbums.get(state.activeAlbumId);
    
    for (const file of files) {
        const dataUrl = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(file);
        });
        await db.qzonePhotos.add({ albumId: state.activeAlbumId, url: dataUrl, createdAt: Date.now() });
    }

    const photoCount = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).count();
    const updateData = { photoCount };
    
    if (!album.photoCount || album.coverUrl.includes('placeholder')) {
        const firstPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
        if(firstPhoto) updateData.coverUrl = firstPhoto.url;
    }

    await db.qzoneAlbums.update(state.activeAlbumId, updateData);
    await renderAlbumPhotosScreen();
    await renderAlbumList();
    
    event.target.value = null;
    alert('照片上传成功！');
});

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---

// --- ↓↓↓ 从这里开始复制，完整替换掉旧的 photos-grid-page 监听器 ↓↓↓ ---

document.getElementById('photos-grid-page').addEventListener('click', async (e) => {
    const deleteBtn = e.target.closest('.photo-delete-btn');
    const photoThumb = e.target.closest('.photo-thumb');

    if (deleteBtn) {
        e.stopPropagation(); // 阻止事件冒泡到图片上
        const photoId = parseInt(deleteBtn.dataset.photoId);
        const confirmed = await showCustomConfirm(
            '删除照片',
            '确定要删除这张照片吗？此操作不可恢复。',
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            const deletedPhoto = await db.qzonePhotos.get(photoId);
            if (!deletedPhoto) return;
            
            await db.qzonePhotos.delete(photoId);

            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            const photoCount = (album.photoCount || 1) - 1;
            const updateData = { photoCount };
            
            if (album.coverUrl === deletedPhoto.url) {
                const nextPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                updateData.coverUrl = nextPhoto ? nextPhoto.url : 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            }
            
            await db.qzoneAlbums.update(state.activeAlbumId, updateData);
            await renderAlbumPhotosScreen();
            await renderAlbumList();
            alert('照片已删除。');
        }
    } 
    else if (photoThumb) {
        // 这就是恢复的图片点击放大功能！
        openPhotoViewer(photoThumb.src);
    }
});

// 恢复图片查看器的控制事件
document.getElementById('photo-viewer-close-btn').addEventListener('click', closePhotoViewer);
document.getElementById('photo-viewer-next-btn').addEventListener('click', showNextPhoto);
document.getElementById('photo-viewer-prev-btn').addEventListener('click', showPrevPhoto);

// 恢复键盘左右箭头和ESC键的功能
document.addEventListener('keydown', (e) => {
    if (!photoViewerState.isOpen) return; 

    if (e.key === 'ArrowRight') {
        showNextPhoto();
    } else if (e.key === 'ArrowLeft') {
        showPrevPhoto();
    } else if (e.key === 'Escape') {
        closePhotoViewer();
    }
});

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
         
document.getElementById('create-album-btn-page').addEventListener('click', async () => { const albumName = await showCustomPrompt("创建新相册", "请输入相册名称"); if (albumName && albumName.trim()) { const newAlbum = { name: albumName.trim(), coverUrl: 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png', photoCount: 0, createdAt: Date.now() }; await db.qzoneAlbums.add(newAlbum); await renderAlbumList(); alert(`相册 "${albumName}" 创建成功！`); } else if (albumName !== null) { alert("相册名称不能为空！"); } });

            document.getElementById('cancel-create-post-btn').addEventListener('click', () => document.getElementById('create-post-modal').classList.remove('visible'));
            document.getElementById('post-upload-local-btn').addEventListener('click', () => document.getElementById('post-local-image-input').click());
            document.getElementById('post-local-image-input').addEventListener('change', (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { document.getElementById('post-image-preview').src = e.target.result; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; }; reader.readAsDataURL(file); } });
            document.getElementById('post-use-url-btn').addEventListener('click', async () => { const url = await showCustomPrompt("输入图片URL", "请输入网络图片的链接", "", "url"); if (url) { document.getElementById('post-image-preview').src = url; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; } });
            document.getElementById('post-remove-image-btn').addEventListener('click', () => resetCreatePostModal());
            const imageModeBtn = document.getElementById('switch-to-image-mode');
            const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
            const imageModeContent = document.getElementById('image-mode-content');
            const textImageModeContent = document.getElementById('text-image-mode-content');
            imageModeBtn.addEventListener('click', () => { imageModeBtn.classList.add('active'); textImageModeBtn.classList.remove('active'); imageModeContent.classList.add('active'); textImageModeContent.classList.remove('active'); });
            textImageModeBtn.addEventListener('click', () => { textImageModeBtn.classList.add('active'); imageModeBtn.classList.remove('active'); textImageModeContent.classList.add('active'); imageModeContent.classList.remove('active'); });

// ▼▼▼ 【最终修正版】的“发布”按钮事件，已修复权限漏洞 ▼▼▼
document.getElementById('confirm-create-post-btn').addEventListener('click', async () => {
    const modal = document.getElementById('create-post-modal');
    const mode = modal.dataset.mode;
    
    // --- 1. 获取通用的可见性设置 ---
    const visibilityMode = document.querySelector('input[name="visibility"]:checked').value;
    let visibleGroupIds = null;
    
    if (visibilityMode === 'include') {
        visibleGroupIds = Array.from(document.querySelectorAll('input[name="visibility_group"]:checked')).map(cb => parseInt(cb.value));
    }

    let newPost = {};
    const basePostData = {
        timestamp: Date.now(),
        authorId: 'user',
        // 【重要】在这里就把权限信息存好
        visibleGroupIds: visibleGroupIds,
    };

    // --- 2. 根据模式构建不同的 post 对象 ---
    if (mode === 'shuoshuo') {
        const content = document.getElementById('post-public-text').value.trim();
        if (!content) {
            alert('说说内容不能为空哦！');
            return;
        }
        newPost = {
            ...basePostData,
            type: 'shuoshuo',
            content: content,
        };

    } else { // 处理 'complex' 模式 (图片/文字图)
        const publicText = document.getElementById('post-public-text').value.trim();
        const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');

        if (isImageModeActive) {
            const imageUrl = document.getElementById('post-image-preview').src;
            const imageDescription = document.getElementById('post-image-description').value.trim();
            if (!imageUrl || !(imageUrl.startsWith('http') || imageUrl.startsWith('data:'))) {
                alert('请先添加一张图片再发布动态哦！');
                return;
            }
            if (!imageDescription) {
                alert('请为你的图片添加一个简单的描述（必填，给AI看的）！');
                return;
            }
            newPost = {
                ...basePostData,
                type: 'image_post',
                publicText: publicText,
                imageUrl: imageUrl,
                imageDescription: imageDescription,
            };
        } else { // 文字图模式
            const hiddenText = document.getElementById('post-hidden-text').value.trim();
            if (!hiddenText) {
                alert('请输入文字图描述！');
                return;
            }
            newPost = {
                ...basePostData,
                type: 'text_image',
                publicText: publicText,
                hiddenContent: hiddenText,
            };
        }
    }

    // --- 3. 保存到数据库 ---
    const newPostId = await db.qzonePosts.add(newPost);
    let postSummary = newPost.content || newPost.publicText || newPost.imageDescription || newPost.hiddenContent || "（无文字内容）";
    postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? '...' : '');

    // --- 4. 【核心修正】带有权限检查的通知循环 ---
    for (const chatId in state.chats) {
        const chat = state.chats[chatId];
        if (chat.isGroup) continue; // 跳过群聊

        let shouldNotify = false;
        const postVisibleGroups = newPost.visibleGroupIds;

        // 判断条件1：如果动态是公开的 (没有设置任何可见分组)
        if (!postVisibleGroups || postVisibleGroups.length === 0) {
            shouldNotify = true;
        } 
        // 判断条件2：如果动态设置了部分可见，并且当前角色在可见分组内
        else if (chat.groupId && postVisibleGroups.includes(chat.groupId)) {
            shouldNotify = true;
        }

        // 只有满足条件的角色才会被通知
        if (shouldNotify) {
            const historyMessage = {
                role: 'system',
                content: `[系统提示：用户刚刚发布了一条动态(ID: ${newPostId})，内容摘要是：“${postSummary}”。你现在可以对这条动态进行评论了。]`,
                timestamp: Date.now(),
                isHidden: true
            };
            chat.history.push(historyMessage);
            await db.chats.put(chat);
        }
    }
    // --- 修正结束 ---

    await renderQzonePosts();
    modal.classList.remove('visible');
    alert('动态发布成功！');
});

// ▼▼▼ 请用这【一整块】包含所有滑动和点击事件的完整代码，替换掉旧的 postsList 事件监听器 ▼▼▼

const postsList = document.getElementById('qzone-posts-list');
let swipeState = { isDragging: false, startX: 0, startY: 0, currentX: 0, activeContainer: null, swipeDirection: null, isClick: true };

function resetAllSwipes(exceptThisOne = null) {
    document.querySelectorAll('.qzone-post-container').forEach(container => {
        if (container !== exceptThisOne) {
            container.querySelector('.qzone-post-item').classList.remove('swiped');
        }
    });
}

const handleSwipeStart = (e) => {
    const targetContainer = e.target.closest('.qzone-post-container');
    if (!targetContainer) return;

    resetAllSwipes(targetContainer);
    swipeState.activeContainer = targetContainer;
    swipeState.isDragging = true;
    swipeState.isClick = true;
    swipeState.swipeDirection = null;
    swipeState.startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    swipeState.startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    swipeState.activeContainer.querySelector('.qzone-post-item').style.transition = 'none';
};

const handleSwipeMove = (e) => {
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    const diffX = currentX - swipeState.startX;
    const diffY = currentY - swipeState.startY;
    const absDiffX = Math.abs(diffX);
    const absDiffY = Math.abs(diffY);
    const clickThreshold = 5;

    if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
        swipeState.isClick = false;
    }

    if (swipeState.swipeDirection === null) {
        if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
            if (absDiffX > absDiffY) {
                swipeState.swipeDirection = 'horizontal';
            } else {
                swipeState.swipeDirection = 'vertical';
            }
        }
    }
    if (swipeState.swipeDirection === 'vertical') {
        handleSwipeEnd(e);
        return;
    }
    if (swipeState.swipeDirection === 'horizontal') {
        e.preventDefault();
        swipeState.currentX = currentX;
        let translation = diffX;
        if (translation > 0) translation = 0;
        if (translation < -90) translation = -90;
        swipeState.activeContainer.querySelector('.qzone-post-item').style.transform = `translateX(${translation}px)`;
    }
};

const handleSwipeEnd = (e) => {
    if (swipeState.isClick) {
        swipeState.isDragging = false;
        swipeState.activeContainer = null;
        return;
    }
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const postItem = swipeState.activeContainer.querySelector('.qzone-post-item');
    postItem.style.transition = 'transform 0.3s ease';

    const finalX = e.type.includes('touchend') ? e.changedTouches[0].pageX : e.pageX;
    const diffX = finalX - swipeState.startX;
    const swipeThreshold = -40;

    if (swipeState.swipeDirection === 'horizontal' && diffX < swipeThreshold) {
        postItem.classList.add('swiped');
        postItem.style.transform = '';
    } else {
        postItem.classList.remove('swiped');
        postItem.style.transform = '';
    }

    swipeState.isDragging = false;
    swipeState.startX = 0;
    swipeState.startY = 0;
    swipeState.currentX = 0;
    swipeState.activeContainer = null;
    swipeState.swipeDirection = null;
    swipeState.isClick = true;
};

// --- 绑定所有滑动事件 ---
postsList.addEventListener('mousedown', handleSwipeStart);
document.addEventListener('mousemove', handleSwipeMove);
document.addEventListener('mouseup', handleSwipeEnd);
postsList.addEventListener('touchstart', handleSwipeStart, { passive: false });
postsList.addEventListener('touchmove', handleSwipeMove, { passive: false });
postsList.addEventListener('touchend', handleSwipeEnd);

// --- 绑定所有点击事件 ---
postsList.addEventListener('click', async (e) => {
    e.stopPropagation();
    const target = e.target;

    // --- 新增：处理评论删除按钮 ---
    if (target.classList.contains('comment-delete-btn')) {
        const postContainer = target.closest('.qzone-post-container');
        if (!postContainer) return;

        const postId = parseInt(postContainer.dataset.postId);
        const commentIndex = parseInt(target.dataset.commentIndex);
        if (isNaN(postId) || isNaN(commentIndex)) return;

        const post = await db.qzonePosts.get(postId);
        if (!post || !post.comments || !post.comments[commentIndex]) return;

        const commentText = post.comments[commentIndex].text;
        const confirmed = await showCustomConfirm(
            '删除评论',
            `确定要删除这条评论吗？\n\n“${commentText.substring(0, 50)}...”`,
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            // 从数组中移除该评论
            post.comments.splice(commentIndex, 1);
            // 更新数据库
            await db.qzonePosts.update(postId, { comments: post.comments });
            // 重新渲染列表以反映更改
            await renderQzonePosts();
            alert('评论已删除。');
        }
        return; // 处理完后直接返回
    }

    if (target.classList.contains('post-actions-btn')) {
        const container = target.closest('.qzone-post-container');
        if (container && container.dataset.postId) {
            showPostActions(parseInt(container.dataset.postId));
        }
        return;
    }

    if (target.closest('.qzone-post-delete-action')) {
        const container = target.closest('.qzone-post-container');
        if (!container) return;
        
        const postIdToDelete = parseInt(container.dataset.postId);
        if (isNaN(postIdToDelete)) return;

        const confirmed = await showCustomConfirm('删除动态', '确定要永久删除这条动态吗？', { confirmButtonClass: 'btn-danger' });

        if (confirmed) {
            container.style.transition = 'all 0.3s ease';
            container.style.transform = 'scale(0.8)';
            container.style.opacity = '0';
        
            setTimeout(async () => {
                 await db.qzonePosts.delete(postIdToDelete);
                 
                 const notificationIdentifier = `(ID: ${postIdToDelete})`;
                 for (const chatId in state.chats) {
                     const chat = state.chats[chatId];
                     const originalHistoryLength = chat.history.length;
                     chat.history = chat.history.filter(msg => !(msg.role === 'system' && msg.content.includes(notificationIdentifier)));
                     if (chat.history.length < originalHistoryLength) {
                         await db.chats.put(chat);
                     }
                 }
                 await renderQzonePosts();
                 alert('动态已删除。');
            }, 300);
        }
        return;
    }

    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        showCustomAlert("图片内容", hiddenText.replace(/<br>/g, '\n'));
        return;
    }
    const icon = target.closest('.action-icon');
    if (icon) {
        const postContainer = icon.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        if (isNaN(postId)) return;
        if (icon.classList.contains('like')) {
            const post = await db.qzonePosts.get(postId);
            if (!post) return;
            if (!post.likes) post.likes = [];
            const userNickname = state.qzoneSettings.nickname;
            const userLikeIndex = post.likes.indexOf(userNickname);
            if (userLikeIndex > -1) {
                post.likes.splice(userLikeIndex, 1);
            } else {
                post.likes.push(userNickname);
                icon.classList.add('animate-like');
                icon.addEventListener('animationend', () => icon.classList.remove('animate-like'), { once: true });
            }
            await db.qzonePosts.update(postId, { likes: post.likes });
        }
        if (icon.classList.contains('favorite')) {
            const existingFavorite = await db.favorites.where({ type: 'qzone_post', 'content.id': postId }).first();
            if (existingFavorite) {
                await db.favorites.delete(existingFavorite.id);
                await showCustomAlert('提示', '已取消收藏');
            } else {
                const postToSave = await db.qzonePosts.get(postId);
                if (postToSave) {
                    await db.favorites.add({ type: 'qzone_post', content: postToSave, timestamp: Date.now() });
                    await showCustomAlert('提示', '收藏成功！');
                }
            }
        }
        await renderQzonePosts();
        return;
    }
    // ▼▼▼ 请用这个【新版本】替换旧的 sendBtn 判断逻辑 ▼▼▼
const sendBtn = target.closest('.comment-send-btn');
if (sendBtn) {
    // 使用一个立即执行的异步函数来处理整个流程
    (async () => {
        const postContainer = sendBtn.closest('.qzone-post-container');
        if (!postContainer) return;

        const postId = parseInt(postContainer.dataset.postId);
        const commentInput = postContainer.querySelector('.comment-input');
        const commentText = commentInput.value.trim();

        if (!commentText || isNaN(postId)) return;

        const post = await db.qzonePosts.get(postId);
        if (!post) return;

        // 1. 添加用户的评论
        if (!post.comments) post.comments = [];
        post.comments.push({ commenterName: state.qzoneSettings.nickname, text: commentText, timestamp: Date.now() });

        // 2. 保存用户评论到数据库
        await db.qzonePosts.update(postId, { comments: post.comments });
        commentInput.value = '';

        // 3. 判断是否需要AI回复
        const needsAiReply = post.authorId !== 'user';

        // 4. 刷新界面（如果需要AI回复，此时会显示加载动画）
        await renderQzonePosts(needsAiReply ? postId : null);

        // 5. 如果需要，则调用API并等待其完成
        if (needsAiReply) {
            await triggerAiPostReply(post, commentText);

            // 6. 保存AI的新评论到数据库
            await db.qzonePosts.update(postId, { comments: post.comments });

            // 7. 再次刷新界面，显示AI的回复并移除加载动画
            await renderQzonePosts();
        }
    })();
    return; // 结束事件处理
}
// ▲▲▲ 替换结束 ▲▲▲
});
// ▲▲▲ 替换结束 ▲▲▲

            // ▼▼▼ 在 init() 函数的事件监听器区域，粘贴下面这两行 ▼▼▼

            // 绑定动态页和收藏页的返回按钮
            document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
            document.getElementById('favorites-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

            // ▲▲▲ 添加结束 ▲▲▲

            // ▼▼▼ 在 init() 函数的事件监听器区域，检查并确保你有这段完整的代码 ▼▼▼

            // 收藏页搜索功能
            const searchInput = document.getElementById('favorites-search-input');
            const searchClearBtn = document.getElementById('favorites-search-clear-btn');

            searchInput.addEventListener('input', () => {
                const searchTerm = searchInput.value.trim().toLowerCase();
                
                // 控制清除按钮的显示/隐藏
                searchClearBtn.style.display = searchTerm ? 'block' : 'none';

                if (!searchTerm) {
                    displayFilteredFavorites(allFavoriteItems); // 如果搜索框为空，显示所有
                    return;
                }

                // 筛选逻辑
                const filteredItems = allFavoriteItems.filter(item => {
                    let contentToSearch = '';
                    let authorToSearch = '';

                    if (item.type === 'qzone_post') {
                        const post = item.content;
                        contentToSearch += (post.publicText || '') + ' ' + (post.content || '');
                        if (post.authorId === 'user') {
                            authorToSearch = state.qzoneSettings.nickname;
                        } else if (state.chats[post.authorId]) {
                            authorToSearch = state.chats[post.authorId].name;
                        }
                    } else if (item.type === 'chat_message') {
                        const msg = item.content;
                        if (typeof msg.content === 'string') {
                            contentToSearch = msg.content;
                        }
                        const chat = state.chats[item.chatId];
                        if (chat) {
                           if (msg.role === 'user') {
                                authorToSearch = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                           } else {
                                authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                           }
                        }
                    }
                    
                    // 同时搜索内容和作者，并且不区分大小写
                    return contentToSearch.toLowerCase().includes(searchTerm) || 
                           authorToSearch.toLowerCase().includes(searchTerm);
                });

                displayFilteredFavorites(filteredItems);
            });

            // 清除按钮的点击事件
            searchClearBtn.addEventListener('click', () => {
                searchInput.value = '';
                searchClearBtn.style.display = 'none';
                displayFilteredFavorites(allFavoriteItems);
                searchInput.focus();
            });

            // ▲▲▲ 代码检查结束 ▲▲▲

            // ▼▼▼ 新增/修改的事件监听器 ▼▼▼
            
            // 为聊天界面的批量收藏按钮绑定事件
                        // 为聊天界面的批量收藏按钮绑定事件 (已修正)
            document.getElementById('selection-favorite-btn').addEventListener('click', async () => {
                if (selectedMessages.size === 0) return;
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const favoritesToAdd = [];
                const timestampsToFavorite = [...selectedMessages];

                for (const timestamp of timestampsToFavorite) {
                    // 【核心修正1】使用新的、高效的索引进行查询
                    const existing = await db.favorites.where('originalTimestamp').equals(timestamp).first();
                    
                    if (!existing) {
                        const messageToSave = chat.history.find(msg => msg.timestamp === timestamp);
                        if (messageToSave) {
                            favoritesToAdd.push({
                                type: 'chat_message',
                                content: messageToSave,
                                chatId: state.activeChatId,
                                timestamp: Date.now(), // 这是收藏操作发生的时间
                                originalTimestamp: messageToSave.timestamp // 【核心修正2】保存原始消息的时间戳到新字段
                            });
                        }
                    }
                }

                if (favoritesToAdd.length > 0) {
                    await db.favorites.bulkAdd(favoritesToAdd);
                    allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray(); // 更新全局收藏缓存
                    await showCustomAlert('收藏成功', `已成功收藏 ${favoritesToAdd.length} 条消息。`);
                } else {
                    await showCustomAlert('提示', '选中的消息均已收藏过。');
                }
                
                exitSelectionMode();
            });

            // 收藏页面的"编辑"按钮事件 (已修正)
            const favoritesEditBtn = document.getElementById('favorites-edit-btn');
            const favoritesView = document.getElementById('favorites-view');
            const favoritesActionBar = document.getElementById('favorites-action-bar');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 获取主导航栏
            const favoritesList = document.getElementById('favorites-list'); // 获取收藏列表
            
            favoritesEditBtn.addEventListener('click', () => {
                isFavoritesSelectionMode = !isFavoritesSelectionMode;
                favoritesView.classList.toggle('selection-mode', isFavoritesSelectionMode);

                if (isFavoritesSelectionMode) {
                    // --- 进入编辑模式 ---
                    favoritesEditBtn.textContent = '完成';
                    favoritesActionBar.style.display = 'block'; // 显示删除操作栏
                    mainBottomNav.style.display = 'none'; // ▼ 新增：隐藏主导航栏
                    favoritesList.style.paddingBottom = '80px'; // ▼ 新增：给列表底部增加空间
                } else {
                    // --- 退出编辑模式 ---
                    favoritesEditBtn.textContent = '编辑';
                    favoritesActionBar.style.display = 'none'; // 隐藏删除操作栏
                    mainBottomNav.style.display = 'flex';  // ▼ 新增：恢复主导航栏
                    favoritesList.style.paddingBottom = ''; // ▼ 新增：恢复列表默认padding

                    // 退出时清空所有选择
                    selectedFavorites.clear();
                    document.querySelectorAll('.favorite-item-card.selected').forEach(card => card.classList.remove('selected'));
                    document.getElementById('favorites-delete-selected-btn').textContent = `删除 (0)`;
                }
            });

// ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
// 收藏列表的点击选择事件 (事件委托)
document.getElementById('favorites-list').addEventListener('click', (e) => {
    const target = e.target;
    const card = target.closest('.favorite-item-card');

    // 【新增】处理文字图点击，这段逻辑要放在最前面，保证任何模式下都生效
    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        showCustomAlert("图片内容", hiddenText.replace(/<br>/g, '\n'));
        return; // 处理完就退出，不继续执行选择逻辑
    }
    
    // 如果不在选择模式，则不执行后续的选择操作
    if (!isFavoritesSelectionMode) return;

    // --- 以下是原有的选择逻辑，保持不变 ---
    if (!card) return;

    const favId = parseInt(card.dataset.favid);
    if (isNaN(favId)) return;

    // 切换选择状态
    if (selectedFavorites.has(favId)) {
        selectedFavorites.delete(favId);
        card.classList.remove('selected');
    } else {
        selectedFavorites.add(favId);
        card.classList.add('selected');
    }
    
    // 更新底部删除按钮的计数
    document.getElementById('favorites-delete-selected-btn').textContent = `删除 (${selectedFavorites.size})`;
});

// ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
// 收藏页面批量删除按钮事件
document.getElementById('favorites-delete-selected-btn').addEventListener('click', async () => {
    if (selectedFavorites.size === 0) return;

    const confirmed = await showCustomConfirm(
        '确认删除', 
        `确定要从收藏夹中移除这 ${selectedFavorites.size} 条内容吗？`, 
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const idsToDelete = [...selectedFavorites];
        await db.favorites.bulkDelete(idsToDelete);
        await showCustomAlert('删除成功', '选中的收藏已被移除。');
        
        // 【核心修正1】从前端缓存中也移除被删除的项
        allFavoriteItems = allFavoriteItems.filter(item => !idsToDelete.includes(item.id));
        
        // 【核心修正2】使用更新后的缓存，立即重新渲染列表
        displayFilteredFavorites(allFavoriteItems);
        
        // 最后，再退出编辑模式
        favoritesEditBtn.click(); // 模拟点击"完成"按钮来退出编辑模式
    }
});

// ▼▼▼ 在 init() 函数末尾添加 ▼▼▼
if (state.globalSettings.enableBackgroundActivity) {
    startBackgroundSimulation();
    console.log("后台活动模拟已自动启动。");
}
// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 【这是最终的正确代码】请粘贴这段代码到 init() 的事件监听器区域末尾 ▼▼▼

// --- 统一处理所有影响预览的控件的事件 ---

// 1. 监听主题选择 (已删除)

// 2. 监听字体大小滑块
const fontSizeSlider = document.getElementById('font-size-slider');

// 更新滑块进度的函数
function updateSliderProgress(slider) {
    const progress = ((slider.value - slider.min) / (slider.max - slider.min)) * 100;
    slider.style.background = `linear-gradient(to right, #000 0%, #000 ${progress}%, #ddd ${progress}%, #ddd 100%)`;
}

fontSizeSlider.addEventListener('input', () => {
    // a. 实时更新数值显示
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    // b. 更新滑块进度颜色
    updateSliderProgress(fontSizeSlider);
    // c. 更新预览
    updateSettingsPreview();
});

// 3. 监听自定义CSS输入框
const customCssInputForPreview = document.getElementById('custom-css-input');
customCssInputForPreview.addEventListener('input', updateSettingsPreview);
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
    // 【全新】监听CSS展开编辑器的实时输入，并同步到预览
    const expandedCssEditor = document.querySelector('#css-editor-expanded .expanded-textarea');
    if (expandedCssEditor) {
        expandedCssEditor.addEventListener('input', () => {
            // 1. 将大编辑器的内容实时同步回小输入框，确保保存功能正常
            customCssInputForPreview.value = expandedCssEditor.value;
            // 2. 手动调用预览更新函数
            updateSettingsPreview();
        });
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲

// 4. 监听重置按钮 (已删除)

document.getElementById('reset-custom-css-btn').addEventListener('click', () => {
    document.getElementById('custom-css-input').value = '';
    updateSettingsPreview();
});

// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
document.querySelectorAll('input[name="visibility"]').forEach(radio => {
    radio.addEventListener('change', function() {
        const groupsContainer = document.getElementById('post-visibility-groups');
        if (this.value === 'include' || this.value === 'exclude') {
            groupsContainer.style.display = 'block';
        } else {
            groupsContainer.style.display = 'none';
        }
    });
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
document.getElementById('manage-groups-btn').addEventListener('click', openGroupManager);
document.getElementById('close-group-manager-btn').addEventListener('click', () => {
    document.getElementById('group-management-modal').classList.remove('visible');
    // 刷新聊天设置里的分组列表
    const chatSettingsBtn = document.getElementById('chat-settings-btn');
    if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
       chatSettingsBtn.click(); // 再次点击以重新打开
    }
});

document.getElementById('add-new-group-btn').addEventListener('click', addNewGroup);
document.getElementById('existing-groups-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-group-btn')) {
        const groupId = parseInt(e.target.dataset.id);
        deleteGroup(groupId);
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
// 消息操作菜单的按钮事件（取消按钮已移除，通过点击外部关闭）
// ▼▼▼ 【修正】使用新的编辑器入口 ▼▼▼
document.getElementById('edit-message-btn').addEventListener('click', openAdvancedMessageEditor);
// ▲▲▲ 替换结束 ▲▲▲
document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);

// ▼▼▼ 在这里添加新代码 ▼▼▼
document.getElementById('recall-message-btn').addEventListener('click', handleRecallClick);
// 【全新】为“向下全选”按钮绑定点击事件
document.getElementById('selection-select-below-btn').addEventListener('click', handleSelectBelow);
// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 请用这段【修正后】的代码替换旧的 select-message-btn 事件监听器 ▼▼▼
document.getElementById('select-message-btn').addEventListener('click', () => {
    // 【核心修复】在关闭菜单前，先捕获时间戳
    const timestampToSelect = activeMessageTimestamp; 
    hideMessageActions();
    // 使用捕获到的值
    if (timestampToSelect) {
        enterSelectionMode(timestampToSelect);
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 在 init() 函数的事件监听器区域末尾添加 ▼▼▼

// 动态操作菜单的按钮事件
document.getElementById('edit-post-btn').addEventListener('click', openPostEditor);
document.getElementById('copy-post-btn').addEventListener('click', copyPostContent);
document.getElementById('cancel-post-action-btn').addEventListener('click', hidePostActions);

// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 【新增】联系人选择器事件绑定 ▼▼▼
document.getElementById('cancel-contact-picker-btn').addEventListener('click', () => {
    showScreen('chat-list-screen');
});

document.getElementById('contact-picker-list').addEventListener('click', (e) => {
    const item = e.target.closest('.contact-picker-item');
    if (!item) return;

    const contactId = item.dataset.contactId;
    item.classList.toggle('selected');
    
    if (selectedContacts.has(contactId)) {
        selectedContacts.delete(contactId);
    } else {
        selectedContacts.add(contactId);
    }
    updateContactPickerConfirmButton();
});

// ▼▼▼ 【新增】绑定“管理群成员”按钮事件 ▼▼▼
document.getElementById('manage-members-btn').addEventListener('click', () => {
    // 在切换屏幕前，先隐藏当前的聊天设置弹窗
    document.getElementById('chat-settings-modal').classList.remove('visible');
    // 然后再打开成员管理屏幕
    openMemberManagementScreen();
});
// ▲▲▲ 新增代码结束 ▲▲▲

// ▼▼▼ 【最终完整版】群成员管理功能事件绑定 ▼▼▼
document.getElementById('back-from-member-management').addEventListener('click', () => {

    showScreen('chat-interface-screen');    
    document.getElementById('chat-settings-btn').click();
});
// ▲▲▲ 替换结束 ▲▲▲

document.getElementById('member-management-list').addEventListener('click', (e) => {
    // 【已恢复】移除成员的事件
    if (e.target.classList.contains('remove-member-btn')) {
        removeMemberFromGroup(e.target.dataset.memberId);
    }
});

document.getElementById('add-existing-contact-btn').addEventListener('click', async () => {
    // 【已恢复】从好友列表添加的事件
    // 【关键】为“完成”按钮绑定“拉人入群”的逻辑
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 使用克隆节点方法清除旧的事件监听器，防止重复绑定
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);
    
    await openContactPickerForAddMember();
});

document.getElementById('create-new-member-btn').addEventListener('click', createNewMemberInGroup);
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】视频通话功能事件监听器 ▼▼▼

// 绑定单聊和群聊的发起按钮
document.getElementById('video-call-btn').addEventListener('click', handleInitiateCall);
document.getElementById('group-video-call-btn').addEventListener('click', handleInitiateCall);

// 绑定“挂断”按钮
document.getElementById('hang-up-btn').addEventListener('click', endVideoCall);

// 绑定“取消呼叫”按钮
document.getElementById('cancel-call-btn').addEventListener('click', () => {
    videoCallState.isAwaitingResponse = false;
    showScreen('chat-interface-screen');
});

// 【全新】绑定“加入通话”按钮
document.getElementById('join-call-btn').addEventListener('click', handleUserJoinCall);

// ▼▼▼ 用这个【已修复并激活旁观模式】的版本替换旧的 decline-call-btn 事件监听器 ▼▼▼
// 绑定来电请求的“拒绝”按钮
document.getElementById('decline-call-btn').addEventListener('click', async () => {
    hideIncomingCallModal();
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;
    
    // 【核心修正】在这里，我们将拒绝的逻辑与API调用连接起来
    if (videoCallState.isGroupCall) {
        videoCallState.isUserParticipating = false; // 标记用户为旁观者
        
        // 1. 创建一条隐藏消息，通知AI用户拒绝了
        const systemNote = {
            role: 'system',
            content: `[系统提示：用户拒绝了通话邀请，但你们可以自己开始。请你们各自决策是否加入。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(systemNote);
        await db.chats.put(chat);
        
        // 2. 【关键】触发AI响应，让它们自己决定要不要开始群聊
        // 这将会在后台处理，如果AI们决定开始，最终会调用 startVideoCall()
        await triggerAiResponse(); 
        
    } else { // 单聊拒绝逻辑保持不变
        const declineMessage = { role: 'user', content: '我拒绝了你的视频通话请求。', timestamp: Date.now() };
        chat.history.push(declineMessage);
        await db.chats.put(chat);
        
        // 回到聊天界面并显示拒绝消息
        showScreen('chat-interface-screen');
        appendMessage(declineMessage, chat);
        
        // 让AI对你的拒绝做出回应
        triggerAiResponse();
    }
    
    // 清理状态，以防万一
    videoCallState.isAwaitingResponse = false;
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这个【已修复重复头像BUG】的版本替换旧的 accept-call-btn 事件监听器 ▼▼▼
// 绑定来电请求的“接听”按钮
document.getElementById('accept-call-btn').addEventListener('click', async () => {
    hideIncomingCallModal();
    
    videoCallState.initiator = 'ai';
    videoCallState.isUserParticipating = true;
    videoCallState.activeChatId = state.activeChatId;
    
    // 【核心修正】我们在这里不再手动添加用户到 participants 列表
    if (videoCallState.isGroupCall) {
        // 对于群聊，我们只把【发起通话的AI】加入参与者列表
        const chat = state.chats[videoCallState.activeChatId];
        const requester = chat.members.find(m => m.name === videoCallState.callRequester);
        if (requester) {
            // 清空可能存在的旧数据，然后只添加发起者
            videoCallState.participants = [requester];
        } else {
            videoCallState.participants = []; // 如果找不到发起者，就清空
        }
    }
    
    // 无论单聊还是群聊，直接启动通话界面！
    startVideoCall();
});
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 请用这个【已增加用户高亮】的全新版本，完整替换旧的 user-speak-btn 事件监听器 ▼▼▼
// 绑定用户在通话中发言的按钮
document.getElementById('user-speak-btn').addEventListener('click', async () => {
    if (!videoCallState.isActive) return;

    // ★★★★★ 核心新增：在弹出输入框前，先找到并高亮用户头像 ★★★★★
    const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
    if (userAvatar) {
        userAvatar.classList.add('speaking');
    }

    const userInput = await showCustomPrompt('你说', '请输入你想说的话...', '', 'textarea');
    
    // ★★★★★ 核心新增：无论用户是否输入，只要关闭输入框就移除高亮 ★★★★★
    if (userAvatar) {
        userAvatar.classList.remove('speaking');
    }

    if (userInput && userInput.trim()) {
        triggerAiInCallAction(userInput.trim());
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【新增】回忆录相关事件绑定 ▼▼▼
// 1. 将“回忆”页签和它的视图连接起来
document.querySelector('.nav-item[data-view="memories-view"]').addEventListener('click', () => {
    // 在切换前，确保"收藏"页面的编辑模式已关闭
    if (isFavoritesSelectionMode) {
        document.getElementById('favorites-edit-btn').click(); 
    }
    switchToChatListView('memories-view');
    renderMemoriesScreen(); // 点击时渲染
});

// 2. 绑定回忆录界面的返回按钮
document.getElementById('memories-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

// ▲▲▲ 新增结束 ▲▲▲

// 【全新】约定/倒计时功能事件绑定
document.getElementById('add-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.add('visible');
});
document.getElementById('cancel-create-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.remove('visible');
});
document.getElementById('confirm-create-countdown-btn').addEventListener('click', async () => {
    const title = document.getElementById('countdown-title-input').value.trim();
    const dateValue = document.getElementById('countdown-date-input').value;
    
    if (!title || !dateValue) {
        alert('请填写完整的约定标题和日期！');
        return;
    }

    const targetDate = new Date(dateValue);
    if (isNaN(targetDate)) {
        alert('请输入一个有效的日期！');
        return;
    }

    const newCountdown = {
        chatId: null, // 用户创建的，不属于任何特定AI
        authorName: '我',
        description: title,
        timestamp: Date.now(),
        type: 'countdown',
        targetDate: targetDate.getTime()
    };
    
    await db.memories.add(newCountdown);
    document.getElementById('create-countdown-modal').classList.remove('visible');
    renderMemoriesScreen();
});

// 【全新】拉黑功能事件绑定
document.getElementById('block-chat-btn').addEventListener('click', async () => {
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;

    const chat = state.chats[state.activeChatId];
    const confirmed = await showCustomConfirm(
        '确认拉黑', 
        `确定要拉黑“${chat.name}”吗？拉黑后您将无法向其发送消息，直到您将Ta移出黑名单，或等待Ta重新申请好友。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：你刚刚被用户拉黑了。在对方解除拉黑之前，你无法再主动发起对话，也无法回应。]`,
            timestamp: Date.now() + 1,
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        
        // 关闭设置弹窗，并刷新聊天界面
        document.getElementById('chat-settings-modal').classList.remove('visible');
        renderChatInterface(state.activeChatId);
        // 刷新聊天列表，可能会有UI变化
        renderChatList();
    }
});

document.getElementById('chat-lock-overlay').addEventListener('click', async (e) => {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    if (e.target.id === 'force-apply-check-btn') {
        alert("正在手动触发好友申请流程，请稍后...\n如果API调用成功，将弹出提示。如果失败，也会有错误提示。如果长时间无反应，说明AI可能决定暂时不申请。");
        await triggerAiFriendApplication(chat.id);
        renderChatInterface(chat.id); 
        return;
    }
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
    else if (e.target.closest('#toggle-dev-panel-btn')) {
        const panel = document.getElementById('developer-diagnostic-panel');
        if (panel) {
            // 切换面板的显示状态
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
        return;
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    if (e.target.id === 'unblock-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.blockedTimestamp = null;

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：用户刚刚解除了对你的拉黑。现在你们可以重新开始对话了。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        triggerAiResponse(); // 【可选但推荐】解除后让AI主动说点什么
    }
    else if (e.target.id === 'accept-friend-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.applicationReason = '';

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：用户刚刚通过了你的好友申请。你们现在又可以正常聊天了。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        const msg = { role: 'user', content: '我通过了你的好友请求', timestamp: Date.now() };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        triggerAiResponse();
    }
    else if (e.target.id === 'reject-friend-btn') {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();
        chat.relationship.applicationReason = '';
        await db.chats.put(chat);
        // ▼▼▼ 在这里添加下面这行代码 ▼▼▼
        await triggerActiveReply(chat, 0); // 核心修改：立即触发AI的“被拉黑后”行为
        renderChatInterface(chat.id);
    }
    // 【新增】处理申请好友按钮的点击事件
    else if (e.target.id === 'apply-friend-btn') {
        const reason = await showCustomPrompt(
            '发送好友申请', 
            `请输入你想对“${chat.name}”说的申请理由：`,
            "我们和好吧！"
        );
        // 只有当用户输入了内容并点击“确定”后才继续
        if (reason !== null) {
            // 更新关系状态为“等待AI批准”
            chat.relationship.status = 'pending_ai_approval';
            chat.relationship.applicationReason = reason;
            await db.chats.put(chat);

            // 刷新UI，显示“等待通过”的界面
            renderChatInterface(chat.id);
            renderChatList();
            
            // 【关键】触发AI响应，让它去处理这个好友申请
            triggerAiResponse();
        }
    }
});

// ▼▼▼ 【全新】红包功能事件绑定 ▼▼▼

// 1. 将原有的转账按钮(￥)的点击事件，重定向到新的总入口函数
document.getElementById('transfer-btn').addEventListener('click', handlePaymentButtonClick);

// 2. 红包模态框内部的控制按钮
document.getElementById('cancel-red-packet-btn').addEventListener('click', () => {
    document.getElementById('red-packet-modal').classList.remove('visible');
});
document.getElementById('send-group-packet-btn').addEventListener('click', sendGroupRedPacket);
document.getElementById('send-direct-packet-btn').addEventListener('click', sendDirectRedPacket);

// 3. 红包模态框的页签切换逻辑
const rpTabGroup = document.getElementById('rp-tab-group');
const rpTabDirect = document.getElementById('rp-tab-direct');
const rpContentGroup = document.getElementById('rp-content-group');
const rpContentDirect = document.getElementById('rp-content-direct');

rpTabGroup.addEventListener('click', () => {
    rpTabGroup.classList.add('active');
    rpTabDirect.classList.remove('active');
    rpContentGroup.style.display = 'block';
    rpContentDirect.style.display = 'none';
});
rpTabDirect.addEventListener('click', () => {
    rpTabDirect.classList.add('active');
    rpTabGroup.classList.remove('active');
    rpContentDirect.style.display = 'block';
    rpContentGroup.style.display = 'none';
});

// 4. 实时更新红包金额显示
document.getElementById('rp-group-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-group-total').textContent = `¥ ${amount.toFixed(2)}`;
});
document.getElementById('rp-direct-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-direct-total').textContent = `¥ ${amount.toFixed(2)}`;
});

// ▲▲▲ 新事件绑定结束 ▲▲▲

// ▼▼▼ 【全新添加】使用事件委托处理红包点击，修复失效问题 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 找到被点击的红包卡片
    const packetCard = e.target.closest('.red-packet-card');
    if (!packetCard) return; // 如果点击的不是红包，就什么也不做

    // 2. 从红包卡片的父级.message-bubble获取时间戳
    const messageBubble = packetCard.closest('.message-bubble');
    if (!messageBubble || !messageBubble.dataset.timestamp) return;

    // 3. 调用我们现有的处理函数
    const timestamp = parseInt(messageBubble.dataset.timestamp);
    handlePacketClick(timestamp);
});
// ▲▲▲ 新增代码结束 ▲▲▲

// ▼▼▼ 【全新】投票功能事件监听器 ▼▼▼
// 在输入框工具栏添加按钮
document.getElementById('send-poll-btn').addEventListener('click', openCreatePollModal);

// 投票创建模态框的按钮
document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
    document.getElementById('create-poll-modal').classList.remove('visible');
});
document.getElementById('confirm-create-poll-btn').addEventListener('click', sendPoll);

// 使用事件委托处理投票卡片内的所有点击事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    const pollCard = e.target.closest('.poll-card');
    if (!pollCard) return;

    const timestamp = parseInt(pollCard.dataset.pollTimestamp);
    if (isNaN(timestamp)) return;
    
    // 点击了选项
    const optionItem = e.target.closest('.poll-option-item');
    if (optionItem && !pollCard.classList.contains('closed')) {
        handleUserVote(timestamp, optionItem.dataset.option);
        return;
    }
    
    // 点击了动作按钮（结束投票/查看结果）
    const actionBtn = e.target.closest('.poll-action-btn');
    if (actionBtn) {
        if (pollCard.classList.contains('closed')) {
            showPollResults(timestamp);
        } else {
            endPoll(timestamp);
        }
        return;
    }

    // 如果是已结束的投票，点击卡片任何地方都可以查看结果
    if (pollCard.classList.contains('closed')) {
        showPollResults(timestamp);
    }
});
// ▲▲▲ 新事件监听器粘贴结束 ▲▲▲

  // ▼▼▼ 【全新】AI头像库功能事件绑定 ▼▼▼
document.getElementById('manage-ai-avatar-library-btn').addEventListener('click', openAiAvatarLibraryModal);
document.getElementById('add-ai-avatar-btn').addEventListener('click', addAvatarToLibrary);
document.getElementById('close-ai-avatar-library-btn').addEventListener('click', closeAiAvatarLibraryModal);
// ▲▲▲ 新增结束 ▲▲▲

// ▼▼▼ 在 init() 的事件监听区域，粘贴这段【新代码】▼▼▼
document.getElementById('icon-settings-grid').addEventListener('click', async (e) => {
    if (e.target.classList.contains('change-icon-btn')) {
        const item = e.target.closest('.icon-setting-item');
        const iconId = item.dataset.iconId;
        if (!iconId) return;

        const currentUrl = state.globalSettings.appIcons[iconId];
        const newUrl = await showCustomPrompt(`更换“${item.querySelector('.icon-preview').alt}”图标`, '请输入新的图片URL', currentUrl, 'url');

        if (newUrl && newUrl.trim().startsWith('http')) {
            // 仅在内存中更新，等待用户点击“保存”
            state.globalSettings.appIcons[iconId] = newUrl.trim();
            // 实时更新设置页面的预览图
            item.querySelector('.icon-preview').src = newUrl.trim();
        } else if (newUrl !== null) {
            alert("请输入一个有效的URL！");
        }
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 函数的末尾，粘贴这段【全新的事件监听器】 ▼▼▼

    document.getElementById('chat-messages').addEventListener('click', (e) => {
        // 使用 .closest() 向上查找被点击的卡片
        const linkCard = e.target.closest('.link-share-card');
        if (linkCard) {
            const timestamp = parseInt(linkCard.dataset.timestamp);
            if (!isNaN(timestamp)) {
                openBrowser(timestamp); // 调用我们的函数
            }
        }
    });

    // 浏览器返回按钮的事件监听，确保它只绑定一次
    document.getElementById('browser-back-btn').addEventListener('click', () => {
        showScreen('chat-interface-screen');
    });

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 函数的末尾，粘贴这段【全新的事件监听器】 ▼▼▼

    // 1. 绑定输入框上方"分享链接"按钮的点击事件
    document.getElementById('share-link-btn').addEventListener('click', openShareLinkModal);
//  ▼▼▼ 请用这段【新代码】替换旧的 'diary-btn' 事件监听器 ▼▼▼
// 绑定日记按钮
document.getElementById('diary-btn').addEventListener('click', () => {
    if (state.activeChatId) {
        // 【核心修复】调用功能更全面的关闭函数，确保空白区域也被移除
        closePlusPanel(); 
        openDiaryScreen(state.activeChatId);
    }
});
// ▲▲▲ 替换结束 ▲▲▲
// 绑定重新生成按钮
    document.getElementById('regenerate-btn').addEventListener('click', handleRegenerateResponse);

    // 2. 绑定模态框中“取消”按钮的点击事件
    document.getElementById('cancel-share-link-btn').addEventListener('click', () => {
        document.getElementById('share-link-modal').classList.remove('visible');
    });

    // 3. 绑定模态框中“分享”按钮的点击事件
    document.getElementById('confirm-share-link-btn').addEventListener('click', sendUserLinkShare);

// ▲▲▲ 新代码粘贴结束 ▲▲▲

document.getElementById('theme-toggle-switch').addEventListener('change', toggleTheme);

// ▼▼▼ 在 init() 的事件监听器区域，粘贴下面这几行 ▼▼▼
// 绑定消息操作菜单中的“引用”按钮
document.getElementById('quote-message-btn').addEventListener('click', startReplyToMessage);

// 绑定回复预览栏中的“取消”按钮
document.getElementById('cancel-reply-btn').addEventListener('click', cancelReplyMode);
// ▲▲▲ 粘贴结束 ▲▲▲

// 在你的 init() 函数的事件监听器区域...

// ▼▼▼ 用这段代码替换旧的转账卡片点击事件 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 向上查找被点击的元素是否在一个消息气泡内
    const bubble = e.target.closest('.message-bubble');
    if (!bubble) return; // 如果不在，就退出

    // 2. 【核心修正】在这里添加严格的筛选条件
    // 必须是 AI 的消息 (.ai)
    // 必须是转账类型 (.is-transfer)
    // 必须是我们标记为“待处理”的 (data-status="pending")
    if (bubble.classList.contains('ai') && 
        bubble.classList.contains('is-transfer') && 
        bubble.dataset.status === 'pending') {
        
        // 3. 只有满足所有条件，才执行后续逻辑
        const timestamp = parseInt(bubble.dataset.timestamp);
        if (!isNaN(timestamp)) {
            showTransferActionModal(timestamp);
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// 在 init() 的事件监听区域添加
document.getElementById('transfer-action-accept').addEventListener('click', () => handleUserTransferResponse('accepted'));
document.getElementById('transfer-action-decline').addEventListener('click', () => handleUserTransferResponse('declined'));
document.getElementById('transfer-action-cancel').addEventListener('click', hideTransferActionModal);

// ▼▼▼ 礼物按钮点击事件处理 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', async (e) => {
    // 检查是否点击了礼物按钮
    if (e.target.classList.contains('gift-decline-btn') || e.target.classList.contains('gift-accept-btn')) {
        const choice = e.target.dataset.choice; // 'accepted' 或 'declined'
        const timestamp = parseInt(e.target.dataset.timestamp);
        
        if (!isNaN(timestamp) && state.activeChatId) {
            const chat = state.chats[state.activeChatId];
            const giftMsgIndex = chat.history.findIndex(m => m.timestamp === timestamp);
            
            if (giftMsgIndex > -1) {
                const giftMsg = chat.history[giftMsgIndex];
                giftMsg.status = choice; // 更新状态
                
                // 如果是拼手气礼物被接受，记录接收者信息
                if (choice === 'accepted' && giftMsg.giftType === 'random') {
                    giftMsg.actualReceiver = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                }
                
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId); // 重新渲染界面
                
                // 发送系统消息给AI，让AI知道用户的选择
                const systemMessage = {
                    role: 'user',
                    content: choice === 'accepted' ? 
                        `[系统提示：用户已接受了你的礼物"${giftMsg.giftName}"（价值¥${giftMsg.giftPrice}），请自然地回应这个结果。]` :
                        `[系统提示：用户已拒绝了你的礼物"${giftMsg.giftName}"（价值¥${giftMsg.giftPrice}），请自然地回应这个结果。]`,
                    timestamp: Date.now(),
                    isSystemMessage: true
                };
                
                chat.history.push(systemMessage);
                await db.chats.put(chat);
                
                // 检查是否还有待处理的礼物
                const hasPendingGifts = chat.history.some(msg => 
                    msg.type === 'gift' && 
                    msg.role === 'assistant' && 
                    msg.status === 'pending'
                );
                
                // 如果是单聊或没有待处理礼物了，立即触发AI回应
                if (!chat.isGroup || !hasPendingGifts) {
                    triggerAiResponse();
                }
            }
        }
    }
});
// ▲▲▲ 礼物按钮处理结束 ▲▲▲

// ▼▼▼ 用这段【新代码】替换旧的通话记录事件绑定 ▼▼▼

document.getElementById('chat-list-title').addEventListener('click', renderCallHistoryScreen);

// 2. 绑定通话记录页面的“返回”按钮
document.getElementById('call-history-back-btn').addEventListener('click', () => {
    // 【核心修改】返回到聊天列表页面，而不是聊天界面
    showScreen('chat-list-screen');
});

// 3. 监听卡片点击的逻辑保持不变
document.getElementById('call-history-list').addEventListener('click', (e) => {
    const card = e.target.closest('.call-record-card');
    if (card && card.dataset.recordId) {
        showCallTranscript(parseInt(card.dataset.recordId));
    }
});

// 4. 关闭详情弹窗的逻辑保持不变
document.getElementById('close-transcript-modal-btn').addEventListener('click', () => {
    document.getElementById('call-transcript-modal').classList.remove('visible');
});

// ▲▲▲ 替换结束 ▲▲▲

document.getElementById('chat-messages').addEventListener('click', (e) => {
    const voiceBody = e.target.closest('.voice-message-body');
    const translationBody = e.target.closest('.translation-body');

    // --- 逻辑1：处理语音条点击 ---
if (voiceBody) {
    const bubble = voiceBody.closest('.message-bubble');
    if (!bubble) return;
    const spinner = voiceBody.querySelector('.loading-spinner');
    const transcriptEl = bubble.querySelector('.voice-transcript');
    const wrapper = bubble.closest('.message-wrapper');
    const chatMessages = document.getElementById('chat-messages');

    if (bubble.dataset.state === 'expanded') {
        transcriptEl.style.display = 'none';
        bubble.dataset.state = 'collapsed';
    } else {
        bubble.dataset.state = 'loading';
        spinner.style.display = 'block';
        setTimeout(() => {
            if (document.body.contains(bubble)) {
                const voiceText = bubble.dataset.voiceText || '(无法识别)';
                transcriptEl.textContent = voiceText;
                spinner.style.display = 'none';
                transcriptEl.style.display = 'block';
                bubble.dataset.state = 'expanded';

                // 【核心修改】判断当前消息是否为最后一条
                const allMessages = chatMessages.querySelectorAll('.message-wrapper');
                const isLastMessage = wrapper === allMessages[allMessages.length - 1];

                if (isLastMessage) {
                    // 如果是最后一条，才滚动到底部
                    chatMessages.scrollTo({ top: chatMessages.scrollHeight, behavior: 'smooth' });
                }
            }
        }, 500);
    }
}
// --- 逻辑2：处理翻译条点击 ---
else if (translationBody) {
    const bubble = translationBody.closest('.message-bubble');
    if (!bubble) return;
    const transcriptEl = bubble.querySelector('.translation-text');
    const wrapper = bubble.closest('.message-wrapper');
    const chatMessages = document.getElementById('chat-messages');

    if (bubble.dataset.state !== 'expanded') {
        transcriptEl.style.display = 'block';
        bubble.dataset.state = 'expanded';

        // 【核心修改】判断当前消息是否为最后一条
        const allMessages = chatMessages.querySelectorAll('.message-wrapper');
        const isLastMessage = wrapper === allMessages[allMessages.length - 1];

        if (isLastMessage) {
            // 如果是最后一条，才滚动到底部
            chatMessages.scrollTo({ top: chatMessages.scrollHeight, behavior: 'smooth' });
        }

    } else {
        transcriptEl.style.display = 'none';
        bubble.dataset.state = 'collapsed';
    }
}
});

document.getElementById('chat-header-status').addEventListener('click', handleEditStatusClick);

// 在 init() 的事件监听器区域添加
document.getElementById('selection-share-btn').addEventListener('click', () => {
    if (selectedMessages.size > 0) {
        openShareTargetPicker(); // 打开我们即将创建的目标选择器
    }
});

// 在 init() 的事件监听器区域添加
document.getElementById('confirm-share-target-btn').addEventListener('click', async () => {
    const modal = document.getElementById('share-target-modal');
    
    // 检查是否是论坛转发
    if (modal.dataset.forwardingPostId) {
        // 论坛转发逻辑
        const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
                                       .map(cb => cb.dataset.chatId);

        if (selectedTargetIds.length === 0) {
            alert("请至少选择一个要转发的聊天。");
            return;
        }

        const postId = parseInt(modal.dataset.forwardingPostId);
        const post = currentForumPosts.find(p => p.id === postId);
        
        if (post) {
            await handleForumPostForward(post, selectedTargetIds);
        }
        
        // 清理并关闭
        modal.dataset.forwardingPostId = '';
        modal.classList.remove('visible');
        return;
    }
    
    // 原有的聊天记录分享逻辑
    const sourceChat = state.chats[state.activeChatId];
    const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
                                   .map(cb => cb.dataset.chatId);

    if (selectedTargetIds.length === 0) {
        alert("请至少选择一个要分享的聊天。");
        return;
    }

    // 1. 打包聊天记录
    const sharedHistory = [];
    const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
    for (const timestamp of sortedTimestamps) {
        const msg = sourceChat.history.find(m => m.timestamp === timestamp);
        if (msg) {
            sharedHistory.push(msg);
        }
    }
    
    // 2. 创建分享卡片消息对象
    const shareCardMessage = {
        role: 'user',
        senderName: sourceChat.isGroup ? (sourceChat.settings.myNickname || '我') : '我',
        type: 'share_card',
        timestamp: Date.now(),
        payload: {
            sourceChatName: sourceChat.name,
            title: `来自“${sourceChat.name}”的聊天记录`,
            sharedHistory: sharedHistory
        }
    };

    // 3. 循环发送到所有目标聊天
    for (const targetId of selectedTargetIds) {
        const targetChat = state.chats[targetId];
        if (targetChat) {
            targetChat.history.push(shareCardMessage);
            await db.chats.put(targetChat);
        }
    }
    
    // 4. 收尾工作
    document.getElementById('share-target-modal').classList.remove('visible');
    exitSelectionMode(); // 退出多选模式
    await showCustomAlert("分享成功", `聊天记录已成功分享到 ${selectedTargetIds.length} 个会话中。`);
    renderChatList(); // 刷新列表，可能会有新消息提示
});

// 绑定取消按钮
document.getElementById('cancel-share-target-btn').addEventListener('click', () => {
    document.getElementById('share-target-modal').classList.remove('visible');
});

// 在 init() 的事件监听器区域添加
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // ...你已有的其他点击事件逻辑...
// ▼▼▼ 在这里添加新的代码块 ▼▼▼
    // 【全新】处理转发的论坛卡片图片点击
    const forumCardImage = e.target.closest('.forum-card .chat-image');
    if (forumCardImage && forumCardImage.dataset.description) {
        const description = forumCardImage.dataset.description;
        showCustomAlert("图片内容", description.replace(/<br>/g, '\n'));
        return; // 处理完后直接返回，避免触发其他事件
    }
    // ▲▲▲ 新代码添加结束 ▲▲▲
    // 新增逻辑：处理分享卡片的点击
    const shareCard = e.target.closest('.link-share-card[data-timestamp]');
    if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(shareCard.dataset.timestamp);
        openSharedHistoryViewer(timestamp);
    }
});

// 绑定查看器的关闭按钮
document.getElementById('close-shared-history-viewer-btn').addEventListener('click', () => {
    document.getElementById('shared-history-viewer-modal').classList.remove('visible');
});

// 创建新函数来处理渲染逻辑
function openSharedHistoryViewer(timestamp) {
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_card') return;

    const viewerModal = document.getElementById('shared-history-viewer-modal');
    const viewerTitle = document.getElementById('shared-history-viewer-title');
    const viewerContent = document.getElementById('shared-history-viewer-content');

    viewerTitle.textContent = message.payload.title;
    viewerContent.innerHTML = ''; // 清空旧内容

    // 【核心】复用 createMessageElement 来渲染每一条被分享的消息
    message.payload.sharedHistory.forEach(sharedMsg => {
        // 注意：这里我们传入的是 sourceChat 对象，以确保头像、昵称等正确
        const sourceChat = Object.values(state.chats).find(c => c.name === message.payload.sourceChatName) || chat;
        const bubbleEl = createMessageElement(sharedMsg, sourceChat);
        if (bubbleEl) {
            viewerContent.appendChild(bubbleEl);
        }
    });

    viewerModal.classList.add('visible');
}

audioPlayer.addEventListener('timeupdate', updateMusicProgressBar);

audioPlayer.addEventListener('pause', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = false; 
        updatePlayerUI(); 
    } 
});
audioPlayer.addEventListener('play', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = true; 
        updatePlayerUI(); 
    } 
});

document.getElementById('playlist-body').addEventListener('click', async (e) => {
    const target = e.target;
    if (target.classList.contains('delete-track-btn')) {
        const index = parseInt(target.dataset.index);
        const track = musicState.playlist[index];
        const confirmed = await showCustomConfirm('删除歌曲', `确定要从播放列表中删除《${track.name}》吗？`);
        if (confirmed) {
            deleteTrack(index);
        }
        return;
    }
    if (target.classList.contains('lyrics-btn')) {
        const index = parseInt(target.dataset.index);
        if (isNaN(index)) return;
        const lrcContent = await new Promise(resolve => {
            const lrcInput = document.getElementById('lrc-upload-input');
            const handler = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (re) => resolve(re.target.result);
                    reader.readAsText(file);
                } else {
                    resolve(null);
                }
                lrcInput.removeEventListener('change', handler);
                lrcInput.value = '';
            };
            lrcInput.addEventListener('change', handler);
            lrcInput.click();
        });
        if (lrcContent !== null) {
            musicState.playlist[index].lrcContent = lrcContent;
            await saveGlobalPlaylist();
            alert('歌词导入成功！');
            if (musicState.currentIndex === index) {
                musicState.parsedLyrics = parseLRC(lrcContent);
                renderLyrics();
            }
        }
    }
});

document.querySelector('.progress-bar').addEventListener('click', (e) => {
    if (!audioPlayer.duration) return;
    const progressBar = e.currentTarget;
    const barWidth = progressBar.clientWidth;
    const clickX = e.offsetX;
    audioPlayer.currentTime = (clickX / barWidth) * audioPlayer.duration;
});

// ▼▼▼ 在 init() 函数的事件监听器区域，粘贴这段新代码 ▼▼▼

// 使用事件委托来处理所有“已撤回消息”的点击事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 检查被点击的元素或其父元素是否是“已撤回”提示
    const placeholder = e.target.closest('.recalled-message-placeholder');
    if (!placeholder) return; // 如果不是，就退出

    // 如果是，就从聊天记录中找到对应的数据并显示
    const chat = state.chats[state.activeChatId];
    const wrapper = placeholder.closest('.message-wrapper'); // 找到它的父容器
    if (chat && wrapper) {
        // 从父容器上找到时间戳
        const timestamp = parseInt(wrapper.dataset.timestamp);
        const recalledMsg = chat.history.find(m => m.timestamp === timestamp);
        
        if (recalledMsg && recalledMsg.recalledData) {
            let originalContentText = '';
            const recalled = recalledMsg.recalledData;
            
            if (recalled.originalType === 'text') {
                originalContentText = `原文: "${recalled.originalContent}"`;
            } else {
                originalContentText = `撤回了一条[${recalled.originalType}]类型的消息`;
            }
            showCustomAlert('已撤回的消息', originalContentText);
        }
    }
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】HTML指令功能事件绑定 ▼▼▼
    document.getElementById('html-prompt-btn-panel').addEventListener('click', () => {
        closePlusPanel(); // 先关闭功能面板
        document.getElementById('html-prompt-modal').classList.add('visible');
    });
    document.getElementById('html-prompt-btn-group-panel').addEventListener('click', () => {
        closePlusPanel(); // 先关闭功能面板
        document.getElementById('html-prompt-modal').classList.add('visible');
    });

    document.getElementById('cancel-html-prompt-btn').addEventListener('click', () => {
        document.getElementById('html-prompt-modal').classList.remove('visible');
    });

    document.getElementById('send-html-prompt-btn').addEventListener('click', sendHtmlPrompt);
    // ▲▲▲ 新事件绑定结束 ▲▲▲
// 监听回忆录列表中的点击事件
document.getElementById('memories-list').addEventListener('click', (e) => {
    const bindBtn = e.target.closest('.bind-char-btn');
    if (bindBtn) {
        const memoryId = parseInt(bindBtn.dataset.memoryId);
        if (!isNaN(memoryId)) {
            openCharacterBinder(memoryId);
        }
    }
});

// 绑定角色模态框的事件
document.getElementById('cancel-char-binding-btn').addEventListener('click', () => {
    document.getElementById('bind-character-modal').classList.remove('visible');
});
document.getElementById('confirm-char-binding-btn').addEventListener('click', saveCountdownBindings);
document.getElementById('bind-character-grid').addEventListener('click', (e) => {
    const item = e.target.closest('.bind-char-item');
    if (item) {
        // 【全新】实现多选的切换逻辑
item.classList.toggle('selected');
    }
});
// ▲▲▲ 统一世界书模态框事件处理器结束 ▲▲▲

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
// 【全新】为分享目标的列表添加整行点击选择功能
document.getElementById('share-target-list').addEventListener('click', (e) => {
    // 1. 找到被点击的整行元素
    const item = e.target.closest('.contact-picker-item');
    if (!item) return;

    // 2. 找到行内的复选框
    const checkbox = item.querySelector('.share-target-checkbox');
    if (!checkbox) return;
    
    // 3. 如果用户就是直接点的复选框，我们什么都不做，让浏览器自己处理
    //    这样可以防止双重触发导致的“点不动”问题
    if (e.target === checkbox) {
        return;
    }
    
    // 4. 如果点击的是其他地方（如头像、名字、空白处），我们就用代码来切换复选框的选中状态
    checkbox.checked = !checkbox.checked;
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】人设展开编辑器事件处理 ▼▼▼
// 【全新】人设展开编辑器事件处理 (已集成预设编辑逻辑并修复展开功能)
document.getElementById('chat-settings-modal').addEventListener('click', async (e) => {
    const expandBtn = e.target.closest('.expand-persona-btn');
    const cancelBtn = e.target.closest('.cancel-expanded-btn');
    const saveBtn = e.target.closest('.save-expanded-btn');

    // ▼▼▼ 这是被我遗漏的、用于处理展开的核心逻辑，现已恢复 ▼▼▼
    if (expandBtn) {
        const targetId = expandBtn.dataset.target;
        let smallTextarea, expandedEditor, largeTextarea;

        if (targetId === 'css') {
            smallTextarea = document.getElementById('custom-css-input');
            expandedEditor = document.getElementById('css-editor-expanded');
        } else {
            smallTextarea = document.getElementById(`${targetId}-persona`);
            expandedEditor = document.getElementById(`${targetId}-persona-editor-expanded`);
        }

        if (smallTextarea && expandedEditor) {
            largeTextarea = expandedEditor.querySelector('.expanded-textarea');
            // 切换显示
            largeTextarea.value = smallTextarea.value;
            smallTextarea.style.display = 'none';
            expandedEditor.style.display = 'block';
        }
    }
    // ▲▲▲ 恢复代码结束 ▲▲▲

    if (cancelBtn) {
        const expandedEditor = cancelBtn.closest('.persona-editor-expanded');
        const formGroup = expandedEditor.closest('.form-group');
        const smallTextarea = formGroup.querySelector('textarea:not(.expanded-textarea)');

        // 切换显示
        expandedEditor.style.display = 'none';
        smallTextarea.style.display = 'block';

        // 取消编辑时，重置状态
        editingBubblePresetId = null;
    }

    if (saveBtn) {
        const expandedEditor = saveBtn.closest('.persona-editor-expanded');
        const formGroup = expandedEditor.closest('.form-group');
        const smallTextarea = formGroup.querySelector('textarea:not(.expanded-textarea)');
        const largeTextarea = expandedEditor.querySelector('.expanded-textarea');

        // 检查是否在编辑气泡预设
        if (expandedEditor.id === 'css-editor-expanded' && editingBubblePresetId) {
            const newCss = largeTextarea.value;
            await db.bubblePresets.update(editingBubblePresetId, { css: newCss });
            await renderBubblePresets();
            alert('预设已更新！');
            editingBubblePresetId = null; // 重置状态
        }
        
        // 原始逻辑：保存内容并切换显示
        smallTextarea.value = largeTextarea.value;
        expandedEditor.style.display = 'none';
        smallTextarea.style.display = 'block';
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

        // ===================================================================
        // 5. 启动！
            // ▼▼▼ 在这里粘贴 ▼▼▼
setupStatusAndDiarySystem();
/**
 * 【全新】打开并填充群聊心声弹窗
 */
/**
 /**
 /**
 * 【已修正】打开并填充群聊心声弹窗
 */
function openGroupStatusModal() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.isGroup) return;

    const modal = document.getElementById('group-status-modal');
    const titleEl = document.getElementById('group-status-modal-title');
    const listEl = document.getElementById('group-status-list');

    titleEl.textContent = `“${chat.name}”的心声`;
    listEl.innerHTML = ''; // 清空旧内容

    chat.members.forEach(member => {
        // 【关键修正1】在函数内部直接检查并兼容旧数据，防止脚本出错
        if (!member.displayStatus) {
            member.displayStatus = { innerThought: '...' };
        }

        const item = document.createElement('div');
        item.className = 'group-status-item';

        // 【关键修正2】现在会正确地从 member 对象中获取心声
        const thought = member.displayStatus.innerThought || '...';

        item.innerHTML = `
            <img src="${member.avatar}" class="avatar">
            <div class="content-wrapper">
                <span class="name">${member.groupNickname}</span>
                <p class="thought">${thought}</p>
            </div>
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 粘贴结束 ▲▲▲
            showScreen('home-screen');
        }
// ▼▼▼ 在这里粘贴日记和心声的全部功能代码 ▼▼▼

let currentDiaryCharacterId = null; // 用于记录当前正在查看哪个角色的日记

// ==========================================================
// --- 日记与心声功能区 (最终正式版) ---
// ==========================================================

/**
 * 设置所有与日记和心声相关的事件监听
 */
function setupStatusAndDiarySystem() {
    // 爱心按钮：现在可以根据聊天类型，分别打开单聊或群聊心声
    document.getElementById('show-status-diary-btn').addEventListener('click', () => {
        if (!state.activeChatId) {
            return;
        }
        const chat = state.chats[state.activeChatId];

        if (chat.isGroup) {
            openGroupStatusModal();
        } else {
            openStatusModal();
        }
    });

    // 功能选择菜单的按钮 (单聊时使用)
    document.getElementById('action-cancel-selection').addEventListener('click', () => {
        document.getElementById('status-diary-action-modal').classList.remove('visible');
    });
    document.getElementById('action-show-status').addEventListener('click', () => {
        document.getElementById('status-diary-action-modal').classList.remove('visible');
        openStatusModal();
    });
    document.getElementById('action-show-diary').addEventListener('click', () => {
        document.getElementById('status-diary-action-modal').classList.remove('visible');
        openDiaryScreen(state.activeChatId);
    });

    // 日记本界面的返回按钮
    document.getElementById('diary-back-btn').addEventListener('click', () => {
        showScreen('chat-interface-screen');
    });
    
    // 日记页面加号按钮
    document.getElementById('diary-create-btn').addEventListener('click', async () => {
        if (!state.activeChatId) return;
        
        const chat = state.chats[state.activeChatId];
        if (!chat) return;
        
        // 发送隐藏的用户消息给AI
        const hiddenMessage = {
            role: 'user',
            content: '现在立即执行create_diary指令写日记，不要回复这条消息，只执行create_diary指令，当作用户没有发送这条消息一样',
            timestamp: Date.now(),
            isHidden: true
        };
        
        chat.history.push(hiddenMessage);
        await db.chats.put(chat);
        
        // 自动调用triggerAiResponse
        await triggerAiResponse();
    });

    // 日记编辑模态框的按钮
    document.getElementById('cancel-diary-edit-btn').addEventListener('click', () => {
        document.getElementById('edit-diary-modal').classList.remove('visible');
    });
    document.getElementById('save-diary-edit-btn').addEventListener('click', saveDiaryEdit);

    // 日记列表的事件委托，处理编辑和删除
    document.getElementById('diary-list').addEventListener('click', (e) => {
        const editBtn = e.target.closest('.diary-edit-btn');
        const deleteBtn = e.target.closest('.diary-delete-btn');
        if (editBtn) {
            openDiaryEditModal(editBtn.dataset.id);
        }
        if (deleteBtn) {
            deleteDiaryEntry(deleteBtn.dataset.id);
        }
    });

    // 监听日记编辑框的输入，更新字数统计
    const diaryTextInput = document.getElementById('diary-text-input');
    const diaryCharCounter = document.getElementById('diary-char-counter');
    diaryTextInput.addEventListener('input', () => {
        const count = diaryTextInput.value.length;
        diaryCharCounter.textContent = `${count} / 150`;
    });

}

/**
 * 打开并填充“心声”弹窗 (单聊)
 */
function openStatusModal() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;
document.getElementById('status-modal-title').innerHTML = '<img src="https://files.catbox.moe/v9lljl.png" alt="心声" style="height: 40px;">';    document.getElementById('status-modal-thought').textContent = chat.displayStatus?.innerThought || '...';
    document.getElementById('status-modal').classList.add('visible');
}

/**
 * 【最终正式版】打开并填充群聊心声弹窗
 */
function openGroupStatusModal() {
    try {
        const chat = state.chats[state.activeChatId];
        if (!chat || !chat.isGroup) return;

        const modal = document.getElementById('group-status-modal');
        const titleEl = document.getElementById('group-status-modal-title');
        const listEl = document.getElementById('group-status-list');

titleEl.innerHTML = '<img src="https://files.catbox.moe/v9lljl.png" alt="心声" style="height: 40px;">';        listEl.innerHTML = ''; 

        if (!chat.members || chat.members.length === 0) {
             listEl.innerHTML = '<p>这个群还没有成员哦。</p>';
        } else {
            chat.members.forEach(member => {
                if (!member) {
                    console.error("发现一个空的成员对象，已跳过。");
                    return;
                }
                if (!member.displayStatus) {
                    member.displayStatus = { innerThought: '...' };
                }
                const item = document.createElement('div');
                item.className = 'group-status-item';
                const thought = member.displayStatus.innerThought || '...';

                item.innerHTML = `
                    <img src="${member.avatar || defaultGroupMemberAvatar}" class="avatar">
                    <div class="content-wrapper">
                        <span class="name">${member.groupNickname || member.originalName || '未知成员'}</span>
                        <p class="thought">${thought}</p>
                    </div>
                `;
                listEl.appendChild(item);
            });
        }

        modal.classList.add('visible');

    } catch (error) {
        // 在正式版中，我们将错误信息打印到控制台，而不是用弹窗打扰用户
        console.error("【严重错误】打开群聊心声弹窗时发生崩溃:", error);
    }
}


/**
 * 打开指定角色的日记本界面
 */
function openDiaryScreen(characterId) {
    currentDiaryCharacterId = characterId;
    const character = state.chats[characterId];
    if (!character) return;
    document.getElementById('diary-screen-title').textContent = `${character.name}的日记`;
    renderDiaryList();
    showScreen('diary-screen');
}

/**
 * 渲染日记列表
 */
function renderDiaryList() {
    const character = state.chats[currentDiaryCharacterId];
    const container = document.getElementById('diary-list');
    container.innerHTML = '';

    if (!character || !character.diary || character.diary.length === 0) {
        container.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">日记本还是空的呢...</p>';
        return;
    }

    [...character.diary].reverse().forEach(entry => {
        const card = document.createElement('div');
        card.className = 'diary-card';
        const date = new Date(entry.timestamp);
        const dateString = `${date.getFullYear()}年${String(date.getMonth() + 1).padStart(2, '0')}月${String(date.getDate()).padStart(2, '0')}日 ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;        
        card.innerHTML = `
            <div class="card-header">
                <span class="date">${dateString}</span>
                <div class="actions">
                    <button class="diary-edit-btn" data-id="${entry.id}" title="编辑">✏️</button>
                    <button class="diary-delete-btn" data-id="${entry.id}" title="删除">🗑️</button>
                </div>
            </div>
            <div class="card-body">${entry.content}</div>
        `;
        container.appendChild(card);
    });
}

/**
 * 打开日记编辑弹窗
 */
function openDiaryEditModal(diaryId) {
    const character = state.chats[currentDiaryCharacterId];
    const entry = character.diary.find(d => d.id === diaryId);
    if (!entry) return;

    const modal = document.getElementById('edit-diary-modal');
    modal.dataset.editingId = entry.id;
    const textInput = document.getElementById('diary-text-input');
    textInput.value = entry.content;
    document.getElementById('diary-char-counter').textContent = `${entry.content.length} / 150`;
    modal.classList.add('visible');
}

/**
 * 保存对日记的修改
 */
async function saveDiaryEdit() {
    const modal = document.getElementById('edit-diary-modal');
    const diaryId = modal.dataset.editingId;
    const newContent = document.getElementById('diary-text-input').value.trim();

    if (!newContent) {
        alert('日记内容不能为空哦。');
        return;
    }

    const character = state.chats[currentDiaryCharacterId];
    const entryIndex = character.diary.findIndex(d => d.id === diaryId);

    if (entryIndex > -1) {
        character.diary[entryIndex].content = newContent;
        await db.chats.put(character); // 保存到数据库
        renderDiaryList();
        modal.classList.remove('visible');
        alert('日记已更新');
    }
}

/**
 * 删除一条日记
 */
async function deleteDiaryEntry(diaryId) {
    const confirmed = await showCustomConfirm(
        '删除日记',
        '真的要撕掉这一页日记吗？',
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        const character = state.chats[currentDiaryCharacterId];
        character.diary = character.diary.filter(d => d.id !== diaryId);
        await db.chats.put(character); // 保存到数据库
        renderDiaryList();
        alert('一页回忆随风去啦...');
    }
}

// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼

// 【全新】为群聊面板中的复用按钮绑定与单聊相同的功能
document.getElementById('send-photo-btn-group').addEventListener('click', () => document.getElementById('send-photo-btn').click());
document.getElementById('upload-image-btn-group').addEventListener('click', () => document.getElementById('upload-image-btn').click());
document.getElementById('transfer-btn-group').addEventListener('click', () => document.getElementById('transfer-btn').click());
// ▼▼▼ 请用这段【新代码】替换旧的 'send-waimai-request-btn' 事件监听器 ▼▼▼
document.getElementById('send-waimai-request-btn').addEventListener('click', () => {waimaiModal.classList.add('visible');// 【核心修复】打开外卖弹窗后，立刻关闭功能面板closePlusPanel();
});
// 将 .click() 修改为直接调用函数
document.getElementById('share-link-btn-group').addEventListener('click', () => openShareLinkModal());document.getElementById('regenerate-btn-group').addEventListener('click', () => document.getElementById('regenerate-btn').click());

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】“查角色手机”功能事件监听器 ▼▼▼

        // 1. 角色选择列表的点击事件 (事件委托)
        document.getElementById('character-selection-list').addEventListener('click', (e) => {
            const item = e.target.closest('.character-select-item');
            if (item && item.dataset.chatId) {
                openCharacterPhone(item.dataset.chatId);
            }
        });

        // 【V3版】角色手机聊天列表的点击事件 (事件委托)
        document.getElementById('character-chat-list').addEventListener('click', (e) => {
            const item = e.target.closest('.chat-list-item');
            // 从 data-contact-name 获取要打开的聊天对象的名字
            if (item && item.dataset.contactName) {
                renderCharacterChatHistory(item.dataset.contactName);
                showCharacterPhonePage('character-chat-history-screen');
            }
        });

        // 2. 角色手机顶部的“刷新”和“清空”按钮
        document.getElementById('generate-character-data-btn').addEventListener('click', generateCharacterPhoneData);
        document.getElementById('clear-character-data-btn').addEventListener('click', clearCharacterPhoneData);

        // ▲▲▲ 事件监听器添加结束 ▲▲▲

        // ▼▼▼ 【全新】角色手机内部统一返回事件监听器 ▼▼▼
        document.getElementById('character-phone-container').addEventListener('click', (e) => {
            const backBtn = e.target.closest('.back-btn');
            if (!backBtn) return;

            // 检查是返回到角色手机内部页面，还是返回到主屏幕
            if (backBtn.dataset.targetPage) {
                showCharacterPhonePage(backBtn.dataset.targetPage);
            } else if (backBtn.dataset.targetScreen) {
                showScreen(backBtn.dataset.targetScreen);
            }
        });
        // ▲▲▲ 新代码粘贴结束 ▲▲▲

        // ▼▼▼ 【全新】角色手机日记APP事件监听器 ▼▼▼
        document.getElementById('character-app-grid').addEventListener('click', (e) => {
            const icon = e.target.closest('.app-icon');
            if (icon && icon.querySelector('.label').textContent === '日记') {
                renderCharacterDiary();
            }
        });
        document.getElementById('generate-diary-entry-btn').addEventListener('click', generateNewDiaryEntry);
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼

// 【全新】为“保存预设”按钮绑定点击事件
document.getElementById('save-bubble-preset-btn').addEventListener('click', saveCurrentBubbleCssAsPreset);

// 【全新】使用事件委托处理“应用”、“编辑”和“删除”按钮的点击
document.getElementById('bubble-presets-list').addEventListener('click', async (e) => {
    const target = e.target;
    const presetId = parseInt(target.dataset.id);

    if (isNaN(presetId)) return;

    // 如果点击的是“应用”按钮
    if (target.classList.contains('apply-btn')) {
        const preset = await db.bubblePresets.get(presetId);
        if (preset) {
            const cssInput = document.getElementById('custom-css-input');
            cssInput.value = preset.css;
            updateSettingsPreview(); // 应用后立即更新预览
        }
    }

    // 如果点击的是“编辑”按钮
    if (target.classList.contains('edit-btn')) {
        handleEditBubblePreset(presetId);
    }

    // 如果点击的是“删除”按钮
    if (target.classList.contains('delete-btn')) {
        const confirmed = await showCustomConfirm('删除预设', '确定要删除这个气泡预设吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.bubblePresets.delete(presetId);
            await renderBubblePresets(); // 删除后立即刷新列表
        }
    }
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼

// ▼▼▼ 请用这段【新代码】替换旧的 plusBtn 事件监听器 ▼▼▼

// ▼▼▼ 请用这段【新代码】替换从 “// 【全新】为“+”号按钮添加点击事件” 开始的那整块代码 ▼▼▼

// 【全新增强版】为"+"号按钮添加点击事件，根据聊天类型显示不同面板
const plusBtn = document.getElementById('chat-plus-btn');
const singlePanel = document.getElementById('chat-plus-panel-single');
const groupPanel = document.getElementById('chat-plus-panel-group');

if (plusBtn && singlePanel && groupPanel) {
    plusBtn.addEventListener('click', () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    // 根据是否为群聊，决定要操作哪个面板
    const targetPanel = chat.isGroup ? groupPanel : singlePanel;
    const otherPanel = chat.isGroup ? singlePanel : groupPanel;

    // 获取聊天界面容器和消息区域
    const chatInterface = document.getElementById('chat-interface-screen');
    const messagesContainer = document.getElementById('chat-messages');

    // 切换目标面板的显示状态
    const isCurrentlyVisible = targetPanel.classList.contains('visible');
    targetPanel.classList.toggle('visible');
    
    // 根据面板状态调整聊天界面
    if (!isCurrentlyVisible) {
        // 面板即将展开
    chatInterface.classList.add('panel-expanded');
    
    // 【核心修正】恢复滚动逻辑，但移除 behavior: 'smooth'
    if (messagesContainer && messagesContainer.scrollHeight > messagesContainer.clientHeight) {
        // 立即滚动到底部，为接下来的CSS动画准备好视觉位置
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
} else {
        // 面板即将收起
        chatInterface.classList.remove('panel-expanded');
    }
    
    // 确保另一个面板总是隐藏的
    if (otherPanel.classList.contains('visible')) {
        otherPanel.classList.remove('visible');
        // 如果另一个面板被关闭，也需要检查是否还有面板展开
        if (!targetPanel.classList.contains('visible')) {
            chatInterface.classList.remove('panel-expanded');
        }
    }
    });
}

// ▼▼▼ 面板滑动翻页功能 ▼▼▼
// ▼▼▼ 请用这个【修正后】的函数，完整替换您现有的旧版本 ▼▼▼
function initializePanelSwipe() {
    const panels = [singlePanel, groupPanel];
    
    panels.forEach(panel => {
        if (!panel) return;
        
        const container = panel.querySelector('.plus-panel-container');
        const pagesContainer = panel.querySelector('.plus-panel-pages');
        const dots = panel.querySelectorAll('.pagination-dot');
        const pages = panel.querySelectorAll('.plus-panel-page');
        
        if (!container || !pagesContainer || !dots.length || !pages.length) return;
        
        let currentPage = 1;
        let startX = 0;
        let startY = 0; // 新增：记录起始Y坐标
        let isDragging = false;
        let swipeDirection = null; // 新增：记录滑动方向

        function updatePage(pageNumber) {
            currentPage = pageNumber;
            const translateX = (pageNumber - 1) * -50;
            pagesContainer.style.transform = `translateX(${translateX}%)`;
            dots.forEach((dot, index) => dot.classList.toggle('active', index + 1 === pageNumber));
            pages.forEach((page, index) => page.classList.toggle('active', index + 1 === pageNumber));
        }

        function handleStart(clientX, clientY) {
            startX = clientX;
            startY = clientY; // 新增
            isDragging = true;
            swipeDirection = null; // 重置方向
            pagesContainer.style.transition = 'none';
        }

        function handleMove(clientX, clientY) {
            if (!isDragging) return;

            const deltaX = clientX - startX;
            const deltaY = clientY - startY; // 新增

            // --- 核心修改1：判断滑动方向 ---
            if (swipeDirection === null) {
                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) { // 超过阈值才判断
                    swipeDirection = Math.abs(deltaX) > Math.abs(deltaY) ? 'horizontal' : 'vertical';
                }
            }

            // --- 核心修改2：只有水平滑动时才阻止默认行为并移动面板 ---
            if (swipeDirection === 'horizontal') {
                event.preventDefault(); // 在这里才阻止！
                const currentTransform = (currentPage - 1) * -50;
                const newTransform = currentTransform + (deltaX / container.offsetWidth) * 50;
                const maxTransform = Math.max(-50, Math.min(0, newTransform));
                pagesContainer.style.transform = `translateX(${maxTransform}%)`;
            }
        }

        function handleEnd(clientX) {
            if (!isDragging) return;
            isDragging = false;
            pagesContainer.style.transition = 'transform 0.3s ease';

            if (swipeDirection === 'horizontal') {
                const deltaX = clientX - startX;
                const threshold = 50; // 滑动超过50像素才翻页

                if (deltaX < -threshold && currentPage === 1) {
                    updatePage(2);
                } else if (deltaX > threshold && currentPage === 2) {
                    updatePage(1);
                } else {
                    updatePage(currentPage); // 滑动不够，弹回
                }
            } else {
                 updatePage(currentPage); // 垂直滑动或点击，弹回
            }
        }

        // --- 触摸事件（移动端）---
        container.addEventListener('touchstart', (e) => {
            // --- 核心修改3：不再在这里调用 e.preventDefault() ---
            handleStart(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });

        container.addEventListener('touchmove', (e) => {
            // 将 event 传给 handleMove
            handleMove(e.touches[0].clientX, e.touches[0].clientY, e);
        }, { passive: false });

        container.addEventListener('touchend', (e) => {
            handleEnd(e.changedTouches[0].clientX);
        });

        // --- 鼠标事件（桌面端，逻辑保持基本不变）---
        container.addEventListener('mousedown', (e) => {
             e.preventDefault();
             handleStart(e.clientX, e.clientY);
        });
         document.addEventListener('mousemove', (e) => {
             if (isDragging) {
                 handleMove(e.clientX, e.clientY, e);
             }
         });
         document.addEventListener('mouseup', (e) => {
             if (isDragging) {
                 handleEnd(e.clientX);
             }
         });

        // 点击指示器切换页面
        dots.forEach((dot, index) => {
            dot.addEventListener('click', () => {
                updatePage(index + 1);
            });
        });
    });
}
// ▼▼▼ 【全新添加】更强大的Base64解码器，用于处理特殊字符 ▼▼▼
/**
 * 解码包含Unicode字符的Base64字符串
 * @param {string} str - Base64编码的字符串
 * @returns {string} - 解码后的UTF-8字符串
 */
function decodeBase64Unicode(str) {
    return decodeURIComponent(atob(str).split('').map(function(c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));
}
// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 【最终终极版】PNG/JPG角色卡导入核心功能 (v4.1 - 增强调试与修复) ▼▼▼

/**
 * 从图片文件中提取并解析角色数据（兼容PNG/JPG，支持zTXt解压）
 * @param {File} file - 用户选择的图片文件
 * @returns {Promise<object|null>} - 解析后的角色JSON数据，或在失败时返回null
 */
function extractCharacterDataFromImage(file) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            const buffer = event.target.result;
            const view = new DataView(buffer);

            const isPng = view.byteLength > 8 && view.getUint32(0) === 0x89504E47 && view.getUint32(4) === 0x0D0A1A0A;
            
            try {
                if (isPng) {
                    console.log("检测到PNG文件，开始解析数据块...");
                    let offset = 8;
                    while (offset < view.byteLength) {
                        const length = view.getUint32(offset);
                        const type = String.fromCharCode(view.getUint8(offset + 4), view.getUint8(offset + 5), view.getUint8(offset + 6), view.getUint8(offset + 7));
                        
                        // 为调试添加日志，显示找到的数据块
                        console.log(`找到数据块: ${type}, 长度: ${length}`);

                        if (type === 'tEXt' || type === 'zTXt') {
                            const dataOffset = offset + 8;
                            const chunkData = new Uint8Array(buffer, dataOffset, length);
                            
                            const separatorIndex = Array.from(chunkData).indexOf(0);
                            if (separatorIndex > 0) {
                                const key = new TextDecoder('latin1').decode(chunkData.slice(0, separatorIndex));
                                
                                if (key === 'chara') {
                                    console.log("成功匹配到 'chara' 键!");
                                    let text;
                                    try {
                                        if (type === 'tEXt') {
                                            const valueData = chunkData.slice(separatorIndex + 1);
                                            text = new TextDecoder('latin1').decode(valueData);
                                        } else { // zTXt
                                            console.log("检测到 zTXt 压缩数据，正在使用 pako 解压...");
                                            const valueData = chunkData.slice(separatorIndex + 2);
                                            const decompressed = pako.inflate(valueData);
                                            text = new TextDecoder('utf-8').decode(decompressed);
                                        }
                                        
                                        const decodedData = decodeBase64Unicode(text);
                                        const charData = JSON.parse(decodedData);
                                        console.log("成功解析出角色数据！", charData);
                                        resolve(charData);
                                        return;
                                    } catch(e) {
                                        console.error(`解析 'chara' 数据时出错 (${type}):`, e);
                                        // 不停止，继续寻找下一个可能的chara块
                                    }
                                }
                            }
                        }
                        offset += 12 + length; // 移动到下一个数据块
                    }
                } else {
                    console.log("检测到非PNG文件(可能是JPG)，开始启发式扫描...");
                    const text = new TextDecoder('latin1').decode(buffer);
                    let startIndex = text.indexOf('ey'); // 'ey' 是 many base64 encoded JSONs start with
                    while(startIndex !== -1) {
                        const potentialB64 = text.substring(startIndex);
                        try {
                            const decodedData = decodeBase64Unicode(potentialB64);
                            if (decodedData.trim().startsWith('{')) {
                                const charData = JSON.parse(decodedData);
                                if (charData.name && (charData.description || charData.persona)) {
                                    console.log("成功在JPG中启发式扫描到角色数据！");
                                    resolve(charData);
                                    return;
                                }
                            }
                        } catch (e) { /* 忽略解析错误并继续 */ }
                        startIndex = text.indexOf('ey', startIndex + 1);
                    }
                }
                
                console.log("扫描完成，未在图片中找到有效的角色数据。");
                resolve(null);

            } catch (error) {
                console.error("解析角色卡时发生严重错误:", error);
                resolve(null);
            }
        };
        reader.onerror = () => {
            console.error("读取文件失败");
            resolve(null);
        };
        reader.readAsArrayBuffer(file);
    });
}

/**
 * 【最终兼容版 v4 - 完美世界书导入】处理角色卡导入的主要逻辑
 * @param {File} file - 用户选择的图片文件
 */
async function handleCharacterCardImport(file) {
    if (!file) return;
    if (!state.activeChatId) {
        alert("请先进入一个聊天窗口再导入角色卡！");
        return;
    }

    const rawCharData = await extractCharacterDataFromImage(file);
    
    // 步骤 1: 智能定位核心数据 (兼容TavernAI V2卡和旧版卡)
    const charData = rawCharData?.data ? rawCharData.data : rawCharData;
    const persona = charData?.persona || charData?.description;

    if (!charData || !persona) {
        await showCustomAlert('导入失败', '无法从此图片中读取有效的角色数据。请确保这是一个标准的PNG角色卡。\n\n提示：你可以使用“角色卡诊断工具”来查看图片内部的原始数据。');
        return;
    }

    const chat = state.chats[state.activeChatId];
    
    // 步骤 2: 更新人设
    chat.settings.aiPersona = persona;
    const personaTextarea = document.getElementById('ai-persona');
    if(personaTextarea) personaTextarea.value = persona;
    
    let worldBooksImported = 0;
    let characterNameForCategory = charData.name || "导入角色"; // 使用角色卡的名字作为分类名

    // ================== 【全新、更健壮的世界书解析逻辑】 ==================

    // 检查是否存在符合你提供的 character_book 格式的数据
    if (charData.character_book && Array.isArray(charData.character_book.entries)) {
        const bookData = charData.character_book;
        const entries = bookData.entries;

        if (entries.length > 0) {
            // 步骤 3: 检查或创建以角色名命名的分类
            let category = await db.worldBookCategories.where('name').equals(characterNameForCategory).first();
            let categoryId;
            if (!category) {
                // 如果分类不存在，就创建一个新的
                categoryId = await db.worldBookCategories.add({ name: characterNameForCategory });
            } else {
                categoryId = category.id;
            }

            const booksToUpdate = [];
            for (const entry of entries) {
                // 智能获取条目名称: 优先使用 "name" 字段，如果没有，则使用 "comment" 字段
                const bookName = entry.name || entry.comment;
                const bookContent = entry.content;

                // 【核心过滤】: 必须同时有名称和有效内容才进行导入
                if (!bookName || !bookContent || !bookContent.trim()) {
                    continue; // 跳过无效条目
                }

                // 检查这个条目是否已存在于此分类中
                const existingBook = await db.worldBooks.where({ name: bookName, categoryId: categoryId }).first();
                
                if (existingBook) {
                    // 如果已存在，则更新内容
                    existingBook.content = bookContent;
                    booksToUpdate.push(existingBook);
                } else {
                    // 如果不存在，则创建新条目
                    booksToUpdate.push({
                        id: 'wb_' + Date.now() + '_' + Math.random().toString(16).slice(2),
                        name: bookName,
                        content: bookContent,
                        categoryId: categoryId // 关联到新建的分类
                    });
                }
            }

            if (booksToUpdate.length > 0) {
                await db.worldBooks.bulkPut(booksToUpdate);
                worldBooksImported = booksToUpdate.length;

                // 更新内存中的 state.worldBooks，确保数据同步
                for (const book of booksToUpdate) {
                    const existingIndex = state.worldBooks.findIndex(wb => wb.id === book.id);
                    if (existingIndex > -1) {
                        state.worldBooks[existingIndex] = book;
                    } else {
                        state.worldBooks.push(book);
                    }
                }
            }
        }
    }
    
    // ================== 【世界书解析逻辑结束】 ==================

    await db.chats.put(chat);
    
    let successMessage = `角色 “${charData.name || '未知'}” 的人设已成功导入！`;
    if (worldBooksImported > 0) {
        successMessage += `\n\n同时，成功导入了 ${worldBooksImported} 条世界书条目到 “${characterNameForCategory}” 分类下。`;
        // 如果当前就在世界书页面，则立即刷新
        if(document.getElementById('world-book-screen').classList.contains('active')) {
            await renderWorldBookScreen();
        }
    }
    
    await showCustomAlert('导入成功', successMessage);
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
/**
 * 【辅助函数】将解析好的世界书条目保存到数据库
 * @param {Array} booksToImport - 包含{name, content}对象的数组
 * @param {number|null} categoryId - 目标分类的ID，如果为null则为未分类
 * @returns {Promise<number>} - 成功导入/更新的条目数量
 */
async function saveWorldBookEntries(booksToImport, categoryId) {
    const booksToUpdate = [];
    for (const newBook of booksToImport) {
        // 根据是否有categoryId，查询条件不同
        const query = categoryId ? { name: newBook.name, categoryId: categoryId } : { name: newBook.name, categoryId: null };
        const existingBook = await db.worldBooks.where(query).first();
        
        if (existingBook) {
            existingBook.content = newBook.content;
            booksToUpdate.push(existingBook);
        } else {
            booksToUpdate.push({
                id: 'wb_' + Date.now() + '_' + Math.random().toString(16).slice(2),
                name: newBook.name,
                content: newBook.content,
                categoryId: categoryId // 应用传入的分类ID
            });
        }
    }

    if (booksToUpdate.length > 0) {
        await db.worldBooks.bulkPut(booksToUpdate);
        // 同步内存中的 state
        for (const book of booksToUpdate) {
            const existingIndex = state.worldBooks.findIndex(wb => wb.id === book.id);
            if (existingIndex > -1) {
                state.worldBooks[existingIndex] = book;
            } else {
                state.worldBooks.push(book);
            }
        }
    }
    return booksToUpdate.length;
}

/**
 * 【辅助函数】弹出模态框，让用户选择分类
 * @param {Array} parsedBooks - 已从文件解析出的书籍对象数组
 * @returns {Promise<{choice: string, name?: string}|null>} - 用户的选择
 */
function promptForCategoryChoice(parsedBooks) {
    return new Promise(resolve => {
        const modal = document.getElementById('import-wb-category-modal');
        const input = document.getElementById('import-new-category-name');
        const confirmBtn = document.getElementById('confirm-import-new-category');
        const uncategorizedBtn = document.getElementById('import-uncategorized');
        const cancelBtn = document.getElementById('cancel-wb-import');

        // 尝试从文件名或内容中获取一个建议的分类名
        const bookTitle = parsedBooks[0]?.name || "新分类";
        input.value = bookTitle;

        // 使用 .cloneNode(true) 来移除旧的事件监听器，防止重复触发
        const cleanConfirmBtn = confirmBtn.cloneNode(true);
        const cleanUncategorizedBtn = uncategorizedBtn.cloneNode(true);
        const cleanCancelBtn = cancelBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(cleanConfirmBtn, confirmBtn);
        uncategorizedBtn.parentNode.replaceChild(cleanUncategorizedBtn, uncategorizedBtn);
        cancelBtn.parentNode.replaceChild(cleanCancelBtn, cancelBtn);

        // 为新按钮绑定事件
        cleanConfirmBtn.onclick = () => {
            const categoryName = input.value.trim();
            if (!categoryName) {
                alert('分类名称不能为空！');
                return;
            }
            modal.classList.remove('visible');
            resolve({ choice: 'new', name: categoryName });
        };

        cleanUncategorizedBtn.onclick = () => {
            modal.classList.remove('visible');
            resolve({ choice: 'uncategorized' });
        };

        cleanCancelBtn.onclick = () => {
            modal.classList.remove('visible');
            resolve(null); // 用户取消
        };

        modal.classList.add('visible');
    });
}

/**
 * 【全新重构版】处理独立的 .json 或 .txt 世界书文件导入
 * @param {File} file - 用户选择的文件
 */
async function handleWorldBookImport(file) {
    const fileName = file.name;
    const fileExtension = fileName.split('.').pop().toLowerCase();
    const reader = new FileReader();

    reader.onload = async (event) => {
        const fileContent = event.target.result;
        let parsedBooks = [];

        try {
            // 步骤 1: 解析文件内容
            if (fileExtension === 'json') {
                const data = JSON.parse(fileContent);
                if (data && data.entries && typeof data.entries === 'object') {
                    for (const entry of Object.values(data.entries)) {
                        const bookName = entry.comment;
                        const bookContent = entry.content;
                        if (bookName && bookContent && bookContent.trim()) {
                            parsedBooks.push({ name: bookName, content: bookContent });
                        }
                    }
                }
            } else if (fileExtension === 'txt') {
                const bookName = fileName.replace(/\.[^/.]+$/, '');
                if (fileContent && fileContent.trim()) {
                    parsedBooks.push({ name: bookName, content: fileContent });
                }
            }

            if (parsedBooks.length === 0) {
                await showCustomAlert('导入提示', '文件中没有找到可以导入的有效世界书条目。');
                return;
            }

            // 步骤 2: 弹出模态框，等待用户选择
            closeUnifiedModal(); // 先关闭主管理面板
            const userChoice = await promptForCategoryChoice(parsedBooks);

            if (!userChoice) { // 用户点击了取消
                return;
            }

            // 步骤 3: 根据用户选择，执行保存
            let categoryId = null;
            let categoryName = "未分类";

            if (userChoice.choice === 'new') {
                categoryName = userChoice.name;
                let category = await db.worldBookCategories.where('name').equals(categoryName).first();
                if (!category) {
                    categoryId = await db.worldBookCategories.add({ name: categoryName });
                } else {
                    categoryId = category.id;
                }
            }

            const importedCount = await saveWorldBookEntries(parsedBooks, categoryId);

            // 步骤 4: 提供最终反馈
            await showCustomAlert('导入成功', `已成功导入/更新 ${importedCount} 条世界书条目到 “${categoryName}” 分类中。`);
            await renderWorldBookScreen();

        } catch (error) {
            console.error("导入世界书失败:", error);
            await showCustomAlert('导入失败', `处理文件时发生错误: ${error.message}`);
        }
    };

    reader.onerror = async () => {
        await showCustomAlert('导入失败', '读取文件时发生错误。');
    };

    reader.readAsText(file);
}
// ▲▲▲ JavaScript功能函数定义区结束 ▲▲▲
// 初始化滑动功能
if (singlePanel && groupPanel) {
    initializePanelSwipe();
}

// ▼▼▼ 添加点击聊天消息区域时关闭面板的功能 ▼▼▼
const chatMessagesEl = document.getElementById('chat-messages');
if (chatMessagesEl) {
    chatMessagesEl.addEventListener('click', () => {
        const chatInterface = document.getElementById('chat-interface-screen');
        const singlePanel = document.getElementById('chat-plus-panel-single');
        const groupPanel = document.getElementById('chat-plus-panel-group');
        
        // 检查是否有面板展开
        if (singlePanel && groupPanel && (singlePanel.classList.contains('visible') || groupPanel.classList.contains('visible'))) {
            // 关闭所有面板
            singlePanel.classList.remove('visible');
            groupPanel.classList.remove('visible');
            if (chatInterface) chatInterface.classList.remove('panel-expanded');
        }
    });
}

// ▼▼▼ 请将这段【新代码】粘贴到 plusBtn 事件监听器的下方 ▼▼▼

// 【全新修正】为所有 class="modal" 的弹窗添加通用的外部点击关闭功能
document.getElementById('phone-screen').addEventListener('click', (e) => {
    // 检查点击的目标是否是弹窗的蒙层本身 (class 包含 'modal' 和 'visible')
    if (e.target.classList.contains('modal') && e.target.classList.contains('visible')) {
        // 如果是，就将其关闭
        e.target.classList.remove('visible');
    }
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// 【全新增强版】点击聊天消息区域时，自动收起所有功能面板
document.getElementById('chat-messages').addEventListener('click', () => {
    if (singlePanel.classList.contains('visible')) {
        singlePanel.classList.remove('visible');
    }
    if (groupPanel.classList.contains('visible')) {
        groupPanel.classList.remove('visible');
    }
});

// ▲▲▲ 替换结束 ▲▲▲
        // ▼▼▼ 统一世界书模态框事件处理器 ▼▼▼
        document.getElementById('unified-modal-close').addEventListener('click', closeUnifiedModal);
        document.getElementById('unified-modal-done').addEventListener('click', () => {
            // Check which view is currently visible and perform appropriate action
            const createBookView = document.getElementById('unified-create-book');
            if (createBookView && createBookView.style.display !== 'none') {
                // If in create book view, save the book
                saveUnifiedBook();
            } else {
                // Otherwise just close the modal
                closeUnifiedModal();
            }
        });
        document.getElementById('unified-add-category-btn').addEventListener('click', addUnifiedCategory);
        
        // 菜单项点击事件
        document.querySelectorAll('.unified-menu-item').forEach(item => {
            item.addEventListener('click', () => {
                const action = item.getAttribute('data-action');
                if (action) {
                    showUnifiedView(action);
                }
            });
        });
        
        // 使用事件委托处理动态生成的删除分类按钮
        document.getElementById('unified-categories-list').addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-group-btn')) {
                const categoryId = parseInt(e.target.dataset.id);
                if (!isNaN(categoryId)) {
                    deleteUnifiedCategory(categoryId);
                }
            }
        });
        
        // 键盘快捷键支持
        document.getElementById('unified-new-category-name').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addUnifiedCategory();
            }
        });
        
        document.getElementById('unified-book-name').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('unified-book-content').focus();
            }
        });
        
        // 点击模态框背景关闭
        document.getElementById('world-book-unified-modal').addEventListener('click', (e) => {
            if (e.target.id === 'world-book-unified-modal') {
                closeUnifiedModal();
            }
        });
        // ▲▲▲ 统一世界书模态框事件处理器结束 ▲▲▲
        
        // 微信风格操作面板按钮区域点击事件：让整个按钮区域都可以点击
        document.addEventListener('click', (e) => {
            const actionBtn = e.target.closest('.wechat-action-btn');
            if (actionBtn) {
                const button = actionBtn.querySelector('button');
                if (button && !e.target.matches('button')) {
                    // 如果点击的不是button本身，就触发button的点击事件
                    e.preventDefault();
                    button.click();
                    return;
                }
            }
        });

        // 全局点击事件监听器：实现点击外部关闭微信风格操作面板
        document.addEventListener('click', (e) => {
            const panel = document.getElementById('wechat-style-actions-panel');
            if (!panel || panel.style.display === 'none' || panel.style.opacity === '0') {
                return; // 面板不可见时直接返回
            }
            
            // 如果面板刚显示，忽略此次点击（防止长按松手时立即关闭面板）
            if (window.panelJustShown) {
                return;
            }
            
            // 检查点击的目标是否是面板本身或面板内部的元素
            if (panel.contains(e.target)) {
                // 点击了面板内部，但如果是按钮，先让按钮事件处理完再关闭面板
                const clickedButton = e.target.closest('button');
                if (clickedButton && clickedButton.id) {
                    // 延迟关闭面板，让按钮事件先执行
                    setTimeout(() => {
                        hideMessageActions();
                    }, 50);
                }
                return;
            } else {
                // 点击了面板外部，隐藏面板
                hideMessageActions();
            }
        });

        // 全局点击事件监听器：点击其他地方隐藏重roll按钮
        document.addEventListener('click', (e) => {
            // 如果没有激活的重roll按钮，直接返回
            if (!currentActiveRerollBtn) return;
            
            // 如果点击的是AI气泡或重roll按钮本身，不隐藏
            const clickedAiBubble = e.target.closest('.call-message-bubble.ai-speech');
            const clickedRerollBtn = e.target.closest('.reroll-btn');
            
            if (clickedAiBubble || clickedRerollBtn) {
                return;
            }
            
            // 点击了其他地方，隐藏重roll按钮
            hideAllRerollButtons();
        });
        // ▼▼▼ 【全新添加】角色卡导入功能事件绑定 ▼▼▼
            document.getElementById('import-character-card-btn').addEventListener('click', () => {
                document.getElementById('character-card-input').click();
            });

            document.getElementById('character-card-input').addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    handleCharacterCardImport(file);
                }
                // 重置文件输入框，以便下次可以选择相同的文件
                event.target.value = null; 
            });
            // ▲▲▲ 添加结束 ▲▲▲
            // ▼▼▼ 【全新】角色卡诊断工具事件绑定 ▼▼▼
document.getElementById('open-card-diagnostic-tool').addEventListener('click', () => {
    document.getElementById('card-diagnostic-modal').classList.add('visible');
    document.getElementById('diagnostic-output').textContent = '等待上传文件...';
});

document.getElementById('close-diagnostic-modal-btn').addEventListener('click', () => {
    document.getElementById('card-diagnostic-modal').classList.remove('visible');
});

document.getElementById('diagnostic-card-input').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    const outputEl = document.getElementById('diagnostic-output');
    if (file) {
        outputEl.textContent = '正在读取和分析文件...';
        const diagnosticResult = await diagnoseCharacterCard(file);
        outputEl.textContent = diagnosticResult;
    }
    event.target.value = null; // 为下次上传重置
});
// ▲▲▲ 新增事件绑定结束 ▲▲▲
// ▼▼▼ 【全新】世界书独立导入功能事件绑定 ▼▼▼
const worldBookImportInput = document.getElementById('world-book-import-input');

// 使用事件委托，为新的菜单项绑定事件
document.getElementById('unified-main-menu').addEventListener('click', (e) => {
    const menuItem = e.target.closest('.unified-menu-item');
    if (menuItem && menuItem.dataset.action === 'import-book') {
        worldBookImportInput.click(); // 点击菜单项时，触发隐藏的文件选择器
    }
});

// 监听文件选择器的变化
worldBookImportInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        handleWorldBookImport(file);
    }
    event.target.value = null; // 重置，以便下次可以选择相同的文件
});
// ▲▲▲ 新事件绑定结束 ▲▲▲

// 【全新】为“刷新记忆锚点”按钮绑定事件
document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
    if (e.target.closest('#refresh-memory-anchor-btn')) {
        const chat = state.chats[state.activeChatId];
        if (!chat) return;

        // 计算已总结消息的数量
        const summarizedCount = chat.history.filter(msg => msg.isSummarized).length;
        
        const anchorInput = document.getElementById('memory-anchor-input');
        // 将锚点设置为已总结数量，这样AI就会从第一条未总结的消息开始读取
        anchorInput.value = summarizedCount; 
        
        alert(`记忆锚点已刷新到第 ${summarizedCount} 条消息之后。请点击“保存”以生效。`);
    }
});
        // init() 函数结束 - 所有初始化代码已完成
        init();
    });
</script>
<input type="file" id="character-card-input" accept="image/png, image/jpeg" style="display: none;">
<div id="card-diagnostic-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>角色卡诊断工具</span>
        </div>
        <div class="modal-body">
            <p style="font-size: 14px; color: #666;">请上传您的PNG角色卡，下方将显示所有读取到的文本数据块。</p>
            <input type="file" id="diagnostic-card-input" accept="image/png" style="margin-top: 10px;">
            <hr style="margin: 20px 0; opacity: 0.2;">
            <pre id="diagnostic-output" style="white-space: pre-wrap; word-wrap: break-word; background-color: #f0f0f0; padding: 10px; border-radius: 5px; max-height: 300px; overflow-y: auto; color: #333;"></pre>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-diagnostic-modal-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<input type="file" id="world-book-import-input" accept=".json,.txt" style="display: none;">
<div id="import-wb-category-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>选择导入方式</span>
        </div>
        <div class="modal-body">
            <p style="font-size: 14px; color: var(--text-secondary); text-align: center; margin-bottom: 20px;">
                要为这些世界书条目创建一个新的分类吗？
            </p>
            <div class="form-group">
                <label for="import-new-category-name">新分类名称</label>
                <input type="text" id="import-new-category-name" placeholder="例如：角色名 或 故事名">
            </div>
        </div>
        <div class="modal-footer" style="flex-direction: column; gap: 10px; padding: 15px;">
            <button class="save" id="confirm-import-new-category" style="width: 100%;">创建新分类并导入</button>
            <button class="cancel" id="import-uncategorized" style="width: 100%;">导入到“未分类”</button>
            <button class="cancel" id="cancel-wb-import" style="width: 100%; margin-top: 5px; background-color: #f0f0f0;">取消导入</button>
        </div>
    </div>
</div>

<!-- 【记忆功能】记忆管理弹窗 -->
<div id="memory-summary-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header" style="flex-shrink: 0;">
            <span>核心记忆管理</span>
        </div>
        <div class="modal-body" style="display: flex; flex-direction: column; flex-grow: 1; min-height: 0;">
            <div id="memory-stats" style="font-size: 12px; color: var(--text-secondary); margin-bottom: 10px; padding: 8px; background-color: #f5f5f5; border-radius: 6px; flex-shrink: 0;">
                <div style="margin-bottom: 5px; display: flex;">
                    <span style="width: 50%;">已总结消息：<span id="summarized-count">0</span></span>
                    <span style="width: 50%;">待总结消息：<span id="pending-count">0</span></span>
                </div>
                <div style="display: flex;">
                    <span style="width: 50%;">总消息数：<span id="total-count">0</span></span>
                    <span style="width: 50%;">上下文Token：<span id="context-token-count">0</span></span>
                </div>
            </div>
            <textarea id="memory-summary-textarea" style="width: 100%; flex-grow: 1; min-height: 0; resize: none; border-radius: 8px; border: 1px solid var(--border-color); padding: 10px; font-size: 14px; box-sizing: border-box; overflow-y: auto;"></textarea>
        </div>
        <div class="modal-footer" style="justify-content: space-between; flex-shrink: 0;">
            <button class="form-button form-button-secondary" id="force-summarize-btn" style="flex: 1;">总结</button>
            <button class="form-button form-button-secondary" id="delete-summary-btn" style="flex: 1; background-color: #AB4D3F; color: white; border-color: #AB4D3F;">删除记忆</button>
            <button class="form-button form-button-secondary" id="save-summary-btn" style="flex: 1;">保存</button>
        </div>
    </div>
</div>

</body>
</html>
